input AbortQueuedMigrationsInput {
  clientMutationId: String
  ownerId: ID!
}

type AbortQueuedMigrationsPayload {
  clientMutationId: String
  success: Boolean
}

input AbortRepositoryMigrationInput {
  clientMutationId: String
  migrationId: ID!
}

type AbortRepositoryMigrationPayload {
  clientMutationId: String
  success: Boolean
}

input AcceptEnterpriseAdministratorInvitationInput {
  clientMutationId: String
  invitationId: ID!
}

type AcceptEnterpriseAdministratorInvitationPayload {
  clientMutationId: String
  invitation: EnterpriseAdministratorInvitation
  message: String
}

input AcceptTopicSuggestionInput {
  clientMutationId: String
  repositoryId: ID
  name: String
}

type AcceptTopicSuggestionPayload {
  clientMutationId: String
  topic: Topic
}

interface Actor {
  avatarUrl(size: URI!): URI!
  login: String!
  resourcePath: URI!
  url: URI!
}

type ActorLocation {
  city: String
  country: String
  countryCode: String
  region: String
  regionCode: String
}

enum ActorType {
  USER
  TEAM
}

input AddAssigneesToAssignableInput {
  clientMutationId: String
  assignableId: ID!
  assigneeIds: []!
}

type AddAssigneesToAssignablePayload {
  assignable: Assignable
  clientMutationId: String
}

input AddCommentInput {
  clientMutationId: String
  subjectId: ID!
  body: String!
}

type AddCommentPayload {
  clientMutationId: String
  commentEdge: IssueCommentEdge
  subject: Node
  timelineEdge: IssueTimelineItemEdge
}

input AddDiscussionCommentInput {
  clientMutationId: String
  discussionId: ID!
  replyToId: ID
  body: String!
}

type AddDiscussionCommentPayload {
  clientMutationId: String
  comment: DiscussionComment
}

input AddDiscussionPollVoteInput {
  clientMutationId: String
  pollOptionId: ID!
}

type AddDiscussionPollVotePayload {
  clientMutationId: String
  pollOption: DiscussionPollOption
}

input AddEnterpriseOrganizationMemberInput {
  clientMutationId: String
  enterpriseId: ID!
  organizationId: ID!
  userIds: []!
  role: OrganizationMemberRole
}

type AddEnterpriseOrganizationMemberPayload {
  clientMutationId: String
  users: [User!]
}

input AddEnterpriseSupportEntitlementInput {
  clientMutationId: String
  enterpriseId: ID!
  login: String!
}

type AddEnterpriseSupportEntitlementPayload {
  clientMutationId: String
  message: String
}

input AddLabelsToLabelableInput {
  clientMutationId: String
  labelableId: ID!
  labelIds: []!
}

type AddLabelsToLabelablePayload {
  clientMutationId: String
  labelable: Labelable
}

input AddProjectCardInput {
  clientMutationId: String
  projectColumnId: ID!
  contentId: ID
  note: String
}

type AddProjectCardPayload {
  cardEdge: ProjectCardEdge
  clientMutationId: String
  projectColumn: ProjectColumn
}

input AddProjectColumnInput {
  clientMutationId: String
  projectId: ID!
  name: String!
}

type AddProjectColumnPayload {
  clientMutationId: String
  columnEdge: ProjectColumnEdge
  project: Project
}

input AddProjectV2DraftIssueInput {
  clientMutationId: String
  projectId: ID!
  title: String!
  body: String
  assigneeIds: [ID!]
}

type AddProjectV2DraftIssuePayload {
  clientMutationId: String
  projectItem: ProjectV2Item
}

input AddProjectV2ItemByIdInput {
  clientMutationId: String
  projectId: ID!
  contentId: ID!
}

type AddProjectV2ItemByIdPayload {
  clientMutationId: String
  item: ProjectV2Item
}

input AddPullRequestReviewCommentInput {
  clientMutationId: String
  pullRequestId: ID
  pullRequestReviewId: ID
  commitOID: GitObjectID
  body: String
  path: String
  position: Int
  inReplyTo: ID
}

type AddPullRequestReviewCommentPayload {
  clientMutationId: String
  comment: PullRequestReviewComment
  commentEdge: PullRequestReviewCommentEdge
}

input AddPullRequestReviewInput {
  clientMutationId: String
  pullRequestId: ID!
  commitOID: GitObjectID
  body: String
  event: PullRequestReviewEvent
  comments: [DraftPullRequestReviewComment]
  threads: [DraftPullRequestReviewThread]
}

type AddPullRequestReviewPayload {
  clientMutationId: String
  pullRequestReview: PullRequestReview
  reviewEdge: PullRequestReviewEdge
}

input AddPullRequestReviewThreadInput {
  clientMutationId: String
  path: String!
  body: String!
  pullRequestId: ID
  pullRequestReviewId: ID
  line: Int
  side: DiffSide
  startLine: Int
  startSide: DiffSide
  subjectType: PullRequestReviewThreadSubjectType
}

type AddPullRequestReviewThreadPayload {
  clientMutationId: String
  thread: PullRequestReviewThread
}

input AddPullRequestReviewThreadReplyInput {
  clientMutationId: String
  pullRequestReviewId: ID
  pullRequestReviewThreadId: ID!
  body: String!
}

type AddPullRequestReviewThreadReplyPayload {
  clientMutationId: String
  comment: PullRequestReviewComment
}

input AddReactionInput {
  clientMutationId: String
  subjectId: ID!
  content: ReactionContent!
}

type AddReactionPayload {
  clientMutationId: String
  reaction: Reaction
  reactionGroups: [ReactionGroup!]
  subject: Reactable
}

input AddStarInput {
  clientMutationId: String
  starrableId: ID!
}

type AddStarPayload {
  clientMutationId: String
  starrable: Starrable
}

input AddUpvoteInput {
  clientMutationId: String
  subjectId: ID!
}

type AddUpvotePayload {
  clientMutationId: String
  subject: Votable
}

input AddVerifiableDomainInput {
  clientMutationId: String
  ownerId: ID!
  domain: URI!
}

type AddVerifiableDomainPayload {
  clientMutationId: String
  domain: VerifiableDomain
}

type AddedToMergeQueueEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  enqueuer: User
  id: ID!
  mergeQueue: MergeQueue
  pullRequest: PullRequest
}

type AddedToProjectEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  databaseId: Int
  id: ID!
  project: Project
  projectCard: ProjectCard
  projectColumnName: String!
}

interface AnnouncementBanner {
  announcement: String
  announcementCreatedAt: DateTime
  announcementExpiresAt: DateTime
  announcementUserDismissible: Boolean
}

type App implements Node {
  createdAt: DateTime!
  databaseId: Int
  description: String
  id: ID!
  ipAllowListEntries(after: IpAllowListEntryConnection!, before: IpAllowListEntryConnection!, first: IpAllowListEntryConnection!, last: IpAllowListEntryConnection!, orderBy: IpAllowListEntryConnection!): IpAllowListEntryConnection!
  logoBackgroundColor: String!
  logoUrl(size: URI!): URI!
  name: String!
  slug: String!
  updatedAt: DateTime!
  url: URI!
}

input ApproveDeploymentsInput {
  clientMutationId: String
  workflowRunId: ID!
  environmentIds: []!
  comment: String
}

type ApproveDeploymentsPayload {
  clientMutationId: String
  deployments: [Deployment!]
}

input ApproveVerifiableDomainInput {
  clientMutationId: String
  id: ID!
}

type ApproveVerifiableDomainPayload {
  clientMutationId: String
  domain: VerifiableDomain
}

input ArchiveProjectV2ItemInput {
  clientMutationId: String
  projectId: ID!
  itemId: ID!
}

type ArchiveProjectV2ItemPayload {
  clientMutationId: String
  item: ProjectV2Item
}

input ArchiveRepositoryInput {
  clientMutationId: String
  repositoryId: ID!
}

type ArchiveRepositoryPayload {
  clientMutationId: String
  repository: Repository
}

interface Assignable {
  assignees(after: UserConnection!, before: UserConnection!, first: UserConnection!, last: UserConnection!): UserConnection!
}

type AssignedEvent implements Node {
  actor: Actor
  assignable: Assignable!
  assignee: Assignee
  createdAt: DateTime!
  id: ID!
  user: User
}

union Assignee = Bot | Mannequin | Organization | User

interface AuditEntry {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  operationType: OperationType
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

union AuditEntryActor = Bot | Organization | User

input AuditLogOrder {
  field: AuditLogOrderField
  direction: OrderDirection
}

enum AuditLogOrderField {
  CREATED_AT
}

type AutoMergeDisabledEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  disabler: User
  id: ID!
  pullRequest: PullRequest
  reason: String
  reasonCode: String
}

type AutoMergeEnabledEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  enabler: User
  id: ID!
  pullRequest: PullRequest
}

type AutoMergeRequest {
  authorEmail: String
  commitBody: String
  commitHeadline: String
  enabledAt: DateTime
  enabledBy: Actor
  mergeMethod: PullRequestMergeMethod!
  pullRequest: PullRequest!
}

type AutoRebaseEnabledEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  enabler: User
  id: ID!
  pullRequest: PullRequest
}

type AutoSquashEnabledEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  enabler: User
  id: ID!
  pullRequest: PullRequest
}

type AutomaticBaseChangeFailedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  newBase: String!
  oldBase: String!
  pullRequest: PullRequest!
}

type AutomaticBaseChangeSucceededEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  newBase: String!
  oldBase: String!
  pullRequest: PullRequest!
}

scalar Base64String

type BaseRefChangedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  currentRefName: String!
  databaseId: Int
  id: ID!
  previousRefName: String!
  pullRequest: PullRequest!
}

type BaseRefDeletedEvent implements Node {
  actor: Actor
  baseRefName: String
  createdAt: DateTime!
  id: ID!
  pullRequest: PullRequest
}

type BaseRefForcePushedEvent implements Node {
  actor: Actor
  afterCommit: Commit
  beforeCommit: Commit
  createdAt: DateTime!
  id: ID!
  pullRequest: PullRequest!
  ref: Ref
}

scalar BigInt

type Blame {
  ranges: [BlameRange!]!
}

type BlameRange {
  age: Int!
  commit: Commit!
  endingLine: Int!
  startingLine: Int!
}

type Blob implements GitObject & Node {
  abbreviatedOid: String!
  byteSize: Int!
  commitResourcePath: URI!
  commitUrl: URI!
  id: ID!
  isBinary: Boolean
  isTruncated: Boolean!
  oid: GitObjectID!
  repository: Repository!
  text: String
}

scalar Boolean

type Bot implements Actor & Node & UniformResourceLocatable {
  avatarUrl(size: URI!): URI!
  createdAt: DateTime!
  databaseId: Int
  id: ID!
  login: String!
  resourcePath: URI!
  updatedAt: DateTime!
  url: URI!
}

union BranchActorAllowanceActor = App | Team | User

type BranchNamePatternParameters {
  name: String
  negate: Boolean!
  operator: String!
  pattern: String!
}

input BranchNamePatternParametersInput {
  name: String
  negate: Boolean
  operator: String!
  pattern: String!
}

type BranchProtectionRule implements Node {
  allowsDeletions: Boolean!
  allowsForcePushes: Boolean!
  blocksCreations: Boolean!
  branchProtectionRuleConflicts(after: BranchProtectionRuleConflictConnection!, before: BranchProtectionRuleConflictConnection!, first: BranchProtectionRuleConflictConnection!, last: BranchProtectionRuleConflictConnection!): BranchProtectionRuleConflictConnection!
  bypassForcePushAllowances(after: BypassForcePushAllowanceConnection!, before: BypassForcePushAllowanceConnection!, first: BypassForcePushAllowanceConnection!, last: BypassForcePushAllowanceConnection!): BypassForcePushAllowanceConnection!
  bypassPullRequestAllowances(after: BypassPullRequestAllowanceConnection!, before: BypassPullRequestAllowanceConnection!, first: BypassPullRequestAllowanceConnection!, last: BypassPullRequestAllowanceConnection!): BypassPullRequestAllowanceConnection!
  creator: Actor
  databaseId: Int
  dismissesStaleReviews: Boolean!
  id: ID!
  isAdminEnforced: Boolean!
  lockAllowsFetchAndMerge: Boolean!
  lockBranch: Boolean!
  matchingRefs(query: RefConnection!, after: RefConnection!, before: RefConnection!, first: RefConnection!, last: RefConnection!): RefConnection!
  pattern: String!
  pushAllowances(after: PushAllowanceConnection!, before: PushAllowanceConnection!, first: PushAllowanceConnection!, last: PushAllowanceConnection!): PushAllowanceConnection!
  repository: Repository
  requireLastPushApproval: Boolean!
  requiredApprovingReviewCount: Int
  requiredDeploymentEnvironments: [String]
  requiredStatusCheckContexts: [String]
  requiredStatusChecks: [RequiredStatusCheckDescription!]
  requiresApprovingReviews: Boolean!
  requiresCodeOwnerReviews: Boolean!
  requiresCommitSignatures: Boolean!
  requiresConversationResolution: Boolean!
  requiresDeployments: Boolean!
  requiresLinearHistory: Boolean!
  requiresStatusChecks: Boolean!
  requiresStrictStatusChecks: Boolean!
  restrictsPushes: Boolean!
  restrictsReviewDismissals: Boolean!
  reviewDismissalAllowances(after: ReviewDismissalAllowanceConnection!, before: ReviewDismissalAllowanceConnection!, first: ReviewDismissalAllowanceConnection!, last: ReviewDismissalAllowanceConnection!): ReviewDismissalAllowanceConnection!
}

type BranchProtectionRuleConflict {
  branchProtectionRule: BranchProtectionRule
  conflictingBranchProtectionRule: BranchProtectionRule
  ref: Ref
}

type BranchProtectionRuleConflictConnection {
  edges: [BranchProtectionRuleConflictEdge]
  nodes: [BranchProtectionRuleConflict]
  pageInfo: PageInfo!
  totalCount: Int!
}

type BranchProtectionRuleConflictEdge {
  cursor: String!
  node: BranchProtectionRuleConflict
}

type BranchProtectionRuleConnection {
  edges: [BranchProtectionRuleEdge]
  nodes: [BranchProtectionRule]
  pageInfo: PageInfo!
  totalCount: Int!
}

type BranchProtectionRuleEdge {
  cursor: String!
  node: BranchProtectionRule
}

input BulkSponsorship {
  sponsorableId: ID
  sponsorableLogin: String
  amount: Int!
}

union BypassActor = App | Team

type BypassForcePushAllowance implements Node {
  actor: BranchActorAllowanceActor
  branchProtectionRule: BranchProtectionRule
  id: ID!
}

type BypassForcePushAllowanceConnection {
  edges: [BypassForcePushAllowanceEdge]
  nodes: [BypassForcePushAllowance]
  pageInfo: PageInfo!
  totalCount: Int!
}

type BypassForcePushAllowanceEdge {
  cursor: String!
  node: BypassForcePushAllowance
}

type BypassPullRequestAllowance implements Node {
  actor: BranchActorAllowanceActor
  branchProtectionRule: BranchProtectionRule
  id: ID!
}

type BypassPullRequestAllowanceConnection {
  edges: [BypassPullRequestAllowanceEdge]
  nodes: [BypassPullRequestAllowance]
  pageInfo: PageInfo!
  totalCount: Int!
}

type BypassPullRequestAllowanceEdge {
  cursor: String!
  node: BypassPullRequestAllowance
}

type CVSS {
  score: Float!
  vectorString: String
}

type CWE implements Node {
  cweId: String!
  description: String!
  id: ID!
  name: String!
}

type CWEConnection {
  edges: [CWEEdge]
  nodes: [CWE]
  pageInfo: PageInfo!
  totalCount: Int!
}

type CWEEdge {
  cursor: String!
  node: CWE
}

input CancelEnterpriseAdminInvitationInput {
  clientMutationId: String
  invitationId: ID!
}

type CancelEnterpriseAdminInvitationPayload {
  clientMutationId: String
  invitation: EnterpriseAdministratorInvitation
  message: String
}

input CancelSponsorshipInput {
  clientMutationId: String
  sponsorId: ID
  sponsorLogin: String
  sponsorableId: ID
  sponsorableLogin: String
}

type CancelSponsorshipPayload {
  clientMutationId: String
  sponsorsTier: SponsorsTier
}

input ChangeUserStatusInput {
  clientMutationId: String
  emoji: String
  message: String
  organizationId: ID
  limitedAvailability: Boolean
  expiresAt: DateTime
}

type ChangeUserStatusPayload {
  clientMutationId: String
  status: UserStatus
}

type CheckAnnotation {
  annotationLevel: CheckAnnotationLevel
  blobUrl: URI!
  databaseId: Int
  location: CheckAnnotationSpan!
  message: String!
  path: String!
  rawDetails: String
  title: String
}

type CheckAnnotationConnection {
  edges: [CheckAnnotationEdge]
  nodes: [CheckAnnotation]
  pageInfo: PageInfo!
  totalCount: Int!
}

input CheckAnnotationData {
  path: String!
  location: CheckAnnotationRange!
  annotationLevel: CheckAnnotationLevel!
  message: String!
  title: String
  rawDetails: String
}

type CheckAnnotationEdge {
  cursor: String!
  node: CheckAnnotation
}

enum CheckAnnotationLevel {
  FAILURE
  NOTICE
  WARNING
}

type CheckAnnotationPosition {
  column: Int
  line: Int!
}

input CheckAnnotationRange {
  startLine: Int!
  startColumn: Int
  endLine: Int!
  endColumn: Int
}

type CheckAnnotationSpan {
  end: CheckAnnotationPosition!
  start: CheckAnnotationPosition!
}

enum CheckConclusionState {
  ACTION_REQUIRED
  TIMED_OUT
  CANCELLED
  FAILURE
  SUCCESS
  NEUTRAL
  SKIPPED
  STARTUP_FAILURE
  STALE
}

type CheckRun implements Node & RequirableByPullRequest & UniformResourceLocatable {
  annotations(after: CheckAnnotationConnection, before: CheckAnnotationConnection, first: CheckAnnotationConnection, last: CheckAnnotationConnection): CheckAnnotationConnection
  checkSuite: CheckSuite!
  completedAt: DateTime
  conclusion: CheckConclusionState
  databaseId: Int
  deployment: Deployment
  detailsUrl: URI
  externalId: String
  id: ID!
  isRequired(pullRequestId: Boolean!, pullRequestNumber: Boolean!): Boolean!
  name: String!
  pendingDeploymentRequest: DeploymentRequest
  permalink: URI!
  repository: Repository!
  resourcePath: URI!
  startedAt: DateTime
  status: CheckStatusState!
  steps(after: CheckStepConnection, before: CheckStepConnection, first: CheckStepConnection, last: CheckStepConnection, number: CheckStepConnection): CheckStepConnection
  summary: String
  text: String
  title: String
  url: URI!
}

input CheckRunAction {
  label: String!
  description: String!
  identifier: String!
}

type CheckRunConnection {
  edges: [CheckRunEdge]
  nodes: [CheckRun]
  pageInfo: PageInfo!
  totalCount: Int!
}

type CheckRunEdge {
  cursor: String!
  node: CheckRun
}

input CheckRunFilter {
  checkType: CheckRunType
  appId: Int
  checkName: String
  status: CheckStatusState
  statuses: [CheckStatusState!]
  conclusions: [CheckConclusionState!]
}

input CheckRunOutput {
  title: String!
  summary: String!
  text: String
  annotations: [CheckAnnotationData!]
  images: [CheckRunOutputImage!]
}

input CheckRunOutputImage {
  alt: String!
  imageUrl: URI!
  caption: String
}

enum CheckRunState {
  ACTION_REQUIRED
  CANCELLED
  COMPLETED
  FAILURE
  IN_PROGRESS
  NEUTRAL
  PENDING
  QUEUED
  SKIPPED
  STALE
  STARTUP_FAILURE
  SUCCESS
  TIMED_OUT
  WAITING
}

type CheckRunStateCount {
  count: Int!
  state: CheckRunState!
}

enum CheckRunType {
  ALL
  LATEST
}

enum CheckStatusState {
  REQUESTED
  QUEUED
  IN_PROGRESS
  COMPLETED
  WAITING
  PENDING
}

type CheckStep {
  completedAt: DateTime
  conclusion: CheckConclusionState
  externalId: String
  name: String!
  number: Int!
  secondsToCompletion: Int
  startedAt: DateTime
  status: CheckStatusState!
}

type CheckStepConnection {
  edges: [CheckStepEdge]
  nodes: [CheckStep]
  pageInfo: PageInfo!
  totalCount: Int!
}

type CheckStepEdge {
  cursor: String!
  node: CheckStep
}

type CheckSuite implements Node {
  app: App
  branch: Ref
  checkRuns(after: CheckRunConnection, before: CheckRunConnection, first: CheckRunConnection, last: CheckRunConnection, filterBy: CheckRunConnection): CheckRunConnection
  commit: Commit!
  conclusion: CheckConclusionState
  createdAt: DateTime!
  creator: User
  databaseId: Int
  id: ID!
  matchingPullRequests(states: PullRequestConnection, labels: PullRequestConnection, headRefName: PullRequestConnection, baseRefName: PullRequestConnection, orderBy: PullRequestConnection, after: PullRequestConnection, before: PullRequestConnection, first: PullRequestConnection, last: PullRequestConnection): PullRequestConnection
  push: Push
  repository: Repository!
  resourcePath: URI!
  status: CheckStatusState!
  updatedAt: DateTime!
  url: URI!
  workflowRun: WorkflowRun
}

input CheckSuiteAutoTriggerPreference {
  appId: ID!
  setting: Boolean!
}

type CheckSuiteConnection {
  edges: [CheckSuiteEdge]
  nodes: [CheckSuite]
  pageInfo: PageInfo!
  totalCount: Int!
}

type CheckSuiteEdge {
  cursor: String!
  node: CheckSuite
}

input CheckSuiteFilter {
  appId: Int
  checkName: String
}

union Claimable = Mannequin | User

input ClearLabelsFromLabelableInput {
  clientMutationId: String
  labelableId: ID!
}

type ClearLabelsFromLabelablePayload {
  clientMutationId: String
  labelable: Labelable
}

input ClearProjectV2ItemFieldValueInput {
  clientMutationId: String
  projectId: ID!
  itemId: ID!
  fieldId: ID!
}

type ClearProjectV2ItemFieldValuePayload {
  clientMutationId: String
  projectV2Item: ProjectV2Item
}

input CloneProjectInput {
  clientMutationId: String
  targetOwnerId: ID!
  sourceId: ID!
  includeWorkflows: Boolean!
  name: String!
  body: String
  public: Boolean
}

type CloneProjectPayload {
  clientMutationId: String
  jobStatusId: String
  project: Project
}

input CloneTemplateRepositoryInput {
  clientMutationId: String
  repositoryId: ID!
  name: String!
  ownerId: ID!
  description: String
  visibility: RepositoryVisibility!
  includeAllBranches: Boolean
}

type CloneTemplateRepositoryPayload {
  clientMutationId: String
  repository: Repository
}

interface Closable {
  closed: Boolean!
  closedAt: DateTime
  viewerCanClose: Boolean!
  viewerCanReopen: Boolean!
}

input CloseDiscussionInput {
  clientMutationId: String
  discussionId: ID!
  reason: DiscussionCloseReason
}

type CloseDiscussionPayload {
  clientMutationId: String
  discussion: Discussion
}

input CloseIssueInput {
  clientMutationId: String
  issueId: ID!
  stateReason: IssueClosedStateReason
}

type CloseIssuePayload {
  clientMutationId: String
  issue: Issue
}

input ClosePullRequestInput {
  clientMutationId: String
  pullRequestId: ID!
}

type ClosePullRequestPayload {
  clientMutationId: String
  pullRequest: PullRequest
}

type ClosedEvent implements Node & UniformResourceLocatable {
  actor: Actor
  closable: Closable!
  closer: Closer
  createdAt: DateTime!
  id: ID!
  resourcePath: URI!
  stateReason: IssueStateReason
  url: URI!
}

union Closer = Commit | ProjectV2 | PullRequest

type CodeOfConduct implements Node {
  body: String
  id: ID!
  key: String!
  name: String!
  resourcePath: URI
  url: URI
}

type CodeScanningParameters {
  codeScanningTools: [CodeScanningTool!]!
}

input CodeScanningParametersInput {
  codeScanningTools: []!
}

type CodeScanningTool {
  alertsThreshold: String!
  securityAlertsThreshold: String!
  tool: String!
}

input CodeScanningToolInput {
  alertsThreshold: String!
  securityAlertsThreshold: String!
  tool: String!
}

enum CollaboratorAffiliation {
  OUTSIDE
  DIRECT
  ALL
}

interface Comment {
  author: Actor
  authorAssociation: CommentAuthorAssociation!
  body: String!
  bodyHTML: HTML!
  bodyText: String!
  createdAt: DateTime!
  createdViaEmail: Boolean!
  editor: Actor
  id: ID!
  includesCreatedEdit: Boolean!
  lastEditedAt: DateTime
  publishedAt: DateTime
  updatedAt: DateTime!
  userContentEdits(after: UserContentEditConnection, before: UserContentEditConnection, first: UserContentEditConnection, last: UserContentEditConnection): UserContentEditConnection
  viewerDidAuthor: Boolean!
}

enum CommentAuthorAssociation {
  MEMBER
  OWNER
  MANNEQUIN
  COLLABORATOR
  CONTRIBUTOR
  FIRST_TIME_CONTRIBUTOR
  FIRST_TIMER
  NONE
}

enum CommentCannotUpdateReason {
  ARCHIVED
  INSUFFICIENT_ACCESS
  LOCKED
  LOGIN_REQUIRED
  MAINTENANCE
  VERIFIED_EMAIL_REQUIRED
  DENIED
}

type CommentDeletedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  databaseId: Int
  deletedCommentAuthor: Actor
  id: ID!
}

type Commit implements GitObject & Node & Subscribable & UniformResourceLocatable {
  abbreviatedOid: String!
  additions: Int!
  associatedPullRequests(after: PullRequestConnection, before: PullRequestConnection, first: PullRequestConnection, last: PullRequestConnection, orderBy: PullRequestConnection): PullRequestConnection
  author: GitActor
  authoredByCommitter: Boolean!
  authoredDate: DateTime!
  authors(after: GitActorConnection!, before: GitActorConnection!, first: GitActorConnection!, last: GitActorConnection!): GitActorConnection!
  blame(path: Blame!): Blame!
  changedFiles: Int!
  changedFilesIfAvailable: Int
  checkSuites(after: CheckSuiteConnection, before: CheckSuiteConnection, first: CheckSuiteConnection, last: CheckSuiteConnection, filterBy: CheckSuiteConnection): CheckSuiteConnection
  comments(after: CommitCommentConnection!, before: CommitCommentConnection!, first: CommitCommentConnection!, last: CommitCommentConnection!): CommitCommentConnection!
  commitResourcePath: URI!
  commitUrl: URI!
  committedDate: DateTime!
  committedViaWeb: Boolean!
  committer: GitActor
  deletions: Int!
  deployments(environments: DeploymentConnection, orderBy: DeploymentConnection, after: DeploymentConnection, before: DeploymentConnection, first: DeploymentConnection, last: DeploymentConnection): DeploymentConnection
  file(path: TreeEntry): TreeEntry
  history(after: CommitHistoryConnection!, before: CommitHistoryConnection!, first: CommitHistoryConnection!, last: CommitHistoryConnection!, path: CommitHistoryConnection!, author: CommitHistoryConnection!, since: CommitHistoryConnection!, until: CommitHistoryConnection!): CommitHistoryConnection!
  id: ID!
  message: String!
  messageBody: String!
  messageBodyHTML: HTML!
  messageHeadline: String!
  messageHeadlineHTML: HTML!
  oid: GitObjectID!
  onBehalfOf: Organization
  parents(after: CommitConnection!, before: CommitConnection!, first: CommitConnection!, last: CommitConnection!): CommitConnection!
  pushedDate: DateTime
  repository: Repository!
  resourcePath: URI!
  signature: GitSignature
  status: Status
  statusCheckRollup: StatusCheckRollup
  submodules(after: SubmoduleConnection!, before: SubmoduleConnection!, first: SubmoduleConnection!, last: SubmoduleConnection!): SubmoduleConnection!
  tarballUrl: URI!
  tree: Tree!
  treeResourcePath: URI!
  treeUrl: URI!
  url: URI!
  viewerCanSubscribe: Boolean!
  viewerSubscription: SubscriptionState
  zipballUrl: URI!
}

input CommitAuthor {
  id: ID
  emails: [String!]
}

type CommitAuthorEmailPatternParameters {
  name: String
  negate: Boolean!
  operator: String!
  pattern: String!
}

input CommitAuthorEmailPatternParametersInput {
  name: String
  negate: Boolean
  operator: String!
  pattern: String!
}

type CommitComment implements Comment & Deletable & Minimizable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment {
  author: Actor
  authorAssociation: CommentAuthorAssociation!
  body: String!
  bodyHTML: HTML!
  bodyText: String!
  commit: Commit
  createdAt: DateTime!
  createdViaEmail: Boolean!
  databaseId: Int
  editor: Actor
  id: ID!
  includesCreatedEdit: Boolean!
  isMinimized: Boolean!
  lastEditedAt: DateTime
  minimizedReason: String
  path: String
  position: Int
  publishedAt: DateTime
  reactionGroups: [ReactionGroup!]
  reactions(after: ReactionConnection!, before: ReactionConnection!, first: ReactionConnection!, last: ReactionConnection!, content: ReactionConnection!, orderBy: ReactionConnection!): ReactionConnection!
  repository: Repository!
  resourcePath: URI!
  updatedAt: DateTime!
  url: URI!
  userContentEdits(after: UserContentEditConnection, before: UserContentEditConnection, first: UserContentEditConnection, last: UserContentEditConnection): UserContentEditConnection
  viewerCanDelete: Boolean!
  viewerCanMinimize: Boolean!
  viewerCanReact: Boolean!
  viewerCanUpdate: Boolean!
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
  viewerDidAuthor: Boolean!
}

type CommitCommentConnection {
  edges: [CommitCommentEdge]
  nodes: [CommitComment]
  pageInfo: PageInfo!
  totalCount: Int!
}

type CommitCommentEdge {
  cursor: String!
  node: CommitComment
}

type CommitCommentThread implements Node & RepositoryNode {
  comments(after: CommitCommentConnection!, before: CommitCommentConnection!, first: CommitCommentConnection!, last: CommitCommentConnection!): CommitCommentConnection!
  commit: Commit
  id: ID!
  path: String
  position: Int
  repository: Repository!
}

type CommitConnection {
  edges: [CommitEdge]
  nodes: [Commit]
  pageInfo: PageInfo!
  totalCount: Int!
}

input CommitContributionOrder {
  field: CommitContributionOrderField!
  direction: OrderDirection!
}

enum CommitContributionOrderField {
  OCCURRED_AT
  COMMIT_COUNT
}

type CommitContributionsByRepository {
  contributions(after: CreatedCommitContributionConnection!, before: CreatedCommitContributionConnection!, first: CreatedCommitContributionConnection!, last: CreatedCommitContributionConnection!, orderBy: CreatedCommitContributionConnection!): CreatedCommitContributionConnection!
  repository: Repository!
  resourcePath: URI!
  url: URI!
}

type CommitEdge {
  cursor: String!
  node: Commit
}

type CommitHistoryConnection {
  edges: [CommitEdge]
  nodes: [Commit]
  pageInfo: PageInfo!
  totalCount: Int!
}

input CommitMessage {
  headline: String!
  body: String
}

type CommitMessagePatternParameters {
  name: String
  negate: Boolean!
  operator: String!
  pattern: String!
}

input CommitMessagePatternParametersInput {
  name: String
  negate: Boolean
  operator: String!
  pattern: String!
}

input CommittableBranch {
  id: ID
  repositoryNameWithOwner: String
  branchName: String
}

type CommitterEmailPatternParameters {
  name: String
  negate: Boolean!
  operator: String!
  pattern: String!
}

input CommitterEmailPatternParametersInput {
  name: String
  negate: Boolean
  operator: String!
  pattern: String!
}

type Comparison implements Node {
  aheadBy: Int!
  baseTarget: GitObject!
  behindBy: Int!
  commits(after: ComparisonCommitConnection!, before: ComparisonCommitConnection!, first: ComparisonCommitConnection!, last: ComparisonCommitConnection!): ComparisonCommitConnection!
  headTarget: GitObject!
  id: ID!
  status: ComparisonStatus!
}

type ComparisonCommitConnection {
  authorCount: Int!
  edges: [CommitEdge]
  nodes: [Commit]
  pageInfo: PageInfo!
  totalCount: Int!
}

enum ComparisonStatus {
  DIVERGED
  AHEAD
  BEHIND
  IDENTICAL
}

type ConnectedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  isCrossRepository: Boolean!
  source: ReferencedSubject!
  subject: ReferencedSubject!
}

type ContributingGuidelines {
  body: String
  resourcePath: URI
  url: URI
}

interface Contribution {
  isRestricted: Boolean!
  occurredAt: DateTime!
  resourcePath: URI!
  url: URI!
  user: User!
}

type ContributionCalendar {
  colors: [String!]!
  isHalloween: Boolean!
  months: [ContributionCalendarMonth!]!
  totalContributions: Int!
  weeks: [ContributionCalendarWeek!]!
}

type ContributionCalendarDay {
  color: String!
  contributionCount: Int!
  contributionLevel: ContributionLevel!
  date: Date!
  weekday: Int!
}

type ContributionCalendarMonth {
  firstDay: Date!
  name: String!
  totalWeeks: Int!
  year: Int!
}

type ContributionCalendarWeek {
  contributionDays: [ContributionCalendarDay!]!
  firstDay: Date!
}

enum ContributionLevel {
  NONE
  FIRST_QUARTILE
  SECOND_QUARTILE
  THIRD_QUARTILE
  FOURTH_QUARTILE
}

input ContributionOrder {
  direction: OrderDirection!
}

type ContributionsCollection {
  commitContributionsByRepository(maxRepositories: [CommitContributionsByRepository!]!): [CommitContributionsByRepository!]!
  contributionCalendar: ContributionCalendar!
  contributionYears: [Int!]!
  doesEndInCurrentMonth: Boolean!
  earliestRestrictedContributionDate: Date
  endedAt: DateTime!
  firstIssueContribution: CreatedIssueOrRestrictedContribution
  firstPullRequestContribution: CreatedPullRequestOrRestrictedContribution
  firstRepositoryContribution: CreatedRepositoryOrRestrictedContribution
  hasActivityInThePast: Boolean!
  hasAnyContributions: Boolean!
  hasAnyRestrictedContributions: Boolean!
  isSingleDay: Boolean!
  issueContributions(after: CreatedIssueContributionConnection!, before: CreatedIssueContributionConnection!, first: CreatedIssueContributionConnection!, last: CreatedIssueContributionConnection!, excludeFirst: CreatedIssueContributionConnection!, excludePopular: CreatedIssueContributionConnection!, orderBy: CreatedIssueContributionConnection!): CreatedIssueContributionConnection!
  issueContributionsByRepository(maxRepositories: [IssueContributionsByRepository!]!, excludeFirst: [IssueContributionsByRepository!]!, excludePopular: [IssueContributionsByRepository!]!): [IssueContributionsByRepository!]!
  joinedGitHubContribution: JoinedGitHubContribution
  latestRestrictedContributionDate: Date
  mostRecentCollectionWithActivity: ContributionsCollection
  mostRecentCollectionWithoutActivity: ContributionsCollection
  popularIssueContribution: CreatedIssueContribution
  popularPullRequestContribution: CreatedPullRequestContribution
  pullRequestContributions(after: CreatedPullRequestContributionConnection!, before: CreatedPullRequestContributionConnection!, first: CreatedPullRequestContributionConnection!, last: CreatedPullRequestContributionConnection!, excludeFirst: CreatedPullRequestContributionConnection!, excludePopular: CreatedPullRequestContributionConnection!, orderBy: CreatedPullRequestContributionConnection!): CreatedPullRequestContributionConnection!
  pullRequestContributionsByRepository(maxRepositories: [PullRequestContributionsByRepository!]!, excludeFirst: [PullRequestContributionsByRepository!]!, excludePopular: [PullRequestContributionsByRepository!]!): [PullRequestContributionsByRepository!]!
  pullRequestReviewContributions(after: CreatedPullRequestReviewContributionConnection!, before: CreatedPullRequestReviewContributionConnection!, first: CreatedPullRequestReviewContributionConnection!, last: CreatedPullRequestReviewContributionConnection!, orderBy: CreatedPullRequestReviewContributionConnection!): CreatedPullRequestReviewContributionConnection!
  pullRequestReviewContributionsByRepository(maxRepositories: [PullRequestReviewContributionsByRepository!]!): [PullRequestReviewContributionsByRepository!]!
  repositoryContributions(after: CreatedRepositoryContributionConnection!, before: CreatedRepositoryContributionConnection!, first: CreatedRepositoryContributionConnection!, last: CreatedRepositoryContributionConnection!, excludeFirst: CreatedRepositoryContributionConnection!, orderBy: CreatedRepositoryContributionConnection!): CreatedRepositoryContributionConnection!
  restrictedContributionsCount: Int!
  startedAt: DateTime!
  totalCommitContributions: Int!
  totalIssueContributions(excludeFirst: Int!, excludePopular: Int!): Int!
  totalPullRequestContributions(excludeFirst: Int!, excludePopular: Int!): Int!
  totalPullRequestReviewContributions: Int!
  totalRepositoriesWithContributedCommits: Int!
  totalRepositoriesWithContributedIssues(excludeFirst: Int!, excludePopular: Int!): Int!
  totalRepositoriesWithContributedPullRequestReviews: Int!
  totalRepositoriesWithContributedPullRequests(excludeFirst: Int!, excludePopular: Int!): Int!
  totalRepositoryContributions(excludeFirst: Int!): Int!
  user: User!
}

input ConvertProjectCardNoteToIssueInput {
  clientMutationId: String
  projectCardId: ID!
  repositoryId: ID!
  title: String
  body: String
}

type ConvertProjectCardNoteToIssuePayload {
  clientMutationId: String
  projectCard: ProjectCard
}

input ConvertPullRequestToDraftInput {
  clientMutationId: String
  pullRequestId: ID!
}

type ConvertPullRequestToDraftPayload {
  clientMutationId: String
  pullRequest: PullRequest
}

type ConvertToDraftEvent implements Node & UniformResourceLocatable {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  pullRequest: PullRequest!
  resourcePath: URI!
  url: URI!
}

type ConvertedNoteToIssueEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  databaseId: Int
  id: ID!
  project: Project
  projectCard: ProjectCard
  projectColumnName: String!
}

type ConvertedToDiscussionEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  discussion: Discussion
  id: ID!
}

type CopilotEndpoints {
  api: String!
  originTracker: String!
  proxy: String!
  telemetry: String!
}

input CopyProjectV2Input {
  clientMutationId: String
  projectId: ID!
  ownerId: ID!
  title: String!
  includeDraftIssues: Boolean
}

type CopyProjectV2Payload {
  clientMutationId: String
  projectV2: ProjectV2
}

input CreateAttributionInvitationInput {
  clientMutationId: String
  ownerId: ID!
  sourceId: ID!
  targetId: ID!
}

type CreateAttributionInvitationPayload {
  clientMutationId: String
  owner: Organization
  source: Claimable
  target: Claimable
}

input CreateBranchProtectionRuleInput {
  clientMutationId: String
  repositoryId: ID!
  pattern: String!
  requiresApprovingReviews: Boolean
  requiredApprovingReviewCount: Int
  requiresCommitSignatures: Boolean
  requiresLinearHistory: Boolean
  blocksCreations: Boolean
  allowsForcePushes: Boolean
  allowsDeletions: Boolean
  isAdminEnforced: Boolean
  requiresStatusChecks: Boolean
  requiresStrictStatusChecks: Boolean
  requiresCodeOwnerReviews: Boolean
  dismissesStaleReviews: Boolean
  restrictsReviewDismissals: Boolean
  reviewDismissalActorIds: [ID!]
  bypassPullRequestActorIds: [ID!]
  bypassForcePushActorIds: [ID!]
  restrictsPushes: Boolean
  pushActorIds: [ID!]
  requiredStatusCheckContexts: [String!]
  requiredStatusChecks: [RequiredStatusCheckInput!]
  requiresDeployments: Boolean
  requiredDeploymentEnvironments: [String!]
  requiresConversationResolution: Boolean
  requireLastPushApproval: Boolean
  lockBranch: Boolean
  lockAllowsFetchAndMerge: Boolean
}

type CreateBranchProtectionRulePayload {
  branchProtectionRule: BranchProtectionRule
  clientMutationId: String
}

input CreateCheckRunInput {
  clientMutationId: String
  repositoryId: ID!
  name: String!
  headSha: GitObjectID!
  detailsUrl: URI
  externalId: String
  status: RequestableCheckStatusState
  startedAt: DateTime
  conclusion: CheckConclusionState
  completedAt: DateTime
  output: CheckRunOutput
  actions: [CheckRunAction!]
}

type CreateCheckRunPayload {
  checkRun: CheckRun
  clientMutationId: String
}

input CreateCheckSuiteInput {
  clientMutationId: String
  repositoryId: ID!
  headSha: GitObjectID!
}

type CreateCheckSuitePayload {
  checkSuite: CheckSuite
  clientMutationId: String
}

input CreateCommitOnBranchInput {
  clientMutationId: String
  branch: CommittableBranch!
  fileChanges: FileChanges
  message: CommitMessage!
  expectedHeadOid: GitObjectID!
}

type CreateCommitOnBranchPayload {
  clientMutationId: String
  commit: Commit
  ref: Ref
}

input CreateDeploymentInput {
  clientMutationId: String
  repositoryId: ID!
  refId: ID!
  autoMerge: Boolean
  requiredContexts: [String!]
  description: String
  environment: String
  task: String
  payload: String
}

type CreateDeploymentPayload {
  autoMerged: Boolean
  clientMutationId: String
  deployment: Deployment
}

input CreateDeploymentStatusInput {
  clientMutationId: String
  deploymentId: ID!
  state: DeploymentStatusState!
  description: String
  environment: String
  environmentUrl: String
  autoInactive: Boolean
  logUrl: String
}

type CreateDeploymentStatusPayload {
  clientMutationId: String
  deploymentStatus: DeploymentStatus
}

input CreateDiscussionInput {
  clientMutationId: String
  repositoryId: ID!
  title: String!
  body: String!
  categoryId: ID!
}

type CreateDiscussionPayload {
  clientMutationId: String
  discussion: Discussion
}

input CreateEnterpriseOrganizationInput {
  clientMutationId: String
  enterpriseId: ID!
  login: String!
  profileName: String!
  billingEmail: String!
  adminLogins: []!
}

type CreateEnterpriseOrganizationPayload {
  clientMutationId: String
  enterprise: Enterprise
  organization: Organization
}

input CreateEnvironmentInput {
  clientMutationId: String
  repositoryId: ID!
  name: String!
}

type CreateEnvironmentPayload {
  clientMutationId: String
  environment: Environment
}

input CreateIpAllowListEntryInput {
  clientMutationId: String
  ownerId: ID!
  allowListValue: String!
  name: String
  isActive: Boolean!
}

type CreateIpAllowListEntryPayload {
  clientMutationId: String
  ipAllowListEntry: IpAllowListEntry
}

input CreateIssueInput {
  clientMutationId: String
  repositoryId: ID!
  title: String!
  body: String
  assigneeIds: [ID!]
  milestoneId: ID
  labelIds: [ID!]
  projectIds: [ID!]
  issueTemplate: String
}

type CreateIssuePayload {
  clientMutationId: String
  issue: Issue
}

input CreateLabelInput {
  clientMutationId: String
  repositoryId: ID!
  color: String!
  name: String!
  description: String
}

type CreateLabelPayload {
  clientMutationId: String
  label: Label
}

input CreateLinkedBranchInput {
  clientMutationId: String
  issueId: ID!
  oid: GitObjectID!
  name: String
  repositoryId: ID
}

type CreateLinkedBranchPayload {
  clientMutationId: String
  issue: Issue
  linkedBranch: LinkedBranch
}

input CreateMigrationSourceInput {
  clientMutationId: String
  name: String!
  url: String
  accessToken: String
  type: MigrationSourceType!
  ownerId: ID!
  githubPat: String
}

type CreateMigrationSourcePayload {
  clientMutationId: String
  migrationSource: MigrationSource
}

input CreateProjectInput {
  clientMutationId: String
  ownerId: ID!
  name: String!
  body: String
  template: ProjectTemplate
  repositoryIds: [ID!]
}

type CreateProjectPayload {
  clientMutationId: String
  project: Project
}

input CreateProjectV2FieldInput {
  clientMutationId: String
  projectId: ID!
  dataType: ProjectV2CustomFieldType!
  name: String!
  singleSelectOptions: [ProjectV2SingleSelectFieldOptionInput!]
}

type CreateProjectV2FieldPayload {
  clientMutationId: String
  projectV2Field: ProjectV2FieldConfiguration
}

input CreateProjectV2Input {
  clientMutationId: String
  ownerId: ID!
  title: String!
  repositoryId: ID
  teamId: ID
}

type CreateProjectV2Payload {
  clientMutationId: String
  projectV2: ProjectV2
}

input CreatePullRequestInput {
  clientMutationId: String
  repositoryId: ID!
  baseRefName: String!
  headRefName: String!
  headRepositoryId: ID
  title: String!
  body: String
  maintainerCanModify: Boolean
  draft: Boolean
}

type CreatePullRequestPayload {
  clientMutationId: String
  pullRequest: PullRequest
}

input CreateRefInput {
  clientMutationId: String
  repositoryId: ID!
  name: String!
  oid: GitObjectID!
}

type CreateRefPayload {
  clientMutationId: String
  ref: Ref
}

input CreateRepositoryInput {
  clientMutationId: String
  name: String!
  ownerId: ID
  description: String
  visibility: RepositoryVisibility!
  template: Boolean
  homepageUrl: URI
  hasWikiEnabled: Boolean
  hasIssuesEnabled: Boolean
  teamId: ID
}

type CreateRepositoryPayload {
  clientMutationId: String
  repository: Repository
}

input CreateRepositoryRulesetInput {
  clientMutationId: String
  sourceId: ID!
  name: String!
  target: RepositoryRulesetTarget
  rules: [RepositoryRuleInput!]
  conditions: RepositoryRuleConditionsInput!
  enforcement: RuleEnforcement!
  bypassActors: [RepositoryRulesetBypassActorInput!]
}

type CreateRepositoryRulesetPayload {
  clientMutationId: String
  ruleset: RepositoryRuleset
}

input CreateSponsorsListingInput {
  clientMutationId: String
  sponsorableLogin: String
  fiscalHostLogin: String
  fiscallyHostedProjectProfileUrl: String
  billingCountryOrRegionCode: SponsorsCountryOrRegionCode
  residenceCountryOrRegionCode: SponsorsCountryOrRegionCode
  contactEmail: String
  fullDescription: String
}

type CreateSponsorsListingPayload {
  clientMutationId: String
  sponsorsListing: SponsorsListing
}

input CreateSponsorsTierInput {
  clientMutationId: String
  sponsorableId: ID
  sponsorableLogin: String
  amount: Int!
  isRecurring: Boolean
  repositoryId: ID
  repositoryOwnerLogin: String
  repositoryName: String
  welcomeMessage: String
  description: String!
  publish: Boolean
}

type CreateSponsorsTierPayload {
  clientMutationId: String
  sponsorsTier: SponsorsTier
}

input CreateSponsorshipInput {
  clientMutationId: String
  sponsorId: ID
  sponsorLogin: String
  sponsorableId: ID
  sponsorableLogin: String
  tierId: ID
  amount: Int
  isRecurring: Boolean
  receiveEmails: Boolean
  privacyLevel: SponsorshipPrivacy
}

type CreateSponsorshipPayload {
  clientMutationId: String
  sponsorship: Sponsorship
}

input CreateSponsorshipsInput {
  clientMutationId: String
  sponsorLogin: String!
  sponsorships: []!
  receiveEmails: Boolean
  privacyLevel: SponsorshipPrivacy
  recurring: Boolean
}

type CreateSponsorshipsPayload {
  clientMutationId: String
  sponsorables: [Sponsorable!]
}

input CreateTeamDiscussionCommentInput {
  clientMutationId: String
  discussionId: ID
  body: String
}

type CreateTeamDiscussionCommentPayload {
  clientMutationId: String
  teamDiscussionComment: TeamDiscussionComment
}

input CreateTeamDiscussionInput {
  clientMutationId: String
  teamId: ID
  title: String
  body: String
  private: Boolean
}

type CreateTeamDiscussionPayload {
  clientMutationId: String
  teamDiscussion: TeamDiscussion
}

input CreateUserListInput {
  clientMutationId: String
  name: String!
  description: String
  isPrivate: Boolean
}

type CreateUserListPayload {
  clientMutationId: String
  list: UserList
  viewer: User
}

type CreatedCommitContribution implements Contribution {
  commitCount: Int!
  isRestricted: Boolean!
  occurredAt: DateTime!
  repository: Repository!
  resourcePath: URI!
  url: URI!
  user: User!
}

type CreatedCommitContributionConnection {
  edges: [CreatedCommitContributionEdge]
  nodes: [CreatedCommitContribution]
  pageInfo: PageInfo!
  totalCount: Int!
}

type CreatedCommitContributionEdge {
  cursor: String!
  node: CreatedCommitContribution
}

type CreatedIssueContribution implements Contribution {
  isRestricted: Boolean!
  issue: Issue!
  occurredAt: DateTime!
  resourcePath: URI!
  url: URI!
  user: User!
}

type CreatedIssueContributionConnection {
  edges: [CreatedIssueContributionEdge]
  nodes: [CreatedIssueContribution]
  pageInfo: PageInfo!
  totalCount: Int!
}

type CreatedIssueContributionEdge {
  cursor: String!
  node: CreatedIssueContribution
}

union CreatedIssueOrRestrictedContribution = CreatedIssueContribution | RestrictedContribution

type CreatedPullRequestContribution implements Contribution {
  isRestricted: Boolean!
  occurredAt: DateTime!
  pullRequest: PullRequest!
  resourcePath: URI!
  url: URI!
  user: User!
}

type CreatedPullRequestContributionConnection {
  edges: [CreatedPullRequestContributionEdge]
  nodes: [CreatedPullRequestContribution]
  pageInfo: PageInfo!
  totalCount: Int!
}

type CreatedPullRequestContributionEdge {
  cursor: String!
  node: CreatedPullRequestContribution
}

union CreatedPullRequestOrRestrictedContribution = CreatedPullRequestContribution | RestrictedContribution

type CreatedPullRequestReviewContribution implements Contribution {
  isRestricted: Boolean!
  occurredAt: DateTime!
  pullRequest: PullRequest!
  pullRequestReview: PullRequestReview!
  repository: Repository!
  resourcePath: URI!
  url: URI!
  user: User!
}

type CreatedPullRequestReviewContributionConnection {
  edges: [CreatedPullRequestReviewContributionEdge]
  nodes: [CreatedPullRequestReviewContribution]
  pageInfo: PageInfo!
  totalCount: Int!
}

type CreatedPullRequestReviewContributionEdge {
  cursor: String!
  node: CreatedPullRequestReviewContribution
}

type CreatedRepositoryContribution implements Contribution {
  isRestricted: Boolean!
  occurredAt: DateTime!
  repository: Repository!
  resourcePath: URI!
  url: URI!
  user: User!
}

type CreatedRepositoryContributionConnection {
  edges: [CreatedRepositoryContributionEdge]
  nodes: [CreatedRepositoryContribution]
  pageInfo: PageInfo!
  totalCount: Int!
}

type CreatedRepositoryContributionEdge {
  cursor: String!
  node: CreatedRepositoryContribution
}

union CreatedRepositoryOrRestrictedContribution = CreatedRepositoryContribution | RestrictedContribution

type CrossReferencedEvent implements Node & UniformResourceLocatable {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  isCrossRepository: Boolean!
  referencedAt: DateTime!
  resourcePath: URI!
  source: ReferencedSubject!
  target: ReferencedSubject!
  url: URI!
  willCloseTarget: Boolean!
}

scalar Date

scalar DateTime

input DeclineTopicSuggestionInput {
  clientMutationId: String
  repositoryId: ID
  name: String
  reason: TopicSuggestionDeclineReason
}

type DeclineTopicSuggestionPayload {
  clientMutationId: String
  topic: Topic
}

enum DefaultRepositoryPermissionField {
  NONE
  READ
  WRITE
  ADMIN
}

interface Deletable {
  viewerCanDelete: Boolean!
}

input DeleteBranchProtectionRuleInput {
  clientMutationId: String
  branchProtectionRuleId: ID!
}

type DeleteBranchProtectionRulePayload {
  clientMutationId: String
}

input DeleteDeploymentInput {
  clientMutationId: String
  id: ID!
}

type DeleteDeploymentPayload {
  clientMutationId: String
}

input DeleteDiscussionCommentInput {
  clientMutationId: String
  id: ID!
}

type DeleteDiscussionCommentPayload {
  clientMutationId: String
  comment: DiscussionComment
}

input DeleteDiscussionInput {
  clientMutationId: String
  id: ID!
}

type DeleteDiscussionPayload {
  clientMutationId: String
  discussion: Discussion
}

input DeleteEnvironmentInput {
  clientMutationId: String
  id: ID!
}

type DeleteEnvironmentPayload {
  clientMutationId: String
}

input DeleteIpAllowListEntryInput {
  clientMutationId: String
  ipAllowListEntryId: ID!
}

type DeleteIpAllowListEntryPayload {
  clientMutationId: String
  ipAllowListEntry: IpAllowListEntry
}

input DeleteIssueCommentInput {
  clientMutationId: String
  id: ID!
}

type DeleteIssueCommentPayload {
  clientMutationId: String
}

input DeleteIssueInput {
  clientMutationId: String
  issueId: ID!
}

type DeleteIssuePayload {
  clientMutationId: String
  repository: Repository
}

input DeleteLabelInput {
  clientMutationId: String
  id: ID!
}

type DeleteLabelPayload {
  clientMutationId: String
}

input DeleteLinkedBranchInput {
  clientMutationId: String
  linkedBranchId: ID!
}

type DeleteLinkedBranchPayload {
  clientMutationId: String
  issue: Issue
}

input DeletePackageVersionInput {
  clientMutationId: String
  packageVersionId: ID!
}

type DeletePackageVersionPayload {
  clientMutationId: String
  success: Boolean
}

input DeleteProjectCardInput {
  clientMutationId: String
  cardId: ID!
}

type DeleteProjectCardPayload {
  clientMutationId: String
  column: ProjectColumn
  deletedCardId: ID
}

input DeleteProjectColumnInput {
  clientMutationId: String
  columnId: ID!
}

type DeleteProjectColumnPayload {
  clientMutationId: String
  deletedColumnId: ID
  project: Project
}

input DeleteProjectInput {
  clientMutationId: String
  projectId: ID!
}

type DeleteProjectPayload {
  clientMutationId: String
  owner: ProjectOwner
}

input DeleteProjectV2FieldInput {
  clientMutationId: String
  fieldId: ID!
}

type DeleteProjectV2FieldPayload {
  clientMutationId: String
  projectV2Field: ProjectV2FieldConfiguration
}

input DeleteProjectV2Input {
  clientMutationId: String
  projectId: ID!
}

input DeleteProjectV2ItemInput {
  clientMutationId: String
  projectId: ID!
  itemId: ID!
}

type DeleteProjectV2ItemPayload {
  clientMutationId: String
  deletedItemId: ID
}

type DeleteProjectV2Payload {
  clientMutationId: String
  projectV2: ProjectV2
}

input DeleteProjectV2WorkflowInput {
  clientMutationId: String
  workflowId: ID!
}

type DeleteProjectV2WorkflowPayload {
  clientMutationId: String
  deletedWorkflowId: ID
  projectV2: ProjectV2
}

input DeletePullRequestReviewCommentInput {
  clientMutationId: String
  id: ID!
}

type DeletePullRequestReviewCommentPayload {
  clientMutationId: String
  pullRequestReview: PullRequestReview
  pullRequestReviewComment: PullRequestReviewComment
}

input DeletePullRequestReviewInput {
  clientMutationId: String
  pullRequestReviewId: ID!
}

type DeletePullRequestReviewPayload {
  clientMutationId: String
  pullRequestReview: PullRequestReview
}

input DeleteRefInput {
  clientMutationId: String
  refId: ID!
}

type DeleteRefPayload {
  clientMutationId: String
}

input DeleteRepositoryRulesetInput {
  clientMutationId: String
  repositoryRulesetId: ID!
}

type DeleteRepositoryRulesetPayload {
  clientMutationId: String
}

input DeleteTeamDiscussionCommentInput {
  clientMutationId: String
  id: ID!
}

type DeleteTeamDiscussionCommentPayload {
  clientMutationId: String
}

input DeleteTeamDiscussionInput {
  clientMutationId: String
  id: ID!
}

type DeleteTeamDiscussionPayload {
  clientMutationId: String
}

input DeleteUserListInput {
  clientMutationId: String
  listId: ID!
}

type DeleteUserListPayload {
  clientMutationId: String
  user: User
}

input DeleteVerifiableDomainInput {
  clientMutationId: String
  id: ID!
}

type DeleteVerifiableDomainPayload {
  clientMutationId: String
  owner: VerifiableDomainOwner
}

type DemilestonedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  milestoneTitle: String!
  subject: MilestoneItem!
}

type DependabotUpdate implements RepositoryNode {
  error: DependabotUpdateError
  pullRequest: PullRequest
  repository: Repository!
}

type DependabotUpdateError {
  body: String!
  errorType: String!
  title: String!
}

type DependencyGraphDependency {
  hasDependencies: Boolean!
  packageLabel: String!
  packageManager: String
  packageName: String!
  repository: Repository
  requirements: String!
}

type DependencyGraphDependencyConnection {
  edges: [DependencyGraphDependencyEdge]
  nodes: [DependencyGraphDependency]
  pageInfo: PageInfo!
  totalCount: Int!
}

type DependencyGraphDependencyEdge {
  cursor: String!
  node: DependencyGraphDependency
}

enum DependencyGraphEcosystem {
  RUBYGEMS
  NPM
  PIP
  MAVEN
  NUGET
  COMPOSER
  GO
  ACTIONS
  RUST
  PUB
  SWIFT
}

type DependencyGraphManifest implements Node {
  blobPath: String!
  dependencies(after: DependencyGraphDependencyConnection, before: DependencyGraphDependencyConnection, first: DependencyGraphDependencyConnection, last: DependencyGraphDependencyConnection): DependencyGraphDependencyConnection
  dependenciesCount: Int
  exceedsMaxSize: Boolean!
  filename: String!
  id: ID!
  parseable: Boolean!
  repository: Repository!
}

type DependencyGraphManifestConnection {
  edges: [DependencyGraphManifestEdge]
  nodes: [DependencyGraphManifest]
  pageInfo: PageInfo!
  totalCount: Int!
}

type DependencyGraphManifestEdge {
  cursor: String!
  node: DependencyGraphManifest
}

type DeployKey implements Node {
  createdAt: DateTime!
  id: ID!
  key: String!
  readOnly: Boolean!
  title: String!
  verified: Boolean!
}

type DeployKeyConnection {
  edges: [DeployKeyEdge]
  nodes: [DeployKey]
  pageInfo: PageInfo!
  totalCount: Int!
}

type DeployKeyEdge {
  cursor: String!
  node: DeployKey
}

type DeployedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  databaseId: Int
  deployment: Deployment!
  id: ID!
  pullRequest: PullRequest!
  ref: Ref
}

type Deployment implements Node {
  commit: Commit
  commitOid: String!
  createdAt: DateTime!
  creator: Actor!
  databaseId: Int
  description: String
  environment: String
  id: ID!
  latestEnvironment: String
  latestStatus: DeploymentStatus
  originalEnvironment: String
  payload: String
  ref: Ref
  repository: Repository!
  state: DeploymentState
  statuses(after: DeploymentStatusConnection, before: DeploymentStatusConnection, first: DeploymentStatusConnection, last: DeploymentStatusConnection): DeploymentStatusConnection
  task: String
  updatedAt: DateTime!
}

type DeploymentConnection {
  edges: [DeploymentEdge]
  nodes: [Deployment]
  pageInfo: PageInfo!
  totalCount: Int!
}

type DeploymentEdge {
  cursor: String!
  node: Deployment
}

type DeploymentEnvironmentChangedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  deploymentStatus: DeploymentStatus!
  id: ID!
  pullRequest: PullRequest!
}

input DeploymentOrder {
  field: DeploymentOrderField!
  direction: OrderDirection!
}

enum DeploymentOrderField {
  CREATED_AT
}

type DeploymentProtectionRule {
  databaseId: Int
  preventSelfReview: Boolean
  reviewers(after: DeploymentReviewerConnection!, before: DeploymentReviewerConnection!, first: DeploymentReviewerConnection!, last: DeploymentReviewerConnection!): DeploymentReviewerConnection!
  timeout: Int!
  type: DeploymentProtectionRuleType!
}

type DeploymentProtectionRuleConnection {
  edges: [DeploymentProtectionRuleEdge]
  nodes: [DeploymentProtectionRule]
  pageInfo: PageInfo!
  totalCount: Int!
}

type DeploymentProtectionRuleEdge {
  cursor: String!
  node: DeploymentProtectionRule
}

enum DeploymentProtectionRuleType {
  REQUIRED_REVIEWERS
  WAIT_TIMER
  BRANCH_POLICY
}

type DeploymentRequest {
  currentUserCanApprove: Boolean!
  environment: Environment!
  reviewers(after: DeploymentReviewerConnection!, before: DeploymentReviewerConnection!, first: DeploymentReviewerConnection!, last: DeploymentReviewerConnection!): DeploymentReviewerConnection!
  waitTimer: Int!
  waitTimerStartedAt: DateTime
}

type DeploymentRequestConnection {
  edges: [DeploymentRequestEdge]
  nodes: [DeploymentRequest]
  pageInfo: PageInfo!
  totalCount: Int!
}

type DeploymentRequestEdge {
  cursor: String!
  node: DeploymentRequest
}

type DeploymentReview implements Node {
  comment: String!
  databaseId: Int
  environments(after: EnvironmentConnection!, before: EnvironmentConnection!, first: EnvironmentConnection!, last: EnvironmentConnection!): EnvironmentConnection!
  id: ID!
  state: DeploymentReviewState!
  user: User!
}

type DeploymentReviewConnection {
  edges: [DeploymentReviewEdge]
  nodes: [DeploymentReview]
  pageInfo: PageInfo!
  totalCount: Int!
}

type DeploymentReviewEdge {
  cursor: String!
  node: DeploymentReview
}

enum DeploymentReviewState {
  APPROVED
  REJECTED
}

union DeploymentReviewer = Team | User

type DeploymentReviewerConnection {
  edges: [DeploymentReviewerEdge]
  nodes: [DeploymentReviewer]
  pageInfo: PageInfo!
  totalCount: Int!
}

type DeploymentReviewerEdge {
  cursor: String!
  node: DeploymentReviewer
}

enum DeploymentState {
  ABANDONED
  ACTIVE
  DESTROYED
  ERROR
  FAILURE
  INACTIVE
  PENDING
  SUCCESS
  QUEUED
  IN_PROGRESS
  WAITING
}

type DeploymentStatus implements Node {
  createdAt: DateTime!
  creator: Actor!
  deployment: Deployment!
  description: String
  environment: String
  environmentUrl: URI
  id: ID!
  logUrl: URI
  state: DeploymentStatusState!
  updatedAt: DateTime!
}

type DeploymentStatusConnection {
  edges: [DeploymentStatusEdge]
  nodes: [DeploymentStatus]
  pageInfo: PageInfo!
  totalCount: Int!
}

type DeploymentStatusEdge {
  cursor: String!
  node: DeploymentStatus
}

enum DeploymentStatusState {
  PENDING
  SUCCESS
  FAILURE
  INACTIVE
  ERROR
  QUEUED
  IN_PROGRESS
  WAITING
}

input DequeuePullRequestInput {
  clientMutationId: String
  id: ID!
}

type DequeuePullRequestPayload {
  clientMutationId: String
  mergeQueueEntry: MergeQueueEntry
}

enum DiffSide {
  LEFT
  RIGHT
}

input DisablePullRequestAutoMergeInput {
  clientMutationId: String
  pullRequestId: ID!
}

type DisablePullRequestAutoMergePayload {
  actor: Actor
  clientMutationId: String
  pullRequest: PullRequest
}

type DisconnectedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  isCrossRepository: Boolean!
  source: ReferencedSubject!
  subject: ReferencedSubject!
}

type Discussion implements Closable & Comment & Deletable & Labelable & Lockable & Node & Reactable & RepositoryNode & Subscribable & Updatable & Votable {
  activeLockReason: LockReason
  answer: DiscussionComment
  answerChosenAt: DateTime
  answerChosenBy: Actor
  author: Actor
  authorAssociation: CommentAuthorAssociation!
  body: String!
  bodyHTML: HTML!
  bodyText: String!
  category: DiscussionCategory!
  closed: Boolean!
  closedAt: DateTime
  comments(after: DiscussionCommentConnection!, before: DiscussionCommentConnection!, first: DiscussionCommentConnection!, last: DiscussionCommentConnection!): DiscussionCommentConnection!
  createdAt: DateTime!
  createdViaEmail: Boolean!
  databaseId: Int
  editor: Actor
  id: ID!
  includesCreatedEdit: Boolean!
  isAnswered: Boolean
  labels(orderBy: LabelConnection, after: LabelConnection, before: LabelConnection, first: LabelConnection, last: LabelConnection): LabelConnection
  lastEditedAt: DateTime
  locked: Boolean!
  number: Int!
  poll: DiscussionPoll
  publishedAt: DateTime
  reactionGroups: [ReactionGroup!]
  reactions(after: ReactionConnection!, before: ReactionConnection!, first: ReactionConnection!, last: ReactionConnection!, content: ReactionConnection!, orderBy: ReactionConnection!): ReactionConnection!
  repository: Repository!
  resourcePath: URI!
  stateReason: DiscussionStateReason
  title: String!
  updatedAt: DateTime!
  upvoteCount: Int!
  url: URI!
  userContentEdits(after: UserContentEditConnection, before: UserContentEditConnection, first: UserContentEditConnection, last: UserContentEditConnection): UserContentEditConnection
  viewerCanClose: Boolean!
  viewerCanDelete: Boolean!
  viewerCanReact: Boolean!
  viewerCanReopen: Boolean!
  viewerCanSubscribe: Boolean!
  viewerCanUpdate: Boolean!
  viewerCanUpvote: Boolean!
  viewerDidAuthor: Boolean!
  viewerHasUpvoted: Boolean!
  viewerSubscription: SubscriptionState
}

type DiscussionCategory implements Node & RepositoryNode {
  createdAt: DateTime!
  description: String
  emoji: String!
  emojiHTML: HTML!
  id: ID!
  isAnswerable: Boolean!
  name: String!
  repository: Repository!
  slug: String!
  updatedAt: DateTime!
}

type DiscussionCategoryConnection {
  edges: [DiscussionCategoryEdge]
  nodes: [DiscussionCategory]
  pageInfo: PageInfo!
  totalCount: Int!
}

type DiscussionCategoryEdge {
  cursor: String!
  node: DiscussionCategory
}

enum DiscussionCloseReason {
  RESOLVED
  OUTDATED
  DUPLICATE
}

type DiscussionComment implements Comment & Deletable & Minimizable & Node & Reactable & Updatable & UpdatableComment & Votable {
  author: Actor
  authorAssociation: CommentAuthorAssociation!
  body: String!
  bodyHTML: HTML!
  bodyText: String!
  createdAt: DateTime!
  createdViaEmail: Boolean!
  databaseId: Int
  deletedAt: DateTime
  discussion: Discussion
  editor: Actor
  id: ID!
  includesCreatedEdit: Boolean!
  isAnswer: Boolean!
  isMinimized: Boolean!
  lastEditedAt: DateTime
  minimizedReason: String
  publishedAt: DateTime
  reactionGroups: [ReactionGroup!]
  reactions(after: ReactionConnection!, before: ReactionConnection!, first: ReactionConnection!, last: ReactionConnection!, content: ReactionConnection!, orderBy: ReactionConnection!): ReactionConnection!
  replies(after: DiscussionCommentConnection!, before: DiscussionCommentConnection!, first: DiscussionCommentConnection!, last: DiscussionCommentConnection!): DiscussionCommentConnection!
  replyTo: DiscussionComment
  resourcePath: URI!
  updatedAt: DateTime!
  upvoteCount: Int!
  url: URI!
  userContentEdits(after: UserContentEditConnection, before: UserContentEditConnection, first: UserContentEditConnection, last: UserContentEditConnection): UserContentEditConnection
  viewerCanDelete: Boolean!
  viewerCanMarkAsAnswer: Boolean!
  viewerCanMinimize: Boolean!
  viewerCanReact: Boolean!
  viewerCanUnmarkAsAnswer: Boolean!
  viewerCanUpdate: Boolean!
  viewerCanUpvote: Boolean!
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
  viewerDidAuthor: Boolean!
  viewerHasUpvoted: Boolean!
}

type DiscussionCommentConnection {
  edges: [DiscussionCommentEdge]
  nodes: [DiscussionComment]
  pageInfo: PageInfo!
  totalCount: Int!
}

type DiscussionCommentEdge {
  cursor: String!
  node: DiscussionComment
}

type DiscussionConnection {
  edges: [DiscussionEdge]
  nodes: [Discussion]
  pageInfo: PageInfo!
  totalCount: Int!
}

type DiscussionEdge {
  cursor: String!
  node: Discussion
}

input DiscussionOrder {
  field: DiscussionOrderField!
  direction: OrderDirection!
}

enum DiscussionOrderField {
  CREATED_AT
  UPDATED_AT
}

type DiscussionPoll implements Node {
  discussion: Discussion
  id: ID!
  options(after: DiscussionPollOptionConnection, before: DiscussionPollOptionConnection, first: DiscussionPollOptionConnection, last: DiscussionPollOptionConnection, orderBy: DiscussionPollOptionConnection): DiscussionPollOptionConnection
  question: String!
  totalVoteCount: Int!
  viewerCanVote: Boolean!
  viewerHasVoted: Boolean!
}

type DiscussionPollOption implements Node {
  id: ID!
  option: String!
  poll: DiscussionPoll
  totalVoteCount: Int!
  viewerHasVoted: Boolean!
}

type DiscussionPollOptionConnection {
  edges: [DiscussionPollOptionEdge]
  nodes: [DiscussionPollOption]
  pageInfo: PageInfo!
  totalCount: Int!
}

type DiscussionPollOptionEdge {
  cursor: String!
  node: DiscussionPollOption
}

input DiscussionPollOptionOrder {
  field: DiscussionPollOptionOrderField!
  direction: OrderDirection!
}

enum DiscussionPollOptionOrderField {
  AUTHORED_ORDER
  VOTE_COUNT
}

enum DiscussionState {
  OPEN
  CLOSED
}

enum DiscussionStateReason {
  RESOLVED
  OUTDATED
  DUPLICATE
  REOPENED
}

input DismissPullRequestReviewInput {
  clientMutationId: String
  pullRequestReviewId: ID!
  message: String!
}

type DismissPullRequestReviewPayload {
  clientMutationId: String
  pullRequestReview: PullRequestReview
}

enum DismissReason {
  FIX_STARTED
  NO_BANDWIDTH
  TOLERABLE_RISK
  INACCURATE
  NOT_USED
}

input DismissRepositoryVulnerabilityAlertInput {
  clientMutationId: String
  repositoryVulnerabilityAlertId: ID!
  dismissReason: DismissReason!
}

type DismissRepositoryVulnerabilityAlertPayload {
  clientMutationId: String
  repositoryVulnerabilityAlert: RepositoryVulnerabilityAlert
}

type DraftIssue implements Node {
  assignees(after: UserConnection!, before: UserConnection!, first: UserConnection!, last: UserConnection!): UserConnection!
  body: String!
  bodyHTML: HTML!
  bodyText: String!
  createdAt: DateTime!
  creator: Actor
  id: ID!
  projectV2Items(after: ProjectV2ItemConnection!, before: ProjectV2ItemConnection!, first: ProjectV2ItemConnection!, last: ProjectV2ItemConnection!): ProjectV2ItemConnection!
  projectsV2(after: ProjectV2Connection!, before: ProjectV2Connection!, first: ProjectV2Connection!, last: ProjectV2Connection!): ProjectV2Connection!
  title: String!
  updatedAt: DateTime!
}

input DraftPullRequestReviewComment {
  path: String!
  position: Int!
  body: String!
}

input DraftPullRequestReviewThread {
  path: String!
  line: Int!
  side: DiffSide
  startLine: Int
  startSide: DiffSide
  body: String!
}

input EnablePullRequestAutoMergeInput {
  clientMutationId: String
  pullRequestId: ID!
  commitHeadline: String
  commitBody: String
  mergeMethod: PullRequestMergeMethod
  authorEmail: String
  expectedHeadOid: GitObjectID
}

type EnablePullRequestAutoMergePayload {
  actor: Actor
  clientMutationId: String
  pullRequest: PullRequest
}

input EnqueuePullRequestInput {
  clientMutationId: String
  pullRequestId: ID!
  jump: Boolean
  expectedHeadOid: GitObjectID
}

type EnqueuePullRequestPayload {
  clientMutationId: String
  mergeQueueEntry: MergeQueueEntry
}

type Enterprise implements AnnouncementBanner & Node {
  announcement: String
  announcementCreatedAt: DateTime
  announcementExpiresAt: DateTime
  announcementUserDismissible: Boolean
  avatarUrl(size: URI!): URI!
  billingEmail: String
  billingInfo: EnterpriseBillingInfo
  createdAt: DateTime!
  databaseId: Int
  description: String
  descriptionHTML: HTML!
  id: ID!
  location: String
  members(organizationLogins: EnterpriseMemberConnection!, query: EnterpriseMemberConnection!, orderBy: EnterpriseMemberConnection!, role: EnterpriseMemberConnection!, deployment: EnterpriseMemberConnection!, hasTwoFactorEnabled: EnterpriseMemberConnection!, after: EnterpriseMemberConnection!, before: EnterpriseMemberConnection!, first: EnterpriseMemberConnection!, last: EnterpriseMemberConnection!): EnterpriseMemberConnection!
  name: String!
  organizations(query: OrganizationConnection!, viewerOrganizationRole: OrganizationConnection!, orderBy: OrganizationConnection!, after: OrganizationConnection!, before: OrganizationConnection!, first: OrganizationConnection!, last: OrganizationConnection!): OrganizationConnection!
  ownerInfo: EnterpriseOwnerInfo
  resourcePath: URI!
  slug: String!
  url: URI!
  viewerIsAdmin: Boolean!
  websiteUrl: URI
}

type EnterpriseAdministratorConnection {
  edges: [EnterpriseAdministratorEdge]
  nodes: [User]
  pageInfo: PageInfo!
  totalCount: Int!
}

type EnterpriseAdministratorEdge {
  cursor: String!
  node: User
  role: EnterpriseAdministratorRole!
}

type EnterpriseAdministratorInvitation implements Node {
  createdAt: DateTime!
  email: String
  enterprise: Enterprise!
  id: ID!
  invitee: User
  inviter: User
  role: EnterpriseAdministratorRole!
}

type EnterpriseAdministratorInvitationConnection {
  edges: [EnterpriseAdministratorInvitationEdge]
  nodes: [EnterpriseAdministratorInvitation]
  pageInfo: PageInfo!
  totalCount: Int!
}

type EnterpriseAdministratorInvitationEdge {
  cursor: String!
  node: EnterpriseAdministratorInvitation
}

input EnterpriseAdministratorInvitationOrder {
  field: EnterpriseAdministratorInvitationOrderField!
  direction: OrderDirection!
}

enum EnterpriseAdministratorInvitationOrderField {
  CREATED_AT
}

enum EnterpriseAdministratorRole {
  OWNER
  BILLING_MANAGER
}

enum EnterpriseAllowPrivateRepositoryForkingPolicyValue {
  ENTERPRISE_ORGANIZATIONS
  SAME_ORGANIZATION
  SAME_ORGANIZATION_USER_ACCOUNTS
  ENTERPRISE_ORGANIZATIONS_USER_ACCOUNTS
  USER_ACCOUNTS
  EVERYWHERE
}

interface EnterpriseAuditEntryData {
  enterpriseResourcePath: URI
  enterpriseSlug: String
  enterpriseUrl: URI
}

type EnterpriseBillingInfo {
  allLicensableUsersCount: Int!
  assetPacks: Int!
  bandwidthQuota: Float!
  bandwidthUsage: Float!
  bandwidthUsagePercentage: Int!
  storageQuota: Float!
  storageUsage: Float!
  storageUsagePercentage: Int!
  totalAvailableLicenses: Int!
  totalLicenses: Int!
}

type EnterpriseConnection {
  edges: [EnterpriseEdge]
  nodes: [Enterprise]
  pageInfo: PageInfo!
  totalCount: Int!
}

enum EnterpriseDefaultRepositoryPermissionSettingValue {
  NO_POLICY
  ADMIN
  WRITE
  READ
  NONE
}

type EnterpriseEdge {
  cursor: String!
  node: Enterprise
}

enum EnterpriseEnabledDisabledSettingValue {
  ENABLED
  DISABLED
  NO_POLICY
}

enum EnterpriseEnabledSettingValue {
  ENABLED
  NO_POLICY
}

type EnterpriseFailedInvitationConnection {
  edges: [EnterpriseFailedInvitationEdge]
  nodes: [OrganizationInvitation]
  pageInfo: PageInfo!
  totalCount: Int!
  totalUniqueUserCount: Int!
}

type EnterpriseFailedInvitationEdge {
  cursor: String!
  node: OrganizationInvitation
}

type EnterpriseIdentityProvider implements Node {
  digestMethod: SamlDigestAlgorithm
  enterprise: Enterprise
  externalIdentities(membersOnly: ExternalIdentityConnection!, login: ExternalIdentityConnection!, userName: ExternalIdentityConnection!, after: ExternalIdentityConnection!, before: ExternalIdentityConnection!, first: ExternalIdentityConnection!, last: ExternalIdentityConnection!): ExternalIdentityConnection!
  id: ID!
  idpCertificate: X509Certificate
  issuer: String
  recoveryCodes: [String!]
  signatureMethod: SamlSignatureAlgorithm
  ssoUrl: URI
}

union EnterpriseMember = EnterpriseUserAccount | User

type EnterpriseMemberConnection {
  edges: [EnterpriseMemberEdge]
  nodes: [EnterpriseMember]
  pageInfo: PageInfo!
  totalCount: Int!
}

type EnterpriseMemberEdge {
  cursor: String!
  node: EnterpriseMember
}

input EnterpriseMemberOrder {
  field: EnterpriseMemberOrderField!
  direction: OrderDirection!
}

enum EnterpriseMemberOrderField {
  LOGIN
  CREATED_AT
}

enum EnterpriseMembersCanCreateRepositoriesSettingValue {
  NO_POLICY
  ALL
  PUBLIC
  PRIVATE
  DISABLED
}

enum EnterpriseMembersCanMakePurchasesSettingValue {
  ENABLED
  DISABLED
}

enum EnterpriseMembershipType {
  ALL
  ADMIN
  BILLING_MANAGER
  ORG_MEMBERSHIP
}

input EnterpriseOrder {
  field: EnterpriseOrderField!
  direction: OrderDirection!
}

enum EnterpriseOrderField {
  NAME
}

type EnterpriseOrganizationMembershipConnection {
  edges: [EnterpriseOrganizationMembershipEdge]
  nodes: [Organization]
  pageInfo: PageInfo!
  totalCount: Int!
}

type EnterpriseOrganizationMembershipEdge {
  cursor: String!
  node: Organization
  role: EnterpriseUserAccountMembershipRole!
}

type EnterpriseOutsideCollaboratorConnection {
  edges: [EnterpriseOutsideCollaboratorEdge]
  nodes: [User]
  pageInfo: PageInfo!
  totalCount: Int!
}

type EnterpriseOutsideCollaboratorEdge {
  cursor: String!
  node: User
  repositories(after: EnterpriseRepositoryInfoConnection!, before: EnterpriseRepositoryInfoConnection!, first: EnterpriseRepositoryInfoConnection!, last: EnterpriseRepositoryInfoConnection!, orderBy: EnterpriseRepositoryInfoConnection!): EnterpriseRepositoryInfoConnection!
}

type EnterpriseOwnerInfo {
  admins(organizationLogins: EnterpriseAdministratorConnection!, query: EnterpriseAdministratorConnection!, role: EnterpriseAdministratorConnection!, orderBy: EnterpriseAdministratorConnection!, hasTwoFactorEnabled: EnterpriseAdministratorConnection!, after: EnterpriseAdministratorConnection!, before: EnterpriseAdministratorConnection!, first: EnterpriseAdministratorConnection!, last: EnterpriseAdministratorConnection!): EnterpriseAdministratorConnection!
  affiliatedUsersWithTwoFactorDisabled(after: UserConnection!, before: UserConnection!, first: UserConnection!, last: UserConnection!): UserConnection!
  affiliatedUsersWithTwoFactorDisabledExist: Boolean!
  allowPrivateRepositoryForkingSetting: EnterpriseEnabledDisabledSettingValue!
  allowPrivateRepositoryForkingSettingOrganizations(after: OrganizationConnection!, before: OrganizationConnection!, first: OrganizationConnection!, last: OrganizationConnection!, value: OrganizationConnection!, orderBy: OrganizationConnection!): OrganizationConnection!
  allowPrivateRepositoryForkingSettingPolicyValue: EnterpriseAllowPrivateRepositoryForkingPolicyValue
  defaultRepositoryPermissionSetting: EnterpriseDefaultRepositoryPermissionSettingValue!
  defaultRepositoryPermissionSettingOrganizations(after: OrganizationConnection!, before: OrganizationConnection!, first: OrganizationConnection!, last: OrganizationConnection!, value: OrganizationConnection!, orderBy: OrganizationConnection!): OrganizationConnection!
  domains(after: VerifiableDomainConnection!, before: VerifiableDomainConnection!, first: VerifiableDomainConnection!, last: VerifiableDomainConnection!, isVerified: VerifiableDomainConnection!, isApproved: VerifiableDomainConnection!, orderBy: VerifiableDomainConnection!): VerifiableDomainConnection!
  enterpriseServerInstallations(after: EnterpriseServerInstallationConnection!, before: EnterpriseServerInstallationConnection!, first: EnterpriseServerInstallationConnection!, last: EnterpriseServerInstallationConnection!, connectedOnly: EnterpriseServerInstallationConnection!, orderBy: EnterpriseServerInstallationConnection!): EnterpriseServerInstallationConnection!
  failedInvitations(query: EnterpriseFailedInvitationConnection!, after: EnterpriseFailedInvitationConnection!, before: EnterpriseFailedInvitationConnection!, first: EnterpriseFailedInvitationConnection!, last: EnterpriseFailedInvitationConnection!): EnterpriseFailedInvitationConnection!
  ipAllowListEnabledSetting: IpAllowListEnabledSettingValue!
  ipAllowListEntries(after: IpAllowListEntryConnection!, before: IpAllowListEntryConnection!, first: IpAllowListEntryConnection!, last: IpAllowListEntryConnection!, orderBy: IpAllowListEntryConnection!): IpAllowListEntryConnection!
  ipAllowListForInstalledAppsEnabledSetting: IpAllowListForInstalledAppsEnabledSettingValue!
  isUpdatingDefaultRepositoryPermission: Boolean!
  isUpdatingTwoFactorRequirement: Boolean!
  membersCanChangeRepositoryVisibilitySetting: EnterpriseEnabledDisabledSettingValue!
  membersCanChangeRepositoryVisibilitySettingOrganizations(after: OrganizationConnection!, before: OrganizationConnection!, first: OrganizationConnection!, last: OrganizationConnection!, value: OrganizationConnection!, orderBy: OrganizationConnection!): OrganizationConnection!
  membersCanCreateInternalRepositoriesSetting: Boolean
  membersCanCreatePrivateRepositoriesSetting: Boolean
  membersCanCreatePublicRepositoriesSetting: Boolean
  membersCanCreateRepositoriesSetting: EnterpriseMembersCanCreateRepositoriesSettingValue
  membersCanCreateRepositoriesSettingOrganizations(after: OrganizationConnection!, before: OrganizationConnection!, first: OrganizationConnection!, last: OrganizationConnection!, value: OrganizationConnection!, orderBy: OrganizationConnection!): OrganizationConnection!
  membersCanDeleteIssuesSetting: EnterpriseEnabledDisabledSettingValue!
  membersCanDeleteIssuesSettingOrganizations(after: OrganizationConnection!, before: OrganizationConnection!, first: OrganizationConnection!, last: OrganizationConnection!, value: OrganizationConnection!, orderBy: OrganizationConnection!): OrganizationConnection!
  membersCanDeleteRepositoriesSetting: EnterpriseEnabledDisabledSettingValue!
  membersCanDeleteRepositoriesSettingOrganizations(after: OrganizationConnection!, before: OrganizationConnection!, first: OrganizationConnection!, last: OrganizationConnection!, value: OrganizationConnection!, orderBy: OrganizationConnection!): OrganizationConnection!
  membersCanInviteCollaboratorsSetting: EnterpriseEnabledDisabledSettingValue!
  membersCanInviteCollaboratorsSettingOrganizations(after: OrganizationConnection!, before: OrganizationConnection!, first: OrganizationConnection!, last: OrganizationConnection!, value: OrganizationConnection!, orderBy: OrganizationConnection!): OrganizationConnection!
  membersCanMakePurchasesSetting: EnterpriseMembersCanMakePurchasesSettingValue!
  membersCanUpdateProtectedBranchesSetting: EnterpriseEnabledDisabledSettingValue!
  membersCanUpdateProtectedBranchesSettingOrganizations(after: OrganizationConnection!, before: OrganizationConnection!, first: OrganizationConnection!, last: OrganizationConnection!, value: OrganizationConnection!, orderBy: OrganizationConnection!): OrganizationConnection!
  membersCanViewDependencyInsightsSetting: EnterpriseEnabledDisabledSettingValue!
  membersCanViewDependencyInsightsSettingOrganizations(after: OrganizationConnection!, before: OrganizationConnection!, first: OrganizationConnection!, last: OrganizationConnection!, value: OrganizationConnection!, orderBy: OrganizationConnection!): OrganizationConnection!
  notificationDeliveryRestrictionEnabledSetting: NotificationRestrictionSettingValue!
  oidcProvider: OIDCProvider
  organizationProjectsSetting: EnterpriseEnabledDisabledSettingValue!
  organizationProjectsSettingOrganizations(after: OrganizationConnection!, before: OrganizationConnection!, first: OrganizationConnection!, last: OrganizationConnection!, value: OrganizationConnection!, orderBy: OrganizationConnection!): OrganizationConnection!
  outsideCollaborators(login: EnterpriseOutsideCollaboratorConnection!, query: EnterpriseOutsideCollaboratorConnection!, orderBy: EnterpriseOutsideCollaboratorConnection!, visibility: EnterpriseOutsideCollaboratorConnection!, hasTwoFactorEnabled: EnterpriseOutsideCollaboratorConnection!, organizationLogins: EnterpriseOutsideCollaboratorConnection!, after: EnterpriseOutsideCollaboratorConnection!, before: EnterpriseOutsideCollaboratorConnection!, first: EnterpriseOutsideCollaboratorConnection!, last: EnterpriseOutsideCollaboratorConnection!): EnterpriseOutsideCollaboratorConnection!
  pendingAdminInvitations(query: EnterpriseAdministratorInvitationConnection!, orderBy: EnterpriseAdministratorInvitationConnection!, role: EnterpriseAdministratorInvitationConnection!, after: EnterpriseAdministratorInvitationConnection!, before: EnterpriseAdministratorInvitationConnection!, first: EnterpriseAdministratorInvitationConnection!, last: EnterpriseAdministratorInvitationConnection!): EnterpriseAdministratorInvitationConnection!
  pendingCollaboratorInvitations(query: RepositoryInvitationConnection!, orderBy: RepositoryInvitationConnection!, after: RepositoryInvitationConnection!, before: RepositoryInvitationConnection!, first: RepositoryInvitationConnection!, last: RepositoryInvitationConnection!): RepositoryInvitationConnection!
  pendingMemberInvitations(query: EnterprisePendingMemberInvitationConnection!, organizationLogins: EnterprisePendingMemberInvitationConnection!, invitationSource: EnterprisePendingMemberInvitationConnection!, after: EnterprisePendingMemberInvitationConnection!, before: EnterprisePendingMemberInvitationConnection!, first: EnterprisePendingMemberInvitationConnection!, last: EnterprisePendingMemberInvitationConnection!): EnterprisePendingMemberInvitationConnection!
  repositoryProjectsSetting: EnterpriseEnabledDisabledSettingValue!
  repositoryProjectsSettingOrganizations(after: OrganizationConnection!, before: OrganizationConnection!, first: OrganizationConnection!, last: OrganizationConnection!, value: OrganizationConnection!, orderBy: OrganizationConnection!): OrganizationConnection!
  samlIdentityProvider: EnterpriseIdentityProvider
  samlIdentityProviderSettingOrganizations(after: OrganizationConnection!, before: OrganizationConnection!, first: OrganizationConnection!, last: OrganizationConnection!, value: OrganizationConnection!, orderBy: OrganizationConnection!): OrganizationConnection!
  supportEntitlements(orderBy: EnterpriseMemberConnection!, after: EnterpriseMemberConnection!, before: EnterpriseMemberConnection!, first: EnterpriseMemberConnection!, last: EnterpriseMemberConnection!): EnterpriseMemberConnection!
  teamDiscussionsSetting: EnterpriseEnabledDisabledSettingValue!
  teamDiscussionsSettingOrganizations(after: OrganizationConnection!, before: OrganizationConnection!, first: OrganizationConnection!, last: OrganizationConnection!, value: OrganizationConnection!, orderBy: OrganizationConnection!): OrganizationConnection!
  twoFactorRequiredSetting: EnterpriseEnabledSettingValue!
  twoFactorRequiredSettingOrganizations(after: OrganizationConnection!, before: OrganizationConnection!, first: OrganizationConnection!, last: OrganizationConnection!, value: OrganizationConnection!, orderBy: OrganizationConnection!): OrganizationConnection!
}

type EnterprisePendingMemberInvitationConnection {
  edges: [EnterprisePendingMemberInvitationEdge]
  nodes: [OrganizationInvitation]
  pageInfo: PageInfo!
  totalCount: Int!
  totalUniqueUserCount: Int!
}

type EnterprisePendingMemberInvitationEdge {
  cursor: String!
  node: OrganizationInvitation
}

type EnterpriseRepositoryInfo implements Node {
  id: ID!
  isPrivate: Boolean!
  name: String!
  nameWithOwner: String!
}

type EnterpriseRepositoryInfoConnection {
  edges: [EnterpriseRepositoryInfoEdge]
  nodes: [EnterpriseRepositoryInfo]
  pageInfo: PageInfo!
  totalCount: Int!
}

type EnterpriseRepositoryInfoEdge {
  cursor: String!
  node: EnterpriseRepositoryInfo
}

type EnterpriseServerInstallation implements Node {
  createdAt: DateTime!
  customerName: String!
  hostName: String!
  id: ID!
  isConnected: Boolean!
  updatedAt: DateTime!
  userAccounts(orderBy: EnterpriseServerUserAccountConnection!, after: EnterpriseServerUserAccountConnection!, before: EnterpriseServerUserAccountConnection!, first: EnterpriseServerUserAccountConnection!, last: EnterpriseServerUserAccountConnection!): EnterpriseServerUserAccountConnection!
  userAccountsUploads(orderBy: EnterpriseServerUserAccountsUploadConnection!, after: EnterpriseServerUserAccountsUploadConnection!, before: EnterpriseServerUserAccountsUploadConnection!, first: EnterpriseServerUserAccountsUploadConnection!, last: EnterpriseServerUserAccountsUploadConnection!): EnterpriseServerUserAccountsUploadConnection!
}

type EnterpriseServerInstallationConnection {
  edges: [EnterpriseServerInstallationEdge]
  nodes: [EnterpriseServerInstallation]
  pageInfo: PageInfo!
  totalCount: Int!
}

type EnterpriseServerInstallationEdge {
  cursor: String!
  node: EnterpriseServerInstallation
}

type EnterpriseServerInstallationMembershipConnection {
  edges: [EnterpriseServerInstallationMembershipEdge]
  nodes: [EnterpriseServerInstallation]
  pageInfo: PageInfo!
  totalCount: Int!
}

type EnterpriseServerInstallationMembershipEdge {
  cursor: String!
  node: EnterpriseServerInstallation
  role: EnterpriseUserAccountMembershipRole!
}

input EnterpriseServerInstallationOrder {
  field: EnterpriseServerInstallationOrderField!
  direction: OrderDirection!
}

enum EnterpriseServerInstallationOrderField {
  HOST_NAME
  CUSTOMER_NAME
  CREATED_AT
}

type EnterpriseServerUserAccount implements Node {
  createdAt: DateTime!
  emails(orderBy: EnterpriseServerUserAccountEmailConnection!, after: EnterpriseServerUserAccountEmailConnection!, before: EnterpriseServerUserAccountEmailConnection!, first: EnterpriseServerUserAccountEmailConnection!, last: EnterpriseServerUserAccountEmailConnection!): EnterpriseServerUserAccountEmailConnection!
  enterpriseServerInstallation: EnterpriseServerInstallation!
  id: ID!
  isSiteAdmin: Boolean!
  login: String!
  profileName: String
  remoteCreatedAt: DateTime!
  remoteUserId: Int!
  updatedAt: DateTime!
}

type EnterpriseServerUserAccountConnection {
  edges: [EnterpriseServerUserAccountEdge]
  nodes: [EnterpriseServerUserAccount]
  pageInfo: PageInfo!
  totalCount: Int!
}

type EnterpriseServerUserAccountEdge {
  cursor: String!
  node: EnterpriseServerUserAccount
}

type EnterpriseServerUserAccountEmail implements Node {
  createdAt: DateTime!
  email: String!
  id: ID!
  isPrimary: Boolean!
  updatedAt: DateTime!
  userAccount: EnterpriseServerUserAccount!
}

type EnterpriseServerUserAccountEmailConnection {
  edges: [EnterpriseServerUserAccountEmailEdge]
  nodes: [EnterpriseServerUserAccountEmail]
  pageInfo: PageInfo!
  totalCount: Int!
}

type EnterpriseServerUserAccountEmailEdge {
  cursor: String!
  node: EnterpriseServerUserAccountEmail
}

input EnterpriseServerUserAccountEmailOrder {
  field: EnterpriseServerUserAccountEmailOrderField!
  direction: OrderDirection!
}

enum EnterpriseServerUserAccountEmailOrderField {
  EMAIL
}

input EnterpriseServerUserAccountOrder {
  field: EnterpriseServerUserAccountOrderField!
  direction: OrderDirection!
}

enum EnterpriseServerUserAccountOrderField {
  LOGIN
  REMOTE_CREATED_AT
}

type EnterpriseServerUserAccountsUpload implements Node {
  createdAt: DateTime!
  enterprise: Enterprise!
  enterpriseServerInstallation: EnterpriseServerInstallation!
  id: ID!
  name: String!
  syncState: EnterpriseServerUserAccountsUploadSyncState!
  updatedAt: DateTime!
}

type EnterpriseServerUserAccountsUploadConnection {
  edges: [EnterpriseServerUserAccountsUploadEdge]
  nodes: [EnterpriseServerUserAccountsUpload]
  pageInfo: PageInfo!
  totalCount: Int!
}

type EnterpriseServerUserAccountsUploadEdge {
  cursor: String!
  node: EnterpriseServerUserAccountsUpload
}

input EnterpriseServerUserAccountsUploadOrder {
  field: EnterpriseServerUserAccountsUploadOrderField!
  direction: OrderDirection!
}

enum EnterpriseServerUserAccountsUploadOrderField {
  CREATED_AT
}

enum EnterpriseServerUserAccountsUploadSyncState {
  PENDING
  SUCCESS
  FAILURE
}

type EnterpriseUserAccount implements Actor & Node {
  avatarUrl(size: URI!): URI!
  createdAt: DateTime!
  enterprise: Enterprise!
  enterpriseInstallations(query: EnterpriseServerInstallationMembershipConnection!, orderBy: EnterpriseServerInstallationMembershipConnection!, role: EnterpriseServerInstallationMembershipConnection!, after: EnterpriseServerInstallationMembershipConnection!, before: EnterpriseServerInstallationMembershipConnection!, first: EnterpriseServerInstallationMembershipConnection!, last: EnterpriseServerInstallationMembershipConnection!): EnterpriseServerInstallationMembershipConnection!
  id: ID!
  login: String!
  name: String
  organizations(query: EnterpriseOrganizationMembershipConnection!, orderBy: EnterpriseOrganizationMembershipConnection!, role: EnterpriseOrganizationMembershipConnection!, after: EnterpriseOrganizationMembershipConnection!, before: EnterpriseOrganizationMembershipConnection!, first: EnterpriseOrganizationMembershipConnection!, last: EnterpriseOrganizationMembershipConnection!): EnterpriseOrganizationMembershipConnection!
  resourcePath: URI!
  updatedAt: DateTime!
  url: URI!
  user: User
}

enum EnterpriseUserAccountMembershipRole {
  MEMBER
  OWNER
  UNAFFILIATED
}

enum EnterpriseUserDeployment {
  CLOUD
  SERVER
}

type Environment implements Node {
  databaseId: Int
  id: ID!
  isPinned: Boolean
  latestCompletedDeployment: Deployment
  name: String!
  pinnedPosition: Int
  protectionRules(after: DeploymentProtectionRuleConnection!, before: DeploymentProtectionRuleConnection!, first: DeploymentProtectionRuleConnection!, last: DeploymentProtectionRuleConnection!): DeploymentProtectionRuleConnection!
}

type EnvironmentConnection {
  edges: [EnvironmentEdge]
  nodes: [Environment]
  pageInfo: PageInfo!
  totalCount: Int!
}

type EnvironmentEdge {
  cursor: String!
  node: Environment
}

enum EnvironmentOrderField {
  NAME
}

enum EnvironmentPinnedFilterField {
  ALL
  ONLY
  NONE
}

input Environments {
  field: EnvironmentOrderField!
  direction: OrderDirection!
}

type ExternalIdentity implements Node {
  guid: String!
  id: ID!
  organizationInvitation: OrganizationInvitation
  samlIdentity: ExternalIdentitySamlAttributes
  scimIdentity: ExternalIdentityScimAttributes
  user: User
}

type ExternalIdentityAttribute {
  metadata: String
  name: String!
  value: String!
}

type ExternalIdentityConnection {
  edges: [ExternalIdentityEdge]
  nodes: [ExternalIdentity]
  pageInfo: PageInfo!
  totalCount: Int!
}

type ExternalIdentityEdge {
  cursor: String!
  node: ExternalIdentity
}

type ExternalIdentitySamlAttributes {
  attributes: [ExternalIdentityAttribute!]!
  emails: [UserEmailMetadata!]
  familyName: String
  givenName: String
  groups: [String!]
  nameId: String
  username: String
}

type ExternalIdentityScimAttributes {
  emails: [UserEmailMetadata!]
  familyName: String
  givenName: String
  groups: [String!]
  username: String
}

input FileAddition {
  path: String!
  contents: Base64String!
}

input FileChanges {
  deletions: [FileDeletion!]
  additions: [FileAddition!]
}

input FileDeletion {
  path: String!
}

type FileExtensionRestrictionParameters {
  restrictedFileExtensions: [String!]!
}

input FileExtensionRestrictionParametersInput {
  restrictedFileExtensions: []!
}

type FilePathRestrictionParameters {
  restrictedFilePaths: [String!]!
}

input FilePathRestrictionParametersInput {
  restrictedFilePaths: []!
}

enum FileViewedState {
  DISMISSED
  VIEWED
  UNVIEWED
}

scalar Float

input FollowOrganizationInput {
  clientMutationId: String
  organizationId: ID!
}

type FollowOrganizationPayload {
  clientMutationId: String
  organization: Organization
}

input FollowUserInput {
  clientMutationId: String
  userId: ID!
}

type FollowUserPayload {
  clientMutationId: String
  user: User
}

type FollowerConnection {
  edges: [UserEdge]
  nodes: [User]
  pageInfo: PageInfo!
  totalCount: Int!
}

type FollowingConnection {
  edges: [UserEdge]
  nodes: [User]
  pageInfo: PageInfo!
  totalCount: Int!
}

type FundingLink {
  platform: FundingPlatform!
  url: URI!
}

enum FundingPlatform {
  GITHUB
  PATREON
  OPEN_COLLECTIVE
  KO_FI
  TIDELIFT
  COMMUNITY_BRIDGE
  LIBERAPAY
  ISSUEHUNT
  LFX_CROWDFUNDING
  POLAR
  BUY_ME_A_COFFEE
  CUSTOM
}

type GenericHovercardContext implements HovercardContext {
  message: String!
  octicon: String!
}

type Gist implements Node & Starrable & UniformResourceLocatable {
  comments(after: GistCommentConnection!, before: GistCommentConnection!, first: GistCommentConnection!, last: GistCommentConnection!): GistCommentConnection!
  createdAt: DateTime!
  description: String
  files(limit: [GistFile], oid: [GistFile]): [GistFile]
  forks(after: GistConnection!, before: GistConnection!, first: GistConnection!, last: GistConnection!, orderBy: GistConnection!): GistConnection!
  id: ID!
  isFork: Boolean!
  isPublic: Boolean!
  name: String!
  owner: RepositoryOwner
  pushedAt: DateTime
  resourcePath: URI!
  stargazerCount: Int!
  stargazers(after: StargazerConnection!, before: StargazerConnection!, first: StargazerConnection!, last: StargazerConnection!, orderBy: StargazerConnection!): StargazerConnection!
  updatedAt: DateTime!
  url: URI!
  viewerHasStarred: Boolean!
}

type GistComment implements Comment & Deletable & Minimizable & Node & Updatable & UpdatableComment {
  author: Actor
  authorAssociation: CommentAuthorAssociation!
  body: String!
  bodyHTML: HTML!
  bodyText: String!
  createdAt: DateTime!
  createdViaEmail: Boolean!
  databaseId: Int
  editor: Actor
  gist: Gist!
  id: ID!
  includesCreatedEdit: Boolean!
  isMinimized: Boolean!
  lastEditedAt: DateTime
  minimizedReason: String
  publishedAt: DateTime
  updatedAt: DateTime!
  userContentEdits(after: UserContentEditConnection, before: UserContentEditConnection, first: UserContentEditConnection, last: UserContentEditConnection): UserContentEditConnection
  viewerCanDelete: Boolean!
  viewerCanMinimize: Boolean!
  viewerCanUpdate: Boolean!
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
  viewerDidAuthor: Boolean!
}

type GistCommentConnection {
  edges: [GistCommentEdge]
  nodes: [GistComment]
  pageInfo: PageInfo!
  totalCount: Int!
}

type GistCommentEdge {
  cursor: String!
  node: GistComment
}

type GistConnection {
  edges: [GistEdge]
  nodes: [Gist]
  pageInfo: PageInfo!
  totalCount: Int!
}

type GistEdge {
  cursor: String!
  node: Gist
}

type GistFile {
  encodedName: String
  encoding: String
  extension: String
  isImage: Boolean!
  isTruncated: Boolean!
  language: Language
  name: String
  size: Int
  text(truncate: String): String
}

input GistOrder {
  field: GistOrderField!
  direction: OrderDirection!
}

enum GistOrderField {
  CREATED_AT
  UPDATED_AT
  PUSHED_AT
}

enum GistPrivacy {
  PUBLIC
  SECRET
  ALL
}

type GitActor {
  avatarUrl(size: URI!): URI!
  date: GitTimestamp
  email: String
  name: String
  user: User
}

type GitActorConnection {
  edges: [GitActorEdge]
  nodes: [GitActor]
  pageInfo: PageInfo!
  totalCount: Int!
}

type GitActorEdge {
  cursor: String!
  node: GitActor
}

type GitHubMetadata {
  gitHubServicesSha: GitObjectID!
  gitIpAddresses: [String!]
  githubEnterpriseImporterIpAddresses: [String!]
  hookIpAddresses: [String!]
  importerIpAddresses: [String!]
  isPasswordAuthenticationVerifiable: Boolean!
  pagesIpAddresses: [String!]
}

interface GitObject {
  abbreviatedOid: String!
  commitResourcePath: URI!
  commitUrl: URI!
  id: ID!
  oid: GitObjectID!
  repository: Repository!
}

scalar GitObjectID

scalar GitRefname

scalar GitSSHRemote

interface GitSignature {
  email: String!
  isValid: Boolean!
  payload: String!
  signature: String!
  signer: User
  state: GitSignatureState!
  wasSignedByGitHub: Boolean!
}

enum GitSignatureState {
  VALID
  INVALID
  MALFORMED_SIG
  UNKNOWN_KEY
  BAD_EMAIL
  UNVERIFIED_EMAIL
  NO_USER
  UNKNOWN_SIG_TYPE
  UNSIGNED
  GPGVERIFY_UNAVAILABLE
  GPGVERIFY_ERROR
  NOT_SIGNING_KEY
  EXPIRED_KEY
  OCSP_PENDING
  OCSP_ERROR
  BAD_CERT
  OCSP_REVOKED
}

scalar GitTimestamp

type GpgSignature implements GitSignature {
  email: String!
  isValid: Boolean!
  keyId: String
  payload: String!
  signature: String!
  signer: User
  state: GitSignatureState!
  wasSignedByGitHub: Boolean!
}

input GrantEnterpriseOrganizationsMigratorRoleInput {
  clientMutationId: String
  enterpriseId: ID!
  login: String!
}

type GrantEnterpriseOrganizationsMigratorRolePayload {
  clientMutationId: String
  organizations(after: OrganizationConnection, before: OrganizationConnection, first: OrganizationConnection, last: OrganizationConnection): OrganizationConnection
}

input GrantMigratorRoleInput {
  clientMutationId: String
  organizationId: ID!
  actor: String!
  actorType: ActorType!
}

type GrantMigratorRolePayload {
  clientMutationId: String
  success: Boolean
}

scalar HTML

type HeadRefDeletedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  headRef: Ref
  headRefName: String!
  id: ID!
  pullRequest: PullRequest!
}

type HeadRefForcePushedEvent implements Node {
  actor: Actor
  afterCommit: Commit
  beforeCommit: Commit
  createdAt: DateTime!
  id: ID!
  pullRequest: PullRequest!
  ref: Ref
}

type HeadRefRestoredEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  pullRequest: PullRequest!
}

type Hovercard {
  contexts: [HovercardContext!]!
}

interface HovercardContext {
  message: String!
  octicon: String!
}

scalar ID

enum IdentityProviderConfigurationState {
  ENFORCED
  CONFIGURED
  UNCONFIGURED
}

input ImportProjectInput {
  clientMutationId: String
  ownerName: String!
  name: String!
  body: String
  public: Boolean
  columnImports: []!
}

type ImportProjectPayload {
  clientMutationId: String
  project: Project
}

scalar Int

input InviteEnterpriseAdminInput {
  clientMutationId: String
  enterpriseId: ID!
  invitee: String
  email: String
  role: EnterpriseAdministratorRole
}

type InviteEnterpriseAdminPayload {
  clientMutationId: String
  invitation: EnterpriseAdministratorInvitation
}

enum IpAllowListEnabledSettingValue {
  ENABLED
  DISABLED
}

type IpAllowListEntry implements Node {
  allowListValue: String!
  createdAt: DateTime!
  id: ID!
  isActive: Boolean!
  name: String
  owner: IpAllowListOwner!
  updatedAt: DateTime!
}

type IpAllowListEntryConnection {
  edges: [IpAllowListEntryEdge]
  nodes: [IpAllowListEntry]
  pageInfo: PageInfo!
  totalCount: Int!
}

type IpAllowListEntryEdge {
  cursor: String!
  node: IpAllowListEntry
}

input IpAllowListEntryOrder {
  field: IpAllowListEntryOrderField!
  direction: OrderDirection!
}

enum IpAllowListEntryOrderField {
  CREATED_AT
  ALLOW_LIST_VALUE
}

enum IpAllowListForInstalledAppsEnabledSettingValue {
  ENABLED
  DISABLED
}

union IpAllowListOwner = App | Enterprise | Organization

type Issue implements Assignable & Closable & Comment & Deletable & Labelable & Lockable & Node & ProjectV2Owner & Reactable & RepositoryNode & Subscribable & SubscribableThread & UniformResourceLocatable & Updatable & UpdatableComment {
  activeLockReason: LockReason
  assignees(after: UserConnection!, before: UserConnection!, first: UserConnection!, last: UserConnection!): UserConnection!
  author: Actor
  authorAssociation: CommentAuthorAssociation!
  body: String!
  bodyHTML: HTML!
  bodyResourcePath: URI!
  bodyText: String!
  bodyUrl: URI!
  closed: Boolean!
  closedAt: DateTime
  comments(orderBy: IssueCommentConnection!, after: IssueCommentConnection!, before: IssueCommentConnection!, first: IssueCommentConnection!, last: IssueCommentConnection!): IssueCommentConnection!
  createdAt: DateTime!
  createdViaEmail: Boolean!
  databaseId: Int
  editor: Actor
  fullDatabaseId: BigInt
  hovercard(includeNotificationContexts: Hovercard!): Hovercard!
  id: ID!
  includesCreatedEdit: Boolean!
  isPinned: Boolean
  isReadByViewer: Boolean
  labels(orderBy: LabelConnection, after: LabelConnection, before: LabelConnection, first: LabelConnection, last: LabelConnection): LabelConnection
  lastEditedAt: DateTime
  linkedBranches(after: LinkedBranchConnection!, before: LinkedBranchConnection!, first: LinkedBranchConnection!, last: LinkedBranchConnection!): LinkedBranchConnection!
  locked: Boolean!
  milestone: Milestone
  number: Int!
  participants(after: UserConnection!, before: UserConnection!, first: UserConnection!, last: UserConnection!): UserConnection!
  projectCards(after: ProjectCardConnection!, before: ProjectCardConnection!, first: ProjectCardConnection!, last: ProjectCardConnection!, archivedStates: ProjectCardConnection!): ProjectCardConnection!
  projectItems(includeArchived: ProjectV2ItemConnection!, after: ProjectV2ItemConnection!, before: ProjectV2ItemConnection!, first: ProjectV2ItemConnection!, last: ProjectV2ItemConnection!): ProjectV2ItemConnection!
  projectV2(number: ProjectV2): ProjectV2
  projectsV2(query: ProjectV2Connection!, orderBy: ProjectV2Connection!, after: ProjectV2Connection!, before: ProjectV2Connection!, first: ProjectV2Connection!, last: ProjectV2Connection!): ProjectV2Connection!
  publishedAt: DateTime
  reactionGroups: [ReactionGroup!]
  reactions(after: ReactionConnection!, before: ReactionConnection!, first: ReactionConnection!, last: ReactionConnection!, content: ReactionConnection!, orderBy: ReactionConnection!): ReactionConnection!
  repository: Repository!
  resourcePath: URI!
  state: IssueState!
  stateReason: IssueStateReason
  timeline(since: IssueTimelineConnection!, after: IssueTimelineConnection!, before: IssueTimelineConnection!, first: IssueTimelineConnection!, last: IssueTimelineConnection!): IssueTimelineConnection!
  timelineItems(since: IssueTimelineItemsConnection!, skip: IssueTimelineItemsConnection!, itemTypes: IssueTimelineItemsConnection!, after: IssueTimelineItemsConnection!, before: IssueTimelineItemsConnection!, first: IssueTimelineItemsConnection!, last: IssueTimelineItemsConnection!): IssueTimelineItemsConnection!
  title: String!
  titleHTML: String!
  trackedInIssues(after: IssueConnection!, before: IssueConnection!, first: IssueConnection!, last: IssueConnection!): IssueConnection!
  trackedIssues(after: IssueConnection!, before: IssueConnection!, first: IssueConnection!, last: IssueConnection!): IssueConnection!
  trackedIssuesCount(states: Int!): Int!
  updatedAt: DateTime!
  url: URI!
  userContentEdits(after: UserContentEditConnection, before: UserContentEditConnection, first: UserContentEditConnection, last: UserContentEditConnection): UserContentEditConnection
  viewerCanClose: Boolean!
  viewerCanDelete: Boolean!
  viewerCanReact: Boolean!
  viewerCanReopen: Boolean!
  viewerCanSubscribe: Boolean!
  viewerCanUpdate: Boolean!
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
  viewerDidAuthor: Boolean!
  viewerSubscription: SubscriptionState
  viewerThreadSubscriptionFormAction: ThreadSubscriptionFormAction
  viewerThreadSubscriptionStatus: ThreadSubscriptionState
}

enum IssueClosedStateReason {
  COMPLETED
  NOT_PLANNED
}

type IssueComment implements Comment & Deletable & Minimizable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment {
  author: Actor
  authorAssociation: CommentAuthorAssociation!
  body: String!
  bodyHTML: HTML!
  bodyText: String!
  createdAt: DateTime!
  createdViaEmail: Boolean!
  databaseId: Int
  editor: Actor
  fullDatabaseId: BigInt
  id: ID!
  includesCreatedEdit: Boolean!
  isMinimized: Boolean!
  issue: Issue!
  lastEditedAt: DateTime
  minimizedReason: String
  publishedAt: DateTime
  pullRequest: PullRequest
  reactionGroups: [ReactionGroup!]
  reactions(after: ReactionConnection!, before: ReactionConnection!, first: ReactionConnection!, last: ReactionConnection!, content: ReactionConnection!, orderBy: ReactionConnection!): ReactionConnection!
  repository: Repository!
  resourcePath: URI!
  updatedAt: DateTime!
  url: URI!
  userContentEdits(after: UserContentEditConnection, before: UserContentEditConnection, first: UserContentEditConnection, last: UserContentEditConnection): UserContentEditConnection
  viewerCanDelete: Boolean!
  viewerCanMinimize: Boolean!
  viewerCanReact: Boolean!
  viewerCanUpdate: Boolean!
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
  viewerDidAuthor: Boolean!
}

type IssueCommentConnection {
  edges: [IssueCommentEdge]
  nodes: [IssueComment]
  pageInfo: PageInfo!
  totalCount: Int!
}

type IssueCommentEdge {
  cursor: String!
  node: IssueComment
}

input IssueCommentOrder {
  field: IssueCommentOrderField!
  direction: OrderDirection!
}

enum IssueCommentOrderField {
  UPDATED_AT
}

type IssueConnection {
  edges: [IssueEdge]
  nodes: [Issue]
  pageInfo: PageInfo!
  totalCount: Int!
}

type IssueContributionsByRepository {
  contributions(after: CreatedIssueContributionConnection!, before: CreatedIssueContributionConnection!, first: CreatedIssueContributionConnection!, last: CreatedIssueContributionConnection!, orderBy: CreatedIssueContributionConnection!): CreatedIssueContributionConnection!
  repository: Repository!
}

type IssueEdge {
  cursor: String!
  node: Issue
}

input IssueFilters {
  assignee: String
  createdBy: String
  labels: [String!]
  mentioned: String
  milestone: String
  milestoneNumber: String
  since: DateTime
  states: [IssueState!]
  viewerSubscribed: Boolean
}

union IssueOrPullRequest = Issue | PullRequest

input IssueOrder {
  field: IssueOrderField!
  direction: OrderDirection!
}

enum IssueOrderField {
  CREATED_AT
  UPDATED_AT
  COMMENTS
}

enum IssueState {
  OPEN
  CLOSED
}

enum IssueStateReason {
  REOPENED
  NOT_PLANNED
  COMPLETED
}

type IssueTemplate {
  about: String
  assignees(after: UserConnection!, before: UserConnection!, first: UserConnection!, last: UserConnection!): UserConnection!
  body: String
  filename: String!
  labels(orderBy: LabelConnection, after: LabelConnection, before: LabelConnection, first: LabelConnection, last: LabelConnection): LabelConnection
  name: String!
  title: String
}

type IssueTimelineConnection {
  edges: [IssueTimelineItemEdge]
  nodes: [IssueTimelineItem]
  pageInfo: PageInfo!
  totalCount: Int!
}

union IssueTimelineItem = AssignedEvent | ClosedEvent | Commit | CrossReferencedEvent | DemilestonedEvent | IssueComment | LabeledEvent | LockedEvent | MilestonedEvent | ReferencedEvent | RenamedTitleEvent | ReopenedEvent | SubscribedEvent | TransferredEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnsubscribedEvent | UserBlockedEvent

type IssueTimelineItemEdge {
  cursor: String!
  node: IssueTimelineItem
}

union IssueTimelineItems = AddedToProjectEvent | AssignedEvent | ClosedEvent | CommentDeletedEvent | ConnectedEvent | ConvertedNoteToIssueEvent | ConvertedToDiscussionEvent | CrossReferencedEvent | DemilestonedEvent | DisconnectedEvent | IssueComment | LabeledEvent | LockedEvent | MarkedAsDuplicateEvent | MentionedEvent | MilestonedEvent | MovedColumnsInProjectEvent | PinnedEvent | ReferencedEvent | RemovedFromProjectEvent | RenamedTitleEvent | ReopenedEvent | SubscribedEvent | TransferredEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnmarkedAsDuplicateEvent | UnpinnedEvent | UnsubscribedEvent | UserBlockedEvent

type IssueTimelineItemsConnection {
  edges: [IssueTimelineItemsEdge]
  filteredCount: Int!
  nodes: [IssueTimelineItems]
  pageCount: Int!
  pageInfo: PageInfo!
  totalCount: Int!
  updatedAt: DateTime!
}

type IssueTimelineItemsEdge {
  cursor: String!
  node: IssueTimelineItems
}

enum IssueTimelineItemsItemType {
  ISSUE_COMMENT
  CROSS_REFERENCED_EVENT
  ADDED_TO_PROJECT_EVENT
  ASSIGNED_EVENT
  CLOSED_EVENT
  COMMENT_DELETED_EVENT
  CONNECTED_EVENT
  CONVERTED_NOTE_TO_ISSUE_EVENT
  CONVERTED_TO_DISCUSSION_EVENT
  DEMILESTONED_EVENT
  DISCONNECTED_EVENT
  LABELED_EVENT
  LOCKED_EVENT
  MARKED_AS_DUPLICATE_EVENT
  MENTIONED_EVENT
  MILESTONED_EVENT
  MOVED_COLUMNS_IN_PROJECT_EVENT
  PINNED_EVENT
  REFERENCED_EVENT
  REMOVED_FROM_PROJECT_EVENT
  RENAMED_TITLE_EVENT
  REOPENED_EVENT
  SUBSCRIBED_EVENT
  TRANSFERRED_EVENT
  UNASSIGNED_EVENT
  UNLABELED_EVENT
  UNLOCKED_EVENT
  USER_BLOCKED_EVENT
  UNMARKED_AS_DUPLICATE_EVENT
  UNPINNED_EVENT
  UNSUBSCRIBED_EVENT
}

type JoinedGitHubContribution implements Contribution {
  isRestricted: Boolean!
  occurredAt: DateTime!
  resourcePath: URI!
  url: URI!
  user: User!
}

type Label implements Node {
  color: String!
  createdAt: DateTime
  description: String
  id: ID!
  isDefault: Boolean!
  issues(orderBy: IssueConnection!, labels: IssueConnection!, states: IssueConnection!, filterBy: IssueConnection!, after: IssueConnection!, before: IssueConnection!, first: IssueConnection!, last: IssueConnection!): IssueConnection!
  name: String!
  pullRequests(states: PullRequestConnection!, labels: PullRequestConnection!, headRefName: PullRequestConnection!, baseRefName: PullRequestConnection!, orderBy: PullRequestConnection!, after: PullRequestConnection!, before: PullRequestConnection!, first: PullRequestConnection!, last: PullRequestConnection!): PullRequestConnection!
  repository: Repository!
  resourcePath: URI!
  updatedAt: DateTime
  url: URI!
}

type LabelConnection {
  edges: [LabelEdge]
  nodes: [Label]
  pageInfo: PageInfo!
  totalCount: Int!
}

type LabelEdge {
  cursor: String!
  node: Label
}

input LabelOrder {
  field: LabelOrderField!
  direction: OrderDirection!
}

enum LabelOrderField {
  NAME
  CREATED_AT
}

interface Labelable {
  labels(orderBy: LabelConnection, after: LabelConnection, before: LabelConnection, first: LabelConnection, last: LabelConnection): LabelConnection
}

type LabeledEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  label: Label!
  labelable: Labelable!
}

type Language implements Node {
  color: String
  id: ID!
  name: String!
}

type LanguageConnection {
  edges: [LanguageEdge]
  nodes: [Language]
  pageInfo: PageInfo!
  totalCount: Int!
  totalSize: Int!
}

type LanguageEdge {
  cursor: String!
  node: Language!
  size: Int!
}

input LanguageOrder {
  field: LanguageOrderField!
  direction: OrderDirection!
}

enum LanguageOrderField {
  SIZE
}

type License implements Node {
  body: String!
  conditions: [LicenseRule]!
  description: String
  featured: Boolean!
  hidden: Boolean!
  id: ID!
  implementation: String
  key: String!
  limitations: [LicenseRule]!
  name: String!
  nickname: String
  permissions: [LicenseRule]!
  pseudoLicense: Boolean!
  spdxId: String
  url: URI
}

type LicenseRule {
  description: String!
  key: String!
  label: String!
}

input LinkProjectV2ToRepositoryInput {
  clientMutationId: String
  projectId: ID!
  repositoryId: ID!
}

type LinkProjectV2ToRepositoryPayload {
  clientMutationId: String
  repository: Repository
}

input LinkProjectV2ToTeamInput {
  clientMutationId: String
  projectId: ID!
  teamId: ID!
}

type LinkProjectV2ToTeamPayload {
  clientMutationId: String
  team: Team
}

input LinkRepositoryToProjectInput {
  clientMutationId: String
  projectId: ID!
  repositoryId: ID!
}

type LinkRepositoryToProjectPayload {
  clientMutationId: String
  project: Project
  repository: Repository
}

type LinkedBranch implements Node {
  id: ID!
  ref: Ref
}

type LinkedBranchConnection {
  edges: [LinkedBranchEdge]
  nodes: [LinkedBranch]
  pageInfo: PageInfo!
  totalCount: Int!
}

type LinkedBranchEdge {
  cursor: String!
  node: LinkedBranch
}

input LockLockableInput {
  clientMutationId: String
  lockableId: ID!
  lockReason: LockReason
}

type LockLockablePayload {
  actor: Actor
  clientMutationId: String
  lockedRecord: Lockable
}

enum LockReason {
  OFF_TOPIC
  TOO_HEATED
  RESOLVED
  SPAM
}

interface Lockable {
  activeLockReason: LockReason
  locked: Boolean!
}

type LockedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  lockReason: LockReason
  lockable: Lockable!
}

type Mannequin implements Actor & Node & UniformResourceLocatable {
  avatarUrl(size: URI!): URI!
  claimant: User
  createdAt: DateTime!
  databaseId: Int
  email: String
  id: ID!
  login: String!
  resourcePath: URI!
  updatedAt: DateTime!
  url: URI!
}

type MannequinConnection {
  edges: [MannequinEdge]
  nodes: [Mannequin]
  pageInfo: PageInfo!
  totalCount: Int!
}

type MannequinEdge {
  cursor: String!
  node: Mannequin
}

input MannequinOrder {
  field: MannequinOrderField!
  direction: OrderDirection!
}

enum MannequinOrderField {
  LOGIN
  CREATED_AT
}

input MarkDiscussionCommentAsAnswerInput {
  clientMutationId: String
  id: ID!
}

type MarkDiscussionCommentAsAnswerPayload {
  clientMutationId: String
  discussion: Discussion
}

input MarkFileAsViewedInput {
  clientMutationId: String
  pullRequestId: ID!
  path: String!
}

type MarkFileAsViewedPayload {
  clientMutationId: String
  pullRequest: PullRequest
}

input MarkNotificationAsDoneInput {
  clientMutationId: String
  id: ID!
}

type MarkNotificationAsDonePayload {
  clientMutationId: String
  success: Boolean
  viewer: User
}

input MarkProjectV2AsTemplateInput {
  clientMutationId: String
  projectId: ID!
}

type MarkProjectV2AsTemplatePayload {
  clientMutationId: String
  projectV2: ProjectV2
}

input MarkPullRequestReadyForReviewInput {
  clientMutationId: String
  pullRequestId: ID!
}

type MarkPullRequestReadyForReviewPayload {
  clientMutationId: String
  pullRequest: PullRequest
}

type MarkedAsDuplicateEvent implements Node {
  actor: Actor
  canonical: IssueOrPullRequest
  createdAt: DateTime!
  duplicate: IssueOrPullRequest
  id: ID!
  isCrossRepository: Boolean!
}

type MarketplaceCategory implements Node {
  description: String
  howItWorks: String
  id: ID!
  name: String!
  primaryListingCount: Int!
  resourcePath: URI!
  secondaryListingCount: Int!
  slug: String!
  url: URI!
}

type MarketplaceListing implements Node {
  app: App
  companyUrl: URI
  configurationResourcePath: URI!
  configurationUrl: URI!
  documentationUrl: URI
  extendedDescription: String
  extendedDescriptionHTML: HTML!
  fullDescription: String!
  fullDescriptionHTML: HTML!
  hasPublishedFreeTrialPlans: Boolean!
  hasTermsOfService: Boolean!
  hasVerifiedOwner: Boolean!
  howItWorks: String
  howItWorksHTML: HTML!
  id: ID!
  installationUrl: URI
  installedForViewer: Boolean!
  isArchived: Boolean!
  isDraft: Boolean!
  isPaid: Boolean!
  isPublic: Boolean!
  isRejected: Boolean!
  isUnverified: Boolean!
  isUnverifiedPending: Boolean!
  isVerificationPendingFromDraft: Boolean!
  isVerificationPendingFromUnverified: Boolean!
  isVerified: Boolean!
  logoBackgroundColor: String!
  logoUrl(size: URI): URI
  name: String!
  normalizedShortDescription: String!
  pricingUrl: URI
  primaryCategory: MarketplaceCategory!
  privacyPolicyUrl: URI!
  resourcePath: URI!
  screenshotUrls: [String]!
  secondaryCategory: MarketplaceCategory
  shortDescription: String!
  slug: String!
  statusUrl: URI
  supportEmail: String
  supportUrl: URI!
  termsOfServiceUrl: URI
  url: URI!
  viewerCanAddPlans: Boolean!
  viewerCanApprove: Boolean!
  viewerCanDelist: Boolean!
  viewerCanEdit: Boolean!
  viewerCanEditCategories: Boolean!
  viewerCanEditPlans: Boolean!
  viewerCanRedraft: Boolean!
  viewerCanReject: Boolean!
  viewerCanRequestApproval: Boolean!
  viewerHasPurchased: Boolean!
  viewerHasPurchasedForAllOrganizations: Boolean!
  viewerIsListingAdmin: Boolean!
}

type MarketplaceListingConnection {
  edges: [MarketplaceListingEdge]
  nodes: [MarketplaceListing]
  pageInfo: PageInfo!
  totalCount: Int!
}

type MarketplaceListingEdge {
  cursor: String!
  node: MarketplaceListing
}

type MaxFilePathLengthParameters {
  maxFilePathLength: Int!
}

input MaxFilePathLengthParametersInput {
  maxFilePathLength: Int!
}

type MaxFileSizeParameters {
  maxFileSize: Int!
}

input MaxFileSizeParametersInput {
  maxFileSize: Int!
}

type MemberFeatureRequestNotification implements Node {
  body: String!
  id: ID!
  title: String!
  updatedAt: DateTime!
}

interface MemberStatusable {
  memberStatuses(after: UserStatusConnection!, before: UserStatusConnection!, first: UserStatusConnection!, last: UserStatusConnection!, orderBy: UserStatusConnection!): UserStatusConnection!
}

type MembersCanDeleteReposClearAuditEntry implements AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  enterpriseResourcePath: URI
  enterpriseSlug: String
  enterpriseUrl: URI
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type MembersCanDeleteReposDisableAuditEntry implements AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  enterpriseResourcePath: URI
  enterpriseSlug: String
  enterpriseUrl: URI
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type MembersCanDeleteReposEnableAuditEntry implements AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  enterpriseResourcePath: URI
  enterpriseSlug: String
  enterpriseUrl: URI
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type MentionedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  databaseId: Int
  id: ID!
}

input MergeBranchInput {
  clientMutationId: String
  repositoryId: ID!
  base: String!
  head: String!
  commitMessage: String
  authorEmail: String
}

type MergeBranchPayload {
  clientMutationId: String
  mergeCommit: Commit
}

enum MergeCommitMessage {
  PR_TITLE
  PR_BODY
  BLANK
}

enum MergeCommitTitle {
  PR_TITLE
  MERGE_MESSAGE
}

input MergePullRequestInput {
  clientMutationId: String
  pullRequestId: ID!
  commitHeadline: String
  commitBody: String
  expectedHeadOid: GitObjectID
  mergeMethod: PullRequestMergeMethod
  authorEmail: String
}

type MergePullRequestPayload {
  actor: Actor
  clientMutationId: String
  pullRequest: PullRequest
}

type MergeQueue implements Node {
  configuration: MergeQueueConfiguration
  entries(after: MergeQueueEntryConnection, before: MergeQueueEntryConnection, first: MergeQueueEntryConnection, last: MergeQueueEntryConnection): MergeQueueEntryConnection
  id: ID!
  nextEntryEstimatedTimeToMerge: Int
  repository: Repository
  resourcePath: URI!
  url: URI!
}

type MergeQueueConfiguration {
  checkResponseTimeout: Int
  maximumEntriesToBuild: Int
  maximumEntriesToMerge: Int
  mergeMethod: PullRequestMergeMethod
  mergingStrategy: MergeQueueMergingStrategy
  minimumEntriesToMerge: Int
  minimumEntriesToMergeWaitTime: Int
}

type MergeQueueEntry implements Node {
  baseCommit: Commit
  enqueuedAt: DateTime!
  enqueuer: Actor!
  estimatedTimeToMerge: Int
  headCommit: Commit
  id: ID!
  jump: Boolean!
  mergeQueue: MergeQueue
  position: Int!
  pullRequest: PullRequest
  solo: Boolean!
  state: MergeQueueEntryState!
}

type MergeQueueEntryConnection {
  edges: [MergeQueueEntryEdge]
  nodes: [MergeQueueEntry]
  pageInfo: PageInfo!
  totalCount: Int!
}

type MergeQueueEntryEdge {
  cursor: String!
  node: MergeQueueEntry
}

enum MergeQueueEntryState {
  QUEUED
  AWAITING_CHECKS
  MERGEABLE
  UNMERGEABLE
  LOCKED
}

enum MergeQueueMergingStrategy {
  ALLGREEN
  HEADGREEN
}

enum MergeStateStatus {
  DIRTY
  UNKNOWN
  BLOCKED
  BEHIND
  DRAFT
  UNSTABLE
  HAS_HOOKS
  CLEAN
}

enum MergeableState {
  MERGEABLE
  CONFLICTING
  UNKNOWN
}

type MergedEvent implements Node & UniformResourceLocatable {
  actor: Actor
  commit: Commit
  createdAt: DateTime!
  id: ID!
  mergeRef: Ref
  mergeRefName: String!
  pullRequest: PullRequest!
  resourcePath: URI!
  url: URI!
}

interface Migration {
  continueOnError: Boolean!
  createdAt: DateTime!
  databaseId: String
  failureReason: String
  id: ID!
  migrationLogUrl: URI
  migrationSource: MigrationSource!
  repositoryName: String!
  sourceUrl: URI!
  state: MigrationState!
  warningsCount: Int!
}

type MigrationSource implements Node {
  id: ID!
  name: String!
  type: MigrationSourceType!
  url: URI!
}

enum MigrationSourceType {
  AZURE_DEVOPS
  BITBUCKET_SERVER
  GITHUB_ARCHIVE
}

enum MigrationState {
  NOT_STARTED
  QUEUED
  IN_PROGRESS
  SUCCEEDED
  FAILED
  PENDING_VALIDATION
  FAILED_VALIDATION
}

type Milestone implements Closable & Node & UniformResourceLocatable {
  closed: Boolean!
  closedAt: DateTime
  createdAt: DateTime!
  creator: Actor
  description: String
  dueOn: DateTime
  id: ID!
  issues(orderBy: IssueConnection!, labels: IssueConnection!, states: IssueConnection!, filterBy: IssueConnection!, after: IssueConnection!, before: IssueConnection!, first: IssueConnection!, last: IssueConnection!): IssueConnection!
  number: Int!
  progressPercentage: Float!
  pullRequests(states: PullRequestConnection!, labels: PullRequestConnection!, headRefName: PullRequestConnection!, baseRefName: PullRequestConnection!, orderBy: PullRequestConnection!, after: PullRequestConnection!, before: PullRequestConnection!, first: PullRequestConnection!, last: PullRequestConnection!): PullRequestConnection!
  repository: Repository!
  resourcePath: URI!
  state: MilestoneState!
  title: String!
  updatedAt: DateTime!
  url: URI!
  viewerCanClose: Boolean!
  viewerCanReopen: Boolean!
}

type MilestoneConnection {
  edges: [MilestoneEdge]
  nodes: [Milestone]
  pageInfo: PageInfo!
  totalCount: Int!
}

type MilestoneEdge {
  cursor: String!
  node: Milestone
}

union MilestoneItem = Issue | PullRequest

input MilestoneOrder {
  field: MilestoneOrderField!
  direction: OrderDirection!
}

enum MilestoneOrderField {
  DUE_DATE
  CREATED_AT
  UPDATED_AT
  NUMBER
}

enum MilestoneState {
  OPEN
  CLOSED
}

type MilestonedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  milestoneTitle: String!
  subject: MilestoneItem!
}

interface Minimizable {
  isMinimized: Boolean!
  minimizedReason: String
  viewerCanMinimize: Boolean!
}

input MinimizeCommentInput {
  clientMutationId: String
  subjectId: ID!
  classifier: ReportedContentClassifiers!
}

type MinimizeCommentPayload {
  clientMutationId: String
  minimizedComment: Minimizable
}

input MoveProjectCardInput {
  clientMutationId: String
  cardId: ID!
  columnId: ID!
  afterCardId: ID
}

type MoveProjectCardPayload {
  cardEdge: ProjectCardEdge
  clientMutationId: String
}

input MoveProjectColumnInput {
  clientMutationId: String
  columnId: ID!
  afterColumnId: ID
}

type MoveProjectColumnPayload {
  clientMutationId: String
  columnEdge: ProjectColumnEdge
}

type MovedColumnsInProjectEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  databaseId: Int
  id: ID!
  previousProjectColumnName: String!
  project: Project
  projectCard: ProjectCard
  projectColumnName: String!
}

type Mutation {
  abortQueuedMigrations(input: AbortQueuedMigrationsPayload): AbortQueuedMigrationsPayload
  abortRepositoryMigration(input: AbortRepositoryMigrationPayload): AbortRepositoryMigrationPayload
  acceptEnterpriseAdministratorInvitation(input: AcceptEnterpriseAdministratorInvitationPayload): AcceptEnterpriseAdministratorInvitationPayload
  acceptTopicSuggestion(input: AcceptTopicSuggestionPayload): AcceptTopicSuggestionPayload
  addAssigneesToAssignable(input: AddAssigneesToAssignablePayload): AddAssigneesToAssignablePayload
  addComment(input: AddCommentPayload): AddCommentPayload
  addDiscussionComment(input: AddDiscussionCommentPayload): AddDiscussionCommentPayload
  addDiscussionPollVote(input: AddDiscussionPollVotePayload): AddDiscussionPollVotePayload
  addEnterpriseOrganizationMember(input: AddEnterpriseOrganizationMemberPayload): AddEnterpriseOrganizationMemberPayload
  addEnterpriseSupportEntitlement(input: AddEnterpriseSupportEntitlementPayload): AddEnterpriseSupportEntitlementPayload
  addLabelsToLabelable(input: AddLabelsToLabelablePayload): AddLabelsToLabelablePayload
  addProjectCard(input: AddProjectCardPayload): AddProjectCardPayload
  addProjectColumn(input: AddProjectColumnPayload): AddProjectColumnPayload
  addProjectV2DraftIssue(input: AddProjectV2DraftIssuePayload): AddProjectV2DraftIssuePayload
  addProjectV2ItemById(input: AddProjectV2ItemByIdPayload): AddProjectV2ItemByIdPayload
  addPullRequestReview(input: AddPullRequestReviewPayload): AddPullRequestReviewPayload
  addPullRequestReviewComment(input: AddPullRequestReviewCommentPayload): AddPullRequestReviewCommentPayload
  addPullRequestReviewThread(input: AddPullRequestReviewThreadPayload): AddPullRequestReviewThreadPayload
  addPullRequestReviewThreadReply(input: AddPullRequestReviewThreadReplyPayload): AddPullRequestReviewThreadReplyPayload
  addReaction(input: AddReactionPayload): AddReactionPayload
  addStar(input: AddStarPayload): AddStarPayload
  addUpvote(input: AddUpvotePayload): AddUpvotePayload
  addVerifiableDomain(input: AddVerifiableDomainPayload): AddVerifiableDomainPayload
  approveDeployments(input: ApproveDeploymentsPayload): ApproveDeploymentsPayload
  approveVerifiableDomain(input: ApproveVerifiableDomainPayload): ApproveVerifiableDomainPayload
  archiveProjectV2Item(input: ArchiveProjectV2ItemPayload): ArchiveProjectV2ItemPayload
  archiveRepository(input: ArchiveRepositoryPayload): ArchiveRepositoryPayload
  cancelEnterpriseAdminInvitation(input: CancelEnterpriseAdminInvitationPayload): CancelEnterpriseAdminInvitationPayload
  cancelSponsorship(input: CancelSponsorshipPayload): CancelSponsorshipPayload
  changeUserStatus(input: ChangeUserStatusPayload): ChangeUserStatusPayload
  clearLabelsFromLabelable(input: ClearLabelsFromLabelablePayload): ClearLabelsFromLabelablePayload
  clearProjectV2ItemFieldValue(input: ClearProjectV2ItemFieldValuePayload): ClearProjectV2ItemFieldValuePayload
  cloneProject(input: CloneProjectPayload): CloneProjectPayload
  cloneTemplateRepository(input: CloneTemplateRepositoryPayload): CloneTemplateRepositoryPayload
  closeDiscussion(input: CloseDiscussionPayload): CloseDiscussionPayload
  closeIssue(input: CloseIssuePayload): CloseIssuePayload
  closePullRequest(input: ClosePullRequestPayload): ClosePullRequestPayload
  convertProjectCardNoteToIssue(input: ConvertProjectCardNoteToIssuePayload): ConvertProjectCardNoteToIssuePayload
  convertPullRequestToDraft(input: ConvertPullRequestToDraftPayload): ConvertPullRequestToDraftPayload
  copyProjectV2(input: CopyProjectV2Payload): CopyProjectV2Payload
  createAttributionInvitation(input: CreateAttributionInvitationPayload): CreateAttributionInvitationPayload
  createBranchProtectionRule(input: CreateBranchProtectionRulePayload): CreateBranchProtectionRulePayload
  createCheckRun(input: CreateCheckRunPayload): CreateCheckRunPayload
  createCheckSuite(input: CreateCheckSuitePayload): CreateCheckSuitePayload
  createCommitOnBranch(input: CreateCommitOnBranchPayload): CreateCommitOnBranchPayload
  createDeployment(input: CreateDeploymentPayload): CreateDeploymentPayload
  createDeploymentStatus(input: CreateDeploymentStatusPayload): CreateDeploymentStatusPayload
  createDiscussion(input: CreateDiscussionPayload): CreateDiscussionPayload
  createEnterpriseOrganization(input: CreateEnterpriseOrganizationPayload): CreateEnterpriseOrganizationPayload
  createEnvironment(input: CreateEnvironmentPayload): CreateEnvironmentPayload
  createIpAllowListEntry(input: CreateIpAllowListEntryPayload): CreateIpAllowListEntryPayload
  createIssue(input: CreateIssuePayload): CreateIssuePayload
  createLabel(input: CreateLabelPayload): CreateLabelPayload
  createLinkedBranch(input: CreateLinkedBranchPayload): CreateLinkedBranchPayload
  createMigrationSource(input: CreateMigrationSourcePayload): CreateMigrationSourcePayload
  createProject(input: CreateProjectPayload): CreateProjectPayload
  createProjectV2(input: CreateProjectV2Payload): CreateProjectV2Payload
  createProjectV2Field(input: CreateProjectV2FieldPayload): CreateProjectV2FieldPayload
  createPullRequest(input: CreatePullRequestPayload): CreatePullRequestPayload
  createRef(input: CreateRefPayload): CreateRefPayload
  createRepository(input: CreateRepositoryPayload): CreateRepositoryPayload
  createRepositoryRuleset(input: CreateRepositoryRulesetPayload): CreateRepositoryRulesetPayload
  createSponsorsListing(input: CreateSponsorsListingPayload): CreateSponsorsListingPayload
  createSponsorsTier(input: CreateSponsorsTierPayload): CreateSponsorsTierPayload
  createSponsorship(input: CreateSponsorshipPayload): CreateSponsorshipPayload
  createSponsorships(input: CreateSponsorshipsPayload): CreateSponsorshipsPayload
  createTeamDiscussion(input: CreateTeamDiscussionPayload): CreateTeamDiscussionPayload
  createTeamDiscussionComment(input: CreateTeamDiscussionCommentPayload): CreateTeamDiscussionCommentPayload
  createUserList(input: CreateUserListPayload): CreateUserListPayload
  declineTopicSuggestion(input: DeclineTopicSuggestionPayload): DeclineTopicSuggestionPayload
  deleteBranchProtectionRule(input: DeleteBranchProtectionRulePayload): DeleteBranchProtectionRulePayload
  deleteDeployment(input: DeleteDeploymentPayload): DeleteDeploymentPayload
  deleteDiscussion(input: DeleteDiscussionPayload): DeleteDiscussionPayload
  deleteDiscussionComment(input: DeleteDiscussionCommentPayload): DeleteDiscussionCommentPayload
  deleteEnvironment(input: DeleteEnvironmentPayload): DeleteEnvironmentPayload
  deleteIpAllowListEntry(input: DeleteIpAllowListEntryPayload): DeleteIpAllowListEntryPayload
  deleteIssue(input: DeleteIssuePayload): DeleteIssuePayload
  deleteIssueComment(input: DeleteIssueCommentPayload): DeleteIssueCommentPayload
  deleteLabel(input: DeleteLabelPayload): DeleteLabelPayload
  deleteLinkedBranch(input: DeleteLinkedBranchPayload): DeleteLinkedBranchPayload
  deletePackageVersion(input: DeletePackageVersionPayload): DeletePackageVersionPayload
  deleteProject(input: DeleteProjectPayload): DeleteProjectPayload
  deleteProjectCard(input: DeleteProjectCardPayload): DeleteProjectCardPayload
  deleteProjectColumn(input: DeleteProjectColumnPayload): DeleteProjectColumnPayload
  deleteProjectV2(input: DeleteProjectV2Payload): DeleteProjectV2Payload
  deleteProjectV2Field(input: DeleteProjectV2FieldPayload): DeleteProjectV2FieldPayload
  deleteProjectV2Item(input: DeleteProjectV2ItemPayload): DeleteProjectV2ItemPayload
  deleteProjectV2Workflow(input: DeleteProjectV2WorkflowPayload): DeleteProjectV2WorkflowPayload
  deletePullRequestReview(input: DeletePullRequestReviewPayload): DeletePullRequestReviewPayload
  deletePullRequestReviewComment(input: DeletePullRequestReviewCommentPayload): DeletePullRequestReviewCommentPayload
  deleteRef(input: DeleteRefPayload): DeleteRefPayload
  deleteRepositoryRuleset(input: DeleteRepositoryRulesetPayload): DeleteRepositoryRulesetPayload
  deleteTeamDiscussion(input: DeleteTeamDiscussionPayload): DeleteTeamDiscussionPayload
  deleteTeamDiscussionComment(input: DeleteTeamDiscussionCommentPayload): DeleteTeamDiscussionCommentPayload
  deleteUserList(input: DeleteUserListPayload): DeleteUserListPayload
  deleteVerifiableDomain(input: DeleteVerifiableDomainPayload): DeleteVerifiableDomainPayload
  dequeuePullRequest(input: DequeuePullRequestPayload): DequeuePullRequestPayload
  disablePullRequestAutoMerge(input: DisablePullRequestAutoMergePayload): DisablePullRequestAutoMergePayload
  dismissPullRequestReview(input: DismissPullRequestReviewPayload): DismissPullRequestReviewPayload
  dismissRepositoryVulnerabilityAlert(input: DismissRepositoryVulnerabilityAlertPayload): DismissRepositoryVulnerabilityAlertPayload
  enablePullRequestAutoMerge(input: EnablePullRequestAutoMergePayload): EnablePullRequestAutoMergePayload
  enqueuePullRequest(input: EnqueuePullRequestPayload): EnqueuePullRequestPayload
  followOrganization(input: FollowOrganizationPayload): FollowOrganizationPayload
  followUser(input: FollowUserPayload): FollowUserPayload
  grantEnterpriseOrganizationsMigratorRole(input: GrantEnterpriseOrganizationsMigratorRolePayload): GrantEnterpriseOrganizationsMigratorRolePayload
  grantMigratorRole(input: GrantMigratorRolePayload): GrantMigratorRolePayload
  importProject(input: ImportProjectPayload): ImportProjectPayload
  inviteEnterpriseAdmin(input: InviteEnterpriseAdminPayload): InviteEnterpriseAdminPayload
  linkProjectV2ToRepository(input: LinkProjectV2ToRepositoryPayload): LinkProjectV2ToRepositoryPayload
  linkProjectV2ToTeam(input: LinkProjectV2ToTeamPayload): LinkProjectV2ToTeamPayload
  linkRepositoryToProject(input: LinkRepositoryToProjectPayload): LinkRepositoryToProjectPayload
  lockLockable(input: LockLockablePayload): LockLockablePayload
  markDiscussionCommentAsAnswer(input: MarkDiscussionCommentAsAnswerPayload): MarkDiscussionCommentAsAnswerPayload
  markFileAsViewed(input: MarkFileAsViewedPayload): MarkFileAsViewedPayload
  markNotificationAsDone(input: MarkNotificationAsDonePayload): MarkNotificationAsDonePayload
  markProjectV2AsTemplate(input: MarkProjectV2AsTemplatePayload): MarkProjectV2AsTemplatePayload
  markPullRequestReadyForReview(input: MarkPullRequestReadyForReviewPayload): MarkPullRequestReadyForReviewPayload
  mergeBranch(input: MergeBranchPayload): MergeBranchPayload
  mergePullRequest(input: MergePullRequestPayload): MergePullRequestPayload
  minimizeComment(input: MinimizeCommentPayload): MinimizeCommentPayload
  moveProjectCard(input: MoveProjectCardPayload): MoveProjectCardPayload
  moveProjectColumn(input: MoveProjectColumnPayload): MoveProjectColumnPayload
  pinEnvironment(input: PinEnvironmentPayload): PinEnvironmentPayload
  pinIssue(input: PinIssuePayload): PinIssuePayload
  publishSponsorsTier(input: PublishSponsorsTierPayload): PublishSponsorsTierPayload
  regenerateEnterpriseIdentityProviderRecoveryCodes(input: RegenerateEnterpriseIdentityProviderRecoveryCodesPayload): RegenerateEnterpriseIdentityProviderRecoveryCodesPayload
  regenerateVerifiableDomainToken(input: RegenerateVerifiableDomainTokenPayload): RegenerateVerifiableDomainTokenPayload
  rejectDeployments(input: RejectDeploymentsPayload): RejectDeploymentsPayload
  removeAssigneesFromAssignable(input: RemoveAssigneesFromAssignablePayload): RemoveAssigneesFromAssignablePayload
  removeEnterpriseAdmin(input: RemoveEnterpriseAdminPayload): RemoveEnterpriseAdminPayload
  removeEnterpriseIdentityProvider(input: RemoveEnterpriseIdentityProviderPayload): RemoveEnterpriseIdentityProviderPayload
  removeEnterpriseMember(input: RemoveEnterpriseMemberPayload): RemoveEnterpriseMemberPayload
  removeEnterpriseOrganization(input: RemoveEnterpriseOrganizationPayload): RemoveEnterpriseOrganizationPayload
  removeEnterpriseSupportEntitlement(input: RemoveEnterpriseSupportEntitlementPayload): RemoveEnterpriseSupportEntitlementPayload
  removeLabelsFromLabelable(input: RemoveLabelsFromLabelablePayload): RemoveLabelsFromLabelablePayload
  removeOutsideCollaborator(input: RemoveOutsideCollaboratorPayload): RemoveOutsideCollaboratorPayload
  removeReaction(input: RemoveReactionPayload): RemoveReactionPayload
  removeStar(input: RemoveStarPayload): RemoveStarPayload
  removeUpvote(input: RemoveUpvotePayload): RemoveUpvotePayload
  reopenDiscussion(input: ReopenDiscussionPayload): ReopenDiscussionPayload
  reopenIssue(input: ReopenIssuePayload): ReopenIssuePayload
  reopenPullRequest(input: ReopenPullRequestPayload): ReopenPullRequestPayload
  reorderEnvironment(input: ReorderEnvironmentPayload): ReorderEnvironmentPayload
  requestReviews(input: RequestReviewsPayload): RequestReviewsPayload
  rerequestCheckSuite(input: RerequestCheckSuitePayload): RerequestCheckSuitePayload
  resolveReviewThread(input: ResolveReviewThreadPayload): ResolveReviewThreadPayload
  retireSponsorsTier(input: RetireSponsorsTierPayload): RetireSponsorsTierPayload
  revertPullRequest(input: RevertPullRequestPayload): RevertPullRequestPayload
  revokeEnterpriseOrganizationsMigratorRole(input: RevokeEnterpriseOrganizationsMigratorRolePayload): RevokeEnterpriseOrganizationsMigratorRolePayload
  revokeMigratorRole(input: RevokeMigratorRolePayload): RevokeMigratorRolePayload
  setEnterpriseIdentityProvider(input: SetEnterpriseIdentityProviderPayload): SetEnterpriseIdentityProviderPayload
  setOrganizationInteractionLimit(input: SetOrganizationInteractionLimitPayload): SetOrganizationInteractionLimitPayload
  setRepositoryInteractionLimit(input: SetRepositoryInteractionLimitPayload): SetRepositoryInteractionLimitPayload
  setUserInteractionLimit(input: SetUserInteractionLimitPayload): SetUserInteractionLimitPayload
  startOrganizationMigration(input: StartOrganizationMigrationPayload): StartOrganizationMigrationPayload
  startRepositoryMigration(input: StartRepositoryMigrationPayload): StartRepositoryMigrationPayload
  submitPullRequestReview(input: SubmitPullRequestReviewPayload): SubmitPullRequestReviewPayload
  transferEnterpriseOrganization(input: TransferEnterpriseOrganizationPayload): TransferEnterpriseOrganizationPayload
  transferIssue(input: TransferIssuePayload): TransferIssuePayload
  unarchiveProjectV2Item(input: UnarchiveProjectV2ItemPayload): UnarchiveProjectV2ItemPayload
  unarchiveRepository(input: UnarchiveRepositoryPayload): UnarchiveRepositoryPayload
  unfollowOrganization(input: UnfollowOrganizationPayload): UnfollowOrganizationPayload
  unfollowUser(input: UnfollowUserPayload): UnfollowUserPayload
  unlinkProjectV2FromRepository(input: UnlinkProjectV2FromRepositoryPayload): UnlinkProjectV2FromRepositoryPayload
  unlinkProjectV2FromTeam(input: UnlinkProjectV2FromTeamPayload): UnlinkProjectV2FromTeamPayload
  unlinkRepositoryFromProject(input: UnlinkRepositoryFromProjectPayload): UnlinkRepositoryFromProjectPayload
  unlockLockable(input: UnlockLockablePayload): UnlockLockablePayload
  unmarkDiscussionCommentAsAnswer(input: UnmarkDiscussionCommentAsAnswerPayload): UnmarkDiscussionCommentAsAnswerPayload
  unmarkFileAsViewed(input: UnmarkFileAsViewedPayload): UnmarkFileAsViewedPayload
  unmarkIssueAsDuplicate(input: UnmarkIssueAsDuplicatePayload): UnmarkIssueAsDuplicatePayload
  unmarkProjectV2AsTemplate(input: UnmarkProjectV2AsTemplatePayload): UnmarkProjectV2AsTemplatePayload
  unminimizeComment(input: UnminimizeCommentPayload): UnminimizeCommentPayload
  unpinIssue(input: UnpinIssuePayload): UnpinIssuePayload
  unresolveReviewThread(input: UnresolveReviewThreadPayload): UnresolveReviewThreadPayload
  unsubscribeFromNotifications(input: UnsubscribeFromNotificationsPayload): UnsubscribeFromNotificationsPayload
  updateBranchProtectionRule(input: UpdateBranchProtectionRulePayload): UpdateBranchProtectionRulePayload
  updateCheckRun(input: UpdateCheckRunPayload): UpdateCheckRunPayload
  updateCheckSuitePreferences(input: UpdateCheckSuitePreferencesPayload): UpdateCheckSuitePreferencesPayload
  updateDiscussion(input: UpdateDiscussionPayload): UpdateDiscussionPayload
  updateDiscussionComment(input: UpdateDiscussionCommentPayload): UpdateDiscussionCommentPayload
  updateEnterpriseAdministratorRole(input: UpdateEnterpriseAdministratorRolePayload): UpdateEnterpriseAdministratorRolePayload
  updateEnterpriseAllowPrivateRepositoryForkingSetting(input: UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload): UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload
  updateEnterpriseDefaultRepositoryPermissionSetting(input: UpdateEnterpriseDefaultRepositoryPermissionSettingPayload): UpdateEnterpriseDefaultRepositoryPermissionSettingPayload
  updateEnterpriseMembersCanChangeRepositoryVisibilitySetting(input: UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload): UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload
  updateEnterpriseMembersCanCreateRepositoriesSetting(input: UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload): UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload
  updateEnterpriseMembersCanDeleteIssuesSetting(input: UpdateEnterpriseMembersCanDeleteIssuesSettingPayload): UpdateEnterpriseMembersCanDeleteIssuesSettingPayload
  updateEnterpriseMembersCanDeleteRepositoriesSetting(input: UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload): UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload
  updateEnterpriseMembersCanInviteCollaboratorsSetting(input: UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload): UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload
  updateEnterpriseMembersCanMakePurchasesSetting(input: UpdateEnterpriseMembersCanMakePurchasesSettingPayload): UpdateEnterpriseMembersCanMakePurchasesSettingPayload
  updateEnterpriseMembersCanUpdateProtectedBranchesSetting(input: UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload): UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload
  updateEnterpriseMembersCanViewDependencyInsightsSetting(input: UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload): UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload
  updateEnterpriseOrganizationProjectsSetting(input: UpdateEnterpriseOrganizationProjectsSettingPayload): UpdateEnterpriseOrganizationProjectsSettingPayload
  updateEnterpriseOwnerOrganizationRole(input: UpdateEnterpriseOwnerOrganizationRolePayload): UpdateEnterpriseOwnerOrganizationRolePayload
  updateEnterpriseProfile(input: UpdateEnterpriseProfilePayload): UpdateEnterpriseProfilePayload
  updateEnterpriseRepositoryProjectsSetting(input: UpdateEnterpriseRepositoryProjectsSettingPayload): UpdateEnterpriseRepositoryProjectsSettingPayload
  updateEnterpriseTeamDiscussionsSetting(input: UpdateEnterpriseTeamDiscussionsSettingPayload): UpdateEnterpriseTeamDiscussionsSettingPayload
  updateEnterpriseTwoFactorAuthenticationRequiredSetting(input: UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload): UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload
  updateEnvironment(input: UpdateEnvironmentPayload): UpdateEnvironmentPayload
  updateIpAllowListEnabledSetting(input: UpdateIpAllowListEnabledSettingPayload): UpdateIpAllowListEnabledSettingPayload
  updateIpAllowListEntry(input: UpdateIpAllowListEntryPayload): UpdateIpAllowListEntryPayload
  updateIpAllowListForInstalledAppsEnabledSetting(input: UpdateIpAllowListForInstalledAppsEnabledSettingPayload): UpdateIpAllowListForInstalledAppsEnabledSettingPayload
  updateIssue(input: UpdateIssuePayload): UpdateIssuePayload
  updateIssueComment(input: UpdateIssueCommentPayload): UpdateIssueCommentPayload
  updateLabel(input: UpdateLabelPayload): UpdateLabelPayload
  updateNotificationRestrictionSetting(input: UpdateNotificationRestrictionSettingPayload): UpdateNotificationRestrictionSettingPayload
  updateOrganizationAllowPrivateRepositoryForkingSetting(input: UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload): UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload
  updateOrganizationWebCommitSignoffSetting(input: UpdateOrganizationWebCommitSignoffSettingPayload): UpdateOrganizationWebCommitSignoffSettingPayload
  updatePatreonSponsorability(input: UpdatePatreonSponsorabilityPayload): UpdatePatreonSponsorabilityPayload
  updateProject(input: UpdateProjectPayload): UpdateProjectPayload
  updateProjectCard(input: UpdateProjectCardPayload): UpdateProjectCardPayload
  updateProjectColumn(input: UpdateProjectColumnPayload): UpdateProjectColumnPayload
  updateProjectV2(input: UpdateProjectV2Payload): UpdateProjectV2Payload
  updateProjectV2Collaborators(input: UpdateProjectV2CollaboratorsPayload): UpdateProjectV2CollaboratorsPayload
  updateProjectV2DraftIssue(input: UpdateProjectV2DraftIssuePayload): UpdateProjectV2DraftIssuePayload
  updateProjectV2ItemFieldValue(input: UpdateProjectV2ItemFieldValuePayload): UpdateProjectV2ItemFieldValuePayload
  updateProjectV2ItemPosition(input: UpdateProjectV2ItemPositionPayload): UpdateProjectV2ItemPositionPayload
  updatePullRequest(input: UpdatePullRequestPayload): UpdatePullRequestPayload
  updatePullRequestBranch(input: UpdatePullRequestBranchPayload): UpdatePullRequestBranchPayload
  updatePullRequestReview(input: UpdatePullRequestReviewPayload): UpdatePullRequestReviewPayload
  updatePullRequestReviewComment(input: UpdatePullRequestReviewCommentPayload): UpdatePullRequestReviewCommentPayload
  updateRef(input: UpdateRefPayload): UpdateRefPayload
  updateRefs(input: UpdateRefsPayload): UpdateRefsPayload
  updateRepository(input: UpdateRepositoryPayload): UpdateRepositoryPayload
  updateRepositoryRuleset(input: UpdateRepositoryRulesetPayload): UpdateRepositoryRulesetPayload
  updateRepositoryWebCommitSignoffSetting(input: UpdateRepositoryWebCommitSignoffSettingPayload): UpdateRepositoryWebCommitSignoffSettingPayload
  updateSponsorshipPreferences(input: UpdateSponsorshipPreferencesPayload): UpdateSponsorshipPreferencesPayload
  updateSubscription(input: UpdateSubscriptionPayload): UpdateSubscriptionPayload
  updateTeamDiscussion(input: UpdateTeamDiscussionPayload): UpdateTeamDiscussionPayload
  updateTeamDiscussionComment(input: UpdateTeamDiscussionCommentPayload): UpdateTeamDiscussionCommentPayload
  updateTeamReviewAssignment(input: UpdateTeamReviewAssignmentPayload): UpdateTeamReviewAssignmentPayload
  updateTeamsRepository(input: UpdateTeamsRepositoryPayload): UpdateTeamsRepositoryPayload
  updateTopics(input: UpdateTopicsPayload): UpdateTopicsPayload
  updateUserList(input: UpdateUserListPayload): UpdateUserListPayload
  updateUserListsForItem(input: UpdateUserListsForItemPayload): UpdateUserListsForItemPayload
  verifyVerifiableDomain(input: VerifyVerifiableDomainPayload): VerifyVerifiableDomainPayload
}

interface Node {
  id: ID!
}

enum NotificationRestrictionSettingValue {
  ENABLED
  DISABLED
}

type OIDCProvider implements Node {
  enterprise: Enterprise
  externalIdentities(membersOnly: ExternalIdentityConnection!, login: ExternalIdentityConnection!, userName: ExternalIdentityConnection!, after: ExternalIdentityConnection!, before: ExternalIdentityConnection!, first: ExternalIdentityConnection!, last: ExternalIdentityConnection!): ExternalIdentityConnection!
  id: ID!
  providerType: OIDCProviderType!
  tenantId: String!
}

enum OIDCProviderType {
  AAD
}

interface OauthApplicationAuditEntryData {
  oauthApplicationName: String
  oauthApplicationResourcePath: URI
  oauthApplicationUrl: URI
}

type OauthApplicationCreateAuditEntry implements AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  applicationUrl: URI
  callbackUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  oauthApplicationName: String
  oauthApplicationResourcePath: URI
  oauthApplicationUrl: URI
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  rateLimit: Int
  state: OauthApplicationCreateAuditEntryState
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

enum OauthApplicationCreateAuditEntryState {
  ACTIVE
  SUSPENDED
  PENDING_DELETION
}

enum OperationType {
  ACCESS
  AUTHENTICATION
  CREATE
  MODIFY
  REMOVE
  RESTORE
  TRANSFER
}

enum OrderDirection {
  ASC
  DESC
}

type OrgAddBillingManagerAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  invitationEmail: String
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type OrgAddMemberAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  permission: OrgAddMemberAuditEntryPermission
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

enum OrgAddMemberAuditEntryPermission {
  READ
  ADMIN
}

type OrgBlockUserAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  blockedUser: User
  blockedUserName: String
  blockedUserResourcePath: URI
  blockedUserUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type OrgConfigDisableCollaboratorsOnlyAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type OrgConfigEnableCollaboratorsOnlyAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type OrgCreateAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  billingPlan: OrgCreateAuditEntryBillingPlan
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

enum OrgCreateAuditEntryBillingPlan {
  FREE
  BUSINESS
  BUSINESS_PLUS
  UNLIMITED
  TIERED_PER_SEAT
}

type OrgDisableOauthAppRestrictionsAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type OrgDisableSamlAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  digestMethodUrl: URI
  id: ID!
  issuerUrl: URI
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  signatureMethodUrl: URI
  singleSignOnUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type OrgDisableTwoFactorRequirementAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type OrgEnableOauthAppRestrictionsAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type OrgEnableSamlAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  digestMethodUrl: URI
  id: ID!
  issuerUrl: URI
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  signatureMethodUrl: URI
  singleSignOnUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type OrgEnableTwoFactorRequirementAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

input OrgEnterpriseOwnerOrder {
  field: OrgEnterpriseOwnerOrderField!
  direction: OrderDirection!
}

enum OrgEnterpriseOwnerOrderField {
  LOGIN
}

type OrgInviteMemberAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  email: String
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationInvitation: OrganizationInvitation
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type OrgInviteToBusinessAuditEntry implements AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  enterpriseResourcePath: URI
  enterpriseSlug: String
  enterpriseUrl: URI
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type OrgOauthAppAccessApprovedAuditEntry implements AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  oauthApplicationName: String
  oauthApplicationResourcePath: URI
  oauthApplicationUrl: URI
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type OrgOauthAppAccessBlockedAuditEntry implements AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  oauthApplicationName: String
  oauthApplicationResourcePath: URI
  oauthApplicationUrl: URI
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type OrgOauthAppAccessDeniedAuditEntry implements AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  oauthApplicationName: String
  oauthApplicationResourcePath: URI
  oauthApplicationUrl: URI
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type OrgOauthAppAccessRequestedAuditEntry implements AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  oauthApplicationName: String
  oauthApplicationResourcePath: URI
  oauthApplicationUrl: URI
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type OrgOauthAppAccessUnblockedAuditEntry implements AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  oauthApplicationName: String
  oauthApplicationResourcePath: URI
  oauthApplicationUrl: URI
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type OrgRemoveBillingManagerAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  reason: OrgRemoveBillingManagerAuditEntryReason
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

enum OrgRemoveBillingManagerAuditEntryReason {
  TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE
  SAML_EXTERNAL_IDENTITY_MISSING
  SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY
}

type OrgRemoveMemberAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  membershipTypes: [OrgRemoveMemberAuditEntryMembershipType!]
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  reason: OrgRemoveMemberAuditEntryReason
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

enum OrgRemoveMemberAuditEntryMembershipType {
  SUSPENDED
  DIRECT_MEMBER
  ADMIN
  BILLING_MANAGER
  UNAFFILIATED
  OUTSIDE_COLLABORATOR
}

enum OrgRemoveMemberAuditEntryReason {
  TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE
  SAML_EXTERNAL_IDENTITY_MISSING
  SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY
  USER_ACCOUNT_DELETED
  TWO_FACTOR_ACCOUNT_RECOVERY
}

type OrgRemoveOutsideCollaboratorAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  membershipTypes: [OrgRemoveOutsideCollaboratorAuditEntryMembershipType!]
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  reason: OrgRemoveOutsideCollaboratorAuditEntryReason
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

enum OrgRemoveOutsideCollaboratorAuditEntryMembershipType {
  OUTSIDE_COLLABORATOR
  UNAFFILIATED
  BILLING_MANAGER
}

enum OrgRemoveOutsideCollaboratorAuditEntryReason {
  TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE
  SAML_EXTERNAL_IDENTITY_MISSING
}

type OrgRestoreMemberAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  restoredCustomEmailRoutingsCount: Int
  restoredIssueAssignmentsCount: Int
  restoredMemberships: [OrgRestoreMemberAuditEntryMembership!]
  restoredMembershipsCount: Int
  restoredRepositoriesCount: Int
  restoredRepositoryStarsCount: Int
  restoredRepositoryWatchesCount: Int
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

union OrgRestoreMemberAuditEntryMembership = OrgRestoreMemberMembershipOrganizationAuditEntryData | OrgRestoreMemberMembershipRepositoryAuditEntryData | OrgRestoreMemberMembershipTeamAuditEntryData

type OrgRestoreMemberMembershipOrganizationAuditEntryData implements OrganizationAuditEntryData {
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
}

type OrgRestoreMemberMembershipRepositoryAuditEntryData implements RepositoryAuditEntryData {
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
}

type OrgRestoreMemberMembershipTeamAuditEntryData implements TeamAuditEntryData {
  team: Team
  teamName: String
  teamResourcePath: URI
  teamUrl: URI
}

type OrgUnblockUserAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  blockedUser: User
  blockedUserName: String
  blockedUserResourcePath: URI
  blockedUserUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type OrgUpdateDefaultRepositoryPermissionAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  permission: OrgUpdateDefaultRepositoryPermissionAuditEntryPermission
  permissionWas: OrgUpdateDefaultRepositoryPermissionAuditEntryPermission
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

enum OrgUpdateDefaultRepositoryPermissionAuditEntryPermission {
  READ
  WRITE
  ADMIN
  NONE
}

type OrgUpdateMemberAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  permission: OrgUpdateMemberAuditEntryPermission
  permissionWas: OrgUpdateMemberAuditEntryPermission
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

enum OrgUpdateMemberAuditEntryPermission {
  READ
  ADMIN
}

type OrgUpdateMemberRepositoryCreationPermissionAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  canCreateRepositories: Boolean
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
  visibility: OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
}

enum OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility {
  ALL
  PUBLIC
  NONE
  PRIVATE
  INTERNAL
  PUBLIC_INTERNAL
  PRIVATE_INTERNAL
  PUBLIC_PRIVATE
}

type OrgUpdateMemberRepositoryInvitationPermissionAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  canInviteOutsideCollaboratorsToRepositories: Boolean
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type Organization implements Actor & AnnouncementBanner & MemberStatusable & Node & PackageOwner & ProfileOwner & ProjectOwner & ProjectV2Owner & ProjectV2Recent & RepositoryDiscussionAuthor & RepositoryDiscussionCommentAuthor & RepositoryOwner & Sponsorable & UniformResourceLocatable {
  announcement: String
  announcementCreatedAt: DateTime
  announcementExpiresAt: DateTime
  announcementUserDismissible: Boolean
  anyPinnableItems(type: Boolean!): Boolean!
  archivedAt: DateTime
  auditLog(after: OrganizationAuditEntryConnection!, before: OrganizationAuditEntryConnection!, first: OrganizationAuditEntryConnection!, last: OrganizationAuditEntryConnection!, query: OrganizationAuditEntryConnection!, orderBy: OrganizationAuditEntryConnection!): OrganizationAuditEntryConnection!
  avatarUrl(size: URI!): URI!
  createdAt: DateTime!
  databaseId: Int
  description: String
  descriptionHTML: String
  domains(after: VerifiableDomainConnection, before: VerifiableDomainConnection, first: VerifiableDomainConnection, last: VerifiableDomainConnection, isVerified: VerifiableDomainConnection, isApproved: VerifiableDomainConnection, orderBy: VerifiableDomainConnection): VerifiableDomainConnection
  email: String
  enterpriseOwners(query: OrganizationEnterpriseOwnerConnection!, organizationRole: OrganizationEnterpriseOwnerConnection!, orderBy: OrganizationEnterpriseOwnerConnection!, after: OrganizationEnterpriseOwnerConnection!, before: OrganizationEnterpriseOwnerConnection!, first: OrganizationEnterpriseOwnerConnection!, last: OrganizationEnterpriseOwnerConnection!): OrganizationEnterpriseOwnerConnection!
  estimatedNextSponsorsPayoutInCents: Int!
  hasSponsorsListing: Boolean!
  id: ID!
  interactionAbility: RepositoryInteractionAbility
  ipAllowListEnabledSetting: IpAllowListEnabledSettingValue!
  ipAllowListEntries(after: IpAllowListEntryConnection!, before: IpAllowListEntryConnection!, first: IpAllowListEntryConnection!, last: IpAllowListEntryConnection!, orderBy: IpAllowListEntryConnection!): IpAllowListEntryConnection!
  ipAllowListForInstalledAppsEnabledSetting: IpAllowListForInstalledAppsEnabledSettingValue!
  isSponsoredBy(accountLogin: Boolean!): Boolean!
  isSponsoringViewer: Boolean!
  isVerified: Boolean!
  itemShowcase: ProfileItemShowcase!
  lifetimeReceivedSponsorshipValues(after: SponsorAndLifetimeValueConnection!, before: SponsorAndLifetimeValueConnection!, first: SponsorAndLifetimeValueConnection!, last: SponsorAndLifetimeValueConnection!, orderBy: SponsorAndLifetimeValueConnection!): SponsorAndLifetimeValueConnection!
  location: String
  login: String!
  mannequins(after: MannequinConnection!, before: MannequinConnection!, first: MannequinConnection!, last: MannequinConnection!, login: MannequinConnection!, orderBy: MannequinConnection!): MannequinConnection!
  memberStatuses(after: UserStatusConnection!, before: UserStatusConnection!, first: UserStatusConnection!, last: UserStatusConnection!, orderBy: UserStatusConnection!): UserStatusConnection!
  membersCanForkPrivateRepositories: Boolean!
  membersWithRole(after: OrganizationMemberConnection!, before: OrganizationMemberConnection!, first: OrganizationMemberConnection!, last: OrganizationMemberConnection!): OrganizationMemberConnection!
  monthlyEstimatedSponsorsIncomeInCents: Int!
  name: String
  newTeamResourcePath: URI!
  newTeamUrl: URI!
  notificationDeliveryRestrictionEnabledSetting: NotificationRestrictionSettingValue!
  organizationBillingEmail: String
  packages(after: PackageConnection!, before: PackageConnection!, first: PackageConnection!, last: PackageConnection!, names: PackageConnection!, repositoryId: PackageConnection!, packageType: PackageConnection!, orderBy: PackageConnection!): PackageConnection!
  pendingMembers(after: UserConnection!, before: UserConnection!, first: UserConnection!, last: UserConnection!): UserConnection!
  pinnableItems(types: PinnableItemConnection!, after: PinnableItemConnection!, before: PinnableItemConnection!, first: PinnableItemConnection!, last: PinnableItemConnection!): PinnableItemConnection!
  pinnedItems(types: PinnableItemConnection!, after: PinnableItemConnection!, before: PinnableItemConnection!, first: PinnableItemConnection!, last: PinnableItemConnection!): PinnableItemConnection!
  pinnedItemsRemaining: Int!
  project(number: Project): Project
  projectV2(number: ProjectV2): ProjectV2
  projects(orderBy: ProjectConnection!, search: ProjectConnection!, states: ProjectConnection!, after: ProjectConnection!, before: ProjectConnection!, first: ProjectConnection!, last: ProjectConnection!): ProjectConnection!
  projectsResourcePath: URI!
  projectsUrl: URI!
  projectsV2(query: ProjectV2Connection!, orderBy: ProjectV2Connection!, after: ProjectV2Connection!, before: ProjectV2Connection!, first: ProjectV2Connection!, last: ProjectV2Connection!): ProjectV2Connection!
  recentProjects(after: ProjectV2Connection!, before: ProjectV2Connection!, first: ProjectV2Connection!, last: ProjectV2Connection!): ProjectV2Connection!
  repositories(privacy: RepositoryConnection!, visibility: RepositoryConnection!, orderBy: RepositoryConnection!, affiliations: RepositoryConnection!, ownerAffiliations: RepositoryConnection!, isLocked: RepositoryConnection!, hasIssuesEnabled: RepositoryConnection!, after: RepositoryConnection!, before: RepositoryConnection!, first: RepositoryConnection!, last: RepositoryConnection!, isArchived: RepositoryConnection!, isFork: RepositoryConnection!): RepositoryConnection!
  repository(name: Repository, followRenames: Repository): Repository
  repositoryDiscussionComments(after: DiscussionCommentConnection!, before: DiscussionCommentConnection!, first: DiscussionCommentConnection!, last: DiscussionCommentConnection!, repositoryId: DiscussionCommentConnection!, onlyAnswers: DiscussionCommentConnection!): DiscussionCommentConnection!
  repositoryDiscussions(after: DiscussionConnection!, before: DiscussionConnection!, first: DiscussionConnection!, last: DiscussionConnection!, orderBy: DiscussionConnection!, repositoryId: DiscussionConnection!, answered: DiscussionConnection!, states: DiscussionConnection!): DiscussionConnection!
  repositoryMigrations(after: RepositoryMigrationConnection!, before: RepositoryMigrationConnection!, first: RepositoryMigrationConnection!, last: RepositoryMigrationConnection!, state: RepositoryMigrationConnection!, repositoryName: RepositoryMigrationConnection!, orderBy: RepositoryMigrationConnection!): RepositoryMigrationConnection!
  requiresTwoFactorAuthentication: Boolean
  resourcePath: URI!
  ruleset(databaseId: RepositoryRuleset): RepositoryRuleset
  rulesets(after: RepositoryRulesetConnection, before: RepositoryRulesetConnection, first: RepositoryRulesetConnection, last: RepositoryRulesetConnection, includeParents: RepositoryRulesetConnection): RepositoryRulesetConnection
  samlIdentityProvider: OrganizationIdentityProvider
  sponsoring(after: SponsorConnection!, before: SponsorConnection!, first: SponsorConnection!, last: SponsorConnection!, orderBy: SponsorConnection!): SponsorConnection!
  sponsors(after: SponsorConnection!, before: SponsorConnection!, first: SponsorConnection!, last: SponsorConnection!, tierId: SponsorConnection!, orderBy: SponsorConnection!): SponsorConnection!
  sponsorsActivities(after: SponsorsActivityConnection!, before: SponsorsActivityConnection!, first: SponsorsActivityConnection!, last: SponsorsActivityConnection!, period: SponsorsActivityConnection!, since: SponsorsActivityConnection!, until: SponsorsActivityConnection!, orderBy: SponsorsActivityConnection!, actions: SponsorsActivityConnection!, includeAsSponsor: SponsorsActivityConnection!, includePrivate: SponsorsActivityConnection!): SponsorsActivityConnection!
  sponsorsListing: SponsorsListing
  sponsorshipForViewerAsSponsor(activeOnly: Sponsorship): Sponsorship
  sponsorshipForViewerAsSponsorable(activeOnly: Sponsorship): Sponsorship
  sponsorshipNewsletters(after: SponsorshipNewsletterConnection!, before: SponsorshipNewsletterConnection!, first: SponsorshipNewsletterConnection!, last: SponsorshipNewsletterConnection!, orderBy: SponsorshipNewsletterConnection!): SponsorshipNewsletterConnection!
  sponsorshipsAsMaintainer(after: SponsorshipConnection!, before: SponsorshipConnection!, first: SponsorshipConnection!, last: SponsorshipConnection!, includePrivate: SponsorshipConnection!, orderBy: SponsorshipConnection!, activeOnly: SponsorshipConnection!): SponsorshipConnection!
  sponsorshipsAsSponsor(after: SponsorshipConnection!, before: SponsorshipConnection!, first: SponsorshipConnection!, last: SponsorshipConnection!, orderBy: SponsorshipConnection!, maintainerLogins: SponsorshipConnection!, activeOnly: SponsorshipConnection!): SponsorshipConnection!
  team(slug: Team): Team
  teams(privacy: TeamConnection!, notificationSetting: TeamConnection!, role: TeamConnection!, query: TeamConnection!, userLogins: TeamConnection!, orderBy: TeamConnection!, ldapMapped: TeamConnection!, rootTeamsOnly: TeamConnection!, after: TeamConnection!, before: TeamConnection!, first: TeamConnection!, last: TeamConnection!): TeamConnection!
  teamsResourcePath: URI!
  teamsUrl: URI!
  totalSponsorshipAmountAsSponsorInCents(since: Int, until: Int, sponsorableLogins: Int): Int
  twitterUsername: String
  updatedAt: DateTime!
  url: URI!
  viewerCanAdminister: Boolean!
  viewerCanChangePinnedItems: Boolean!
  viewerCanCreateProjects: Boolean!
  viewerCanCreateRepositories: Boolean!
  viewerCanCreateTeams: Boolean!
  viewerCanSponsor: Boolean!
  viewerIsAMember: Boolean!
  viewerIsFollowing: Boolean!
  viewerIsSponsoring: Boolean!
  webCommitSignoffRequired: Boolean!
  websiteUrl: URI
}

union OrganizationAuditEntry = MembersCanDeleteReposClearAuditEntry | MembersCanDeleteReposDisableAuditEntry | MembersCanDeleteReposEnableAuditEntry | OauthApplicationCreateAuditEntry | OrgAddBillingManagerAuditEntry | OrgAddMemberAuditEntry | OrgBlockUserAuditEntry | OrgConfigDisableCollaboratorsOnlyAuditEntry | OrgConfigEnableCollaboratorsOnlyAuditEntry | OrgCreateAuditEntry | OrgDisableOauthAppRestrictionsAuditEntry | OrgDisableSamlAuditEntry | OrgDisableTwoFactorRequirementAuditEntry | OrgEnableOauthAppRestrictionsAuditEntry | OrgEnableSamlAuditEntry | OrgEnableTwoFactorRequirementAuditEntry | OrgInviteMemberAuditEntry | OrgInviteToBusinessAuditEntry | OrgOauthAppAccessApprovedAuditEntry | OrgOauthAppAccessBlockedAuditEntry | OrgOauthAppAccessDeniedAuditEntry | OrgOauthAppAccessRequestedAuditEntry | OrgOauthAppAccessUnblockedAuditEntry | OrgRemoveBillingManagerAuditEntry | OrgRemoveMemberAuditEntry | OrgRemoveOutsideCollaboratorAuditEntry | OrgRestoreMemberAuditEntry | OrgUnblockUserAuditEntry | OrgUpdateDefaultRepositoryPermissionAuditEntry | OrgUpdateMemberAuditEntry | OrgUpdateMemberRepositoryCreationPermissionAuditEntry | OrgUpdateMemberRepositoryInvitationPermissionAuditEntry | PrivateRepositoryForkingDisableAuditEntry | PrivateRepositoryForkingEnableAuditEntry | RepoAccessAuditEntry | RepoAddMemberAuditEntry | RepoAddTopicAuditEntry | RepoArchivedAuditEntry | RepoChangeMergeSettingAuditEntry | RepoConfigDisableAnonymousGitAccessAuditEntry | RepoConfigDisableCollaboratorsOnlyAuditEntry | RepoConfigDisableContributorsOnlyAuditEntry | RepoConfigDisableSockpuppetDisallowedAuditEntry | RepoConfigEnableAnonymousGitAccessAuditEntry | RepoConfigEnableCollaboratorsOnlyAuditEntry | RepoConfigEnableContributorsOnlyAuditEntry | RepoConfigEnableSockpuppetDisallowedAuditEntry | RepoConfigLockAnonymousGitAccessAuditEntry | RepoConfigUnlockAnonymousGitAccessAuditEntry | RepoCreateAuditEntry | RepoDestroyAuditEntry | RepoRemoveMemberAuditEntry | RepoRemoveTopicAuditEntry | RepositoryVisibilityChangeDisableAuditEntry | RepositoryVisibilityChangeEnableAuditEntry | TeamAddMemberAuditEntry | TeamAddRepositoryAuditEntry | TeamChangeParentTeamAuditEntry | TeamRemoveMemberAuditEntry | TeamRemoveRepositoryAuditEntry

type OrganizationAuditEntryConnection {
  edges: [OrganizationAuditEntryEdge]
  nodes: [OrganizationAuditEntry]
  pageInfo: PageInfo!
  totalCount: Int!
}

interface OrganizationAuditEntryData {
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
}

type OrganizationAuditEntryEdge {
  cursor: String!
  node: OrganizationAuditEntry
}

type OrganizationConnection {
  edges: [OrganizationEdge]
  nodes: [Organization]
  pageInfo: PageInfo!
  totalCount: Int!
}

type OrganizationEdge {
  cursor: String!
  node: Organization
}

type OrganizationEnterpriseOwnerConnection {
  edges: [OrganizationEnterpriseOwnerEdge]
  nodes: [User]
  pageInfo: PageInfo!
  totalCount: Int!
}

type OrganizationEnterpriseOwnerEdge {
  cursor: String!
  node: User
  organizationRole: RoleInOrganization!
}

type OrganizationIdentityProvider implements Node {
  digestMethod: URI
  externalIdentities(membersOnly: ExternalIdentityConnection!, login: ExternalIdentityConnection!, userName: ExternalIdentityConnection!, after: ExternalIdentityConnection!, before: ExternalIdentityConnection!, first: ExternalIdentityConnection!, last: ExternalIdentityConnection!): ExternalIdentityConnection!
  id: ID!
  idpCertificate: X509Certificate
  issuer: String
  organization: Organization
  signatureMethod: URI
  ssoUrl: URI
}

type OrganizationInvitation implements Node {
  createdAt: DateTime!
  email: String
  id: ID!
  invitationSource: OrganizationInvitationSource!
  invitationType: OrganizationInvitationType!
  invitee: User
  inviter: User!
  inviterActor: User
  organization: Organization!
  role: OrganizationInvitationRole!
}

type OrganizationInvitationConnection {
  edges: [OrganizationInvitationEdge]
  nodes: [OrganizationInvitation]
  pageInfo: PageInfo!
  totalCount: Int!
}

type OrganizationInvitationEdge {
  cursor: String!
  node: OrganizationInvitation
}

enum OrganizationInvitationRole {
  DIRECT_MEMBER
  ADMIN
  BILLING_MANAGER
  REINSTATE
}

enum OrganizationInvitationSource {
  UNKNOWN
  MEMBER
  SCIM
}

enum OrganizationInvitationType {
  USER
  EMAIL
}

type OrganizationMemberConnection {
  edges: [OrganizationMemberEdge]
  nodes: [User]
  pageInfo: PageInfo!
  totalCount: Int!
}

type OrganizationMemberEdge {
  cursor: String!
  hasTwoFactorEnabled: Boolean
  node: User
  role: OrganizationMemberRole
}

enum OrganizationMemberRole {
  MEMBER
  ADMIN
}

enum OrganizationMembersCanCreateRepositoriesSettingValue {
  ALL
  PRIVATE
  INTERNAL
  DISABLED
}

type OrganizationMigration implements Node {
  createdAt: DateTime!
  databaseId: String
  failureReason: String
  id: ID!
  remainingRepositoriesCount: Int
  sourceOrgName: String!
  sourceOrgUrl: URI!
  state: OrganizationMigrationState!
  targetOrgName: String!
  totalRepositoriesCount: Int
}

enum OrganizationMigrationState {
  NOT_STARTED
  QUEUED
  IN_PROGRESS
  PRE_REPO_MIGRATION
  REPO_MIGRATION
  POST_REPO_MIGRATION
  SUCCEEDED
  FAILED
  PENDING_VALIDATION
  FAILED_VALIDATION
}

union OrganizationOrUser = Organization | User

input OrganizationOrder {
  field: OrganizationOrderField!
  direction: OrderDirection!
}

enum OrganizationOrderField {
  CREATED_AT
  LOGIN
}

type OrganizationTeamsHovercardContext implements HovercardContext {
  message: String!
  octicon: String!
  relevantTeams(after: TeamConnection!, before: TeamConnection!, first: TeamConnection!, last: TeamConnection!): TeamConnection!
  teamsResourcePath: URI!
  teamsUrl: URI!
  totalTeamCount: Int!
}

type OrganizationsHovercardContext implements HovercardContext {
  message: String!
  octicon: String!
  relevantOrganizations(orderBy: OrganizationConnection!, after: OrganizationConnection!, before: OrganizationConnection!, first: OrganizationConnection!, last: OrganizationConnection!): OrganizationConnection!
  totalOrganizationCount: Int!
}

type Package implements Node {
  id: ID!
  latestVersion: PackageVersion
  name: String!
  packageType: PackageType!
  repository: Repository
  statistics: PackageStatistics
  version(version: PackageVersion): PackageVersion
  versions(orderBy: PackageVersionConnection!, after: PackageVersionConnection!, before: PackageVersionConnection!, first: PackageVersionConnection!, last: PackageVersionConnection!): PackageVersionConnection!
}

type PackageConnection {
  edges: [PackageEdge]
  nodes: [Package]
  pageInfo: PageInfo!
  totalCount: Int!
}

type PackageEdge {
  cursor: String!
  node: Package
}

type PackageFile implements Node {
  id: ID!
  md5: String
  name: String!
  packageVersion: PackageVersion
  sha1: String
  sha256: String
  size: Int
  updatedAt: DateTime!
  url: URI
}

type PackageFileConnection {
  edges: [PackageFileEdge]
  nodes: [PackageFile]
  pageInfo: PageInfo!
  totalCount: Int!
}

type PackageFileEdge {
  cursor: String!
  node: PackageFile
}

input PackageFileOrder {
  field: PackageFileOrderField
  direction: OrderDirection
}

enum PackageFileOrderField {
  CREATED_AT
}

input PackageOrder {
  field: PackageOrderField
  direction: OrderDirection
}

enum PackageOrderField {
  CREATED_AT
}

interface PackageOwner {
  id: ID!
  packages(after: PackageConnection!, before: PackageConnection!, first: PackageConnection!, last: PackageConnection!, names: PackageConnection!, repositoryId: PackageConnection!, packageType: PackageConnection!, orderBy: PackageConnection!): PackageConnection!
}

type PackageStatistics {
  downloadsTotalCount: Int!
}

type PackageTag implements Node {
  id: ID!
  name: String!
  version: PackageVersion
}

enum PackageType {
  NPM
  RUBYGEMS
  MAVEN
  DOCKER
  DEBIAN
  NUGET
  PYPI
}

type PackageVersion implements Node {
  files(orderBy: PackageFileConnection!, after: PackageFileConnection!, before: PackageFileConnection!, first: PackageFileConnection!, last: PackageFileConnection!): PackageFileConnection!
  id: ID!
  package: Package
  platform: String
  preRelease: Boolean!
  readme: String
  release: Release
  statistics: PackageVersionStatistics
  summary: String
  version: String!
}

type PackageVersionConnection {
  edges: [PackageVersionEdge]
  nodes: [PackageVersion]
  pageInfo: PageInfo!
  totalCount: Int!
}

type PackageVersionEdge {
  cursor: String!
  node: PackageVersion
}

input PackageVersionOrder {
  field: PackageVersionOrderField
  direction: OrderDirection
}

enum PackageVersionOrderField {
  CREATED_AT
}

type PackageVersionStatistics {
  downloadsTotalCount: Int!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

enum PatchStatus {
  ADDED
  DELETED
  RENAMED
  COPIED
  MODIFIED
  CHANGED
}

union PermissionGranter = Organization | Repository | Team

type PermissionSource {
  organization: Organization!
  permission: DefaultRepositoryPermissionField!
  roleName: String
  source: PermissionGranter!
}

input PinEnvironmentInput {
  clientMutationId: String
  environmentId: ID!
  pinned: Boolean!
}

type PinEnvironmentPayload {
  clientMutationId: String
  environment: Environment
  pinnedEnvironment: PinnedEnvironment
}

input PinIssueInput {
  clientMutationId: String
  issueId: ID!
}

type PinIssuePayload {
  clientMutationId: String
  issue: Issue
}

union PinnableItem = Gist | Repository

type PinnableItemConnection {
  edges: [PinnableItemEdge]
  nodes: [PinnableItem]
  pageInfo: PageInfo!
  totalCount: Int!
}

type PinnableItemEdge {
  cursor: String!
  node: PinnableItem
}

enum PinnableItemType {
  REPOSITORY
  GIST
  ISSUE
  PROJECT
  PULL_REQUEST
  USER
  ORGANIZATION
  TEAM
}

type PinnedDiscussion implements Node & RepositoryNode {
  createdAt: DateTime!
  databaseId: Int
  discussion: Discussion!
  gradientStopColors: [String!]!
  id: ID!
  pattern: PinnedDiscussionPattern!
  pinnedBy: Actor!
  preconfiguredGradient: PinnedDiscussionGradient
  repository: Repository!
  updatedAt: DateTime!
}

type PinnedDiscussionConnection {
  edges: [PinnedDiscussionEdge]
  nodes: [PinnedDiscussion]
  pageInfo: PageInfo!
  totalCount: Int!
}

type PinnedDiscussionEdge {
  cursor: String!
  node: PinnedDiscussion
}

enum PinnedDiscussionGradient {
  RED_ORANGE
  BLUE_MINT
  BLUE_PURPLE
  PINK_BLUE
  PURPLE_CORAL
}

enum PinnedDiscussionPattern {
  DOT_FILL
  PLUS
  ZAP
  CHEVRON_UP
  DOT
  HEART_FILL
}

type PinnedEnvironment implements Node {
  createdAt: DateTime!
  databaseId: Int
  environment: Environment!
  id: ID!
  position: Int!
  repository: Repository!
}

type PinnedEnvironmentConnection {
  edges: [PinnedEnvironmentEdge]
  nodes: [PinnedEnvironment]
  pageInfo: PageInfo!
  totalCount: Int!
}

type PinnedEnvironmentEdge {
  cursor: String!
  node: PinnedEnvironment
}

input PinnedEnvironmentOrder {
  field: PinnedEnvironmentOrderField!
  direction: OrderDirection!
}

enum PinnedEnvironmentOrderField {
  POSITION
}

type PinnedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  issue: Issue!
}

type PinnedIssue implements Node {
  databaseId: Int
  fullDatabaseId: BigInt
  id: ID!
  issue: Issue!
  pinnedBy: Actor!
  repository: Repository!
}

type PinnedIssueConnection {
  edges: [PinnedIssueEdge]
  nodes: [PinnedIssue]
  pageInfo: PageInfo!
  totalCount: Int!
}

type PinnedIssueEdge {
  cursor: String!
  node: PinnedIssue
}

scalar PreciseDateTime

type PrivateRepositoryForkingDisableAuditEntry implements AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  enterpriseResourcePath: URI
  enterpriseSlug: String
  enterpriseUrl: URI
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type PrivateRepositoryForkingEnableAuditEntry implements AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  enterpriseResourcePath: URI
  enterpriseSlug: String
  enterpriseUrl: URI
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type ProfileItemShowcase {
  hasPinnedItems: Boolean!
  items(after: PinnableItemConnection!, before: PinnableItemConnection!, first: PinnableItemConnection!, last: PinnableItemConnection!): PinnableItemConnection!
}

interface ProfileOwner {
  anyPinnableItems(type: Boolean!): Boolean!
  email: String
  id: ID!
  itemShowcase: ProfileItemShowcase!
  location: String
  login: String!
  name: String
  pinnableItems(types: PinnableItemConnection!, after: PinnableItemConnection!, before: PinnableItemConnection!, first: PinnableItemConnection!, last: PinnableItemConnection!): PinnableItemConnection!
  pinnedItems(types: PinnableItemConnection!, after: PinnableItemConnection!, before: PinnableItemConnection!, first: PinnableItemConnection!, last: PinnableItemConnection!): PinnableItemConnection!
  pinnedItemsRemaining: Int!
  viewerCanChangePinnedItems: Boolean!
  websiteUrl: URI
}

type Project implements Closable & Node & Updatable {
  body: String
  bodyHTML: HTML!
  closed: Boolean!
  closedAt: DateTime
  columns(after: ProjectColumnConnection!, before: ProjectColumnConnection!, first: ProjectColumnConnection!, last: ProjectColumnConnection!): ProjectColumnConnection!
  createdAt: DateTime!
  creator: Actor
  databaseId: Int
  id: ID!
  name: String!
  number: Int!
  owner: ProjectOwner!
  pendingCards(after: ProjectCardConnection!, before: ProjectCardConnection!, first: ProjectCardConnection!, last: ProjectCardConnection!, archivedStates: ProjectCardConnection!): ProjectCardConnection!
  progress: ProjectProgress!
  resourcePath: URI!
  state: ProjectState!
  updatedAt: DateTime!
  url: URI!
  viewerCanClose: Boolean!
  viewerCanReopen: Boolean!
  viewerCanUpdate: Boolean!
}

type ProjectCard implements Node {
  column: ProjectColumn
  content: ProjectCardItem
  createdAt: DateTime!
  creator: Actor
  databaseId: Int
  id: ID!
  isArchived: Boolean!
  note: String
  project: Project!
  resourcePath: URI!
  state: ProjectCardState
  updatedAt: DateTime!
  url: URI!
}

enum ProjectCardArchivedState {
  ARCHIVED
  NOT_ARCHIVED
}

type ProjectCardConnection {
  edges: [ProjectCardEdge]
  nodes: [ProjectCard]
  pageInfo: PageInfo!
  totalCount: Int!
}

type ProjectCardEdge {
  cursor: String!
  node: ProjectCard
}

input ProjectCardImport {
  repository: String!
  number: Int!
}

union ProjectCardItem = Issue | PullRequest

enum ProjectCardState {
  CONTENT_ONLY
  NOTE_ONLY
  REDACTED
}

type ProjectColumn implements Node {
  cards(after: ProjectCardConnection!, before: ProjectCardConnection!, first: ProjectCardConnection!, last: ProjectCardConnection!, archivedStates: ProjectCardConnection!): ProjectCardConnection!
  createdAt: DateTime!
  databaseId: Int
  id: ID!
  name: String!
  project: Project!
  purpose: ProjectColumnPurpose
  resourcePath: URI!
  updatedAt: DateTime!
  url: URI!
}

type ProjectColumnConnection {
  edges: [ProjectColumnEdge]
  nodes: [ProjectColumn]
  pageInfo: PageInfo!
  totalCount: Int!
}

type ProjectColumnEdge {
  cursor: String!
  node: ProjectColumn
}

input ProjectColumnImport {
  columnName: String!
  position: Int!
  issues: [ProjectCardImport!]
}

enum ProjectColumnPurpose {
  TODO
  IN_PROGRESS
  DONE
}

type ProjectConnection {
  edges: [ProjectEdge]
  nodes: [Project]
  pageInfo: PageInfo!
  totalCount: Int!
}

type ProjectEdge {
  cursor: String!
  node: Project
}

input ProjectOrder {
  field: ProjectOrderField!
  direction: OrderDirection!
}

enum ProjectOrderField {
  CREATED_AT
  UPDATED_AT
  NAME
}

interface ProjectOwner {
  id: ID!
  project(number: Project): Project
  projects(orderBy: ProjectConnection!, search: ProjectConnection!, states: ProjectConnection!, after: ProjectConnection!, before: ProjectConnection!, first: ProjectConnection!, last: ProjectConnection!): ProjectConnection!
  projectsResourcePath: URI!
  projectsUrl: URI!
  viewerCanCreateProjects: Boolean!
}

type ProjectProgress {
  doneCount: Int!
  donePercentage: Float!
  enabled: Boolean!
  inProgressCount: Int!
  inProgressPercentage: Float!
  todoCount: Int!
  todoPercentage: Float!
}

enum ProjectState {
  OPEN
  CLOSED
}

enum ProjectTemplate {
  BASIC_KANBAN
  AUTOMATED_KANBAN_V2
  AUTOMATED_REVIEWS_KANBAN
  BUG_TRIAGE
}

type ProjectV2 implements Closable & Node & Updatable {
  closed: Boolean!
  closedAt: DateTime
  createdAt: DateTime!
  creator: Actor
  databaseId: Int
  field(name: ProjectV2FieldConfiguration): ProjectV2FieldConfiguration
  fields(after: ProjectV2FieldConfigurationConnection!, before: ProjectV2FieldConfigurationConnection!, first: ProjectV2FieldConfigurationConnection!, last: ProjectV2FieldConfigurationConnection!, orderBy: ProjectV2FieldConfigurationConnection!): ProjectV2FieldConfigurationConnection!
  id: ID!
  items(after: ProjectV2ItemConnection!, before: ProjectV2ItemConnection!, first: ProjectV2ItemConnection!, last: ProjectV2ItemConnection!, orderBy: ProjectV2ItemConnection!): ProjectV2ItemConnection!
  number: Int!
  owner: ProjectV2Owner!
  public: Boolean!
  readme: String
  repositories(after: RepositoryConnection!, before: RepositoryConnection!, first: RepositoryConnection!, last: RepositoryConnection!, orderBy: RepositoryConnection!): RepositoryConnection!
  resourcePath: URI!
  shortDescription: String
  teams(after: TeamConnection!, before: TeamConnection!, first: TeamConnection!, last: TeamConnection!, orderBy: TeamConnection!): TeamConnection!
  template: Boolean!
  title: String!
  updatedAt: DateTime!
  url: URI!
  view(number: ProjectV2View): ProjectV2View
  viewerCanClose: Boolean!
  viewerCanReopen: Boolean!
  viewerCanUpdate: Boolean!
  views(after: ProjectV2ViewConnection!, before: ProjectV2ViewConnection!, first: ProjectV2ViewConnection!, last: ProjectV2ViewConnection!, orderBy: ProjectV2ViewConnection!): ProjectV2ViewConnection!
  workflow(number: ProjectV2Workflow): ProjectV2Workflow
  workflows(after: ProjectV2WorkflowConnection!, before: ProjectV2WorkflowConnection!, first: ProjectV2WorkflowConnection!, last: ProjectV2WorkflowConnection!, orderBy: ProjectV2WorkflowConnection!): ProjectV2WorkflowConnection!
}

union ProjectV2Actor = Team | User

type ProjectV2ActorConnection {
  edges: [ProjectV2ActorEdge]
  nodes: [ProjectV2Actor]
  pageInfo: PageInfo!
  totalCount: Int!
}

type ProjectV2ActorEdge {
  cursor: String!
  node: ProjectV2Actor
}

input ProjectV2Collaborator {
  userId: ID
  teamId: ID
  role: ProjectV2Roles!
}

type ProjectV2Connection {
  edges: [ProjectV2Edge]
  nodes: [ProjectV2]
  pageInfo: PageInfo!
  totalCount: Int!
}

enum ProjectV2CustomFieldType {
  TEXT
  SINGLE_SELECT
  NUMBER
  DATE
}

type ProjectV2Edge {
  cursor: String!
  node: ProjectV2
}

type ProjectV2Field implements Node & ProjectV2FieldCommon {
  createdAt: DateTime!
  dataType: ProjectV2FieldType!
  databaseId: Int
  id: ID!
  name: String!
  project: ProjectV2!
  updatedAt: DateTime!
}

interface ProjectV2FieldCommon {
  createdAt: DateTime!
  dataType: ProjectV2FieldType!
  databaseId: Int
  id: ID!
  name: String!
  project: ProjectV2!
  updatedAt: DateTime!
}

union ProjectV2FieldConfiguration = ProjectV2Field | ProjectV2IterationField | ProjectV2SingleSelectField

type ProjectV2FieldConfigurationConnection {
  edges: [ProjectV2FieldConfigurationEdge]
  nodes: [ProjectV2FieldConfiguration]
  pageInfo: PageInfo!
  totalCount: Int!
}

type ProjectV2FieldConfigurationEdge {
  cursor: String!
  node: ProjectV2FieldConfiguration
}

type ProjectV2FieldConnection {
  edges: [ProjectV2FieldEdge]
  nodes: [ProjectV2Field]
  pageInfo: PageInfo!
  totalCount: Int!
}

type ProjectV2FieldEdge {
  cursor: String!
  node: ProjectV2Field
}

input ProjectV2FieldOrder {
  field: ProjectV2FieldOrderField!
  direction: OrderDirection!
}

enum ProjectV2FieldOrderField {
  POSITION
  CREATED_AT
  NAME
}

enum ProjectV2FieldType {
  ASSIGNEES
  LINKED_PULL_REQUESTS
  REVIEWERS
  LABELS
  MILESTONE
  REPOSITORY
  TITLE
  TEXT
  SINGLE_SELECT
  NUMBER
  DATE
  ITERATION
  TRACKS
  TRACKED_BY
}

input ProjectV2FieldValue {
  text: String
  number: Float
  date: Date
  singleSelectOptionId: String
  iterationId: String
}

input ProjectV2Filters {
  state: ProjectV2State
}

type ProjectV2Item implements Node {
  content: ProjectV2ItemContent
  createdAt: DateTime!
  creator: Actor
  databaseId: Int
  fieldValueByName(name: ProjectV2ItemFieldValue): ProjectV2ItemFieldValue
  fieldValues(after: ProjectV2ItemFieldValueConnection!, before: ProjectV2ItemFieldValueConnection!, first: ProjectV2ItemFieldValueConnection!, last: ProjectV2ItemFieldValueConnection!, orderBy: ProjectV2ItemFieldValueConnection!): ProjectV2ItemFieldValueConnection!
  fullDatabaseId: BigInt
  id: ID!
  isArchived: Boolean!
  project: ProjectV2!
  type: ProjectV2ItemType!
  updatedAt: DateTime!
}

type ProjectV2ItemConnection {
  edges: [ProjectV2ItemEdge]
  nodes: [ProjectV2Item]
  pageInfo: PageInfo!
  totalCount: Int!
}

union ProjectV2ItemContent = DraftIssue | Issue | PullRequest

type ProjectV2ItemEdge {
  cursor: String!
  node: ProjectV2Item
}

type ProjectV2ItemFieldDateValue implements Node & ProjectV2ItemFieldValueCommon {
  createdAt: DateTime!
  creator: Actor
  databaseId: Int
  date: Date
  field: ProjectV2FieldConfiguration!
  id: ID!
  item: ProjectV2Item!
  updatedAt: DateTime!
}

type ProjectV2ItemFieldIterationValue implements Node & ProjectV2ItemFieldValueCommon {
  createdAt: DateTime!
  creator: Actor
  databaseId: Int
  duration: Int!
  field: ProjectV2FieldConfiguration!
  id: ID!
  item: ProjectV2Item!
  iterationId: String!
  startDate: Date!
  title: String!
  titleHTML: String!
  updatedAt: DateTime!
}

type ProjectV2ItemFieldLabelValue {
  field: ProjectV2FieldConfiguration!
  labels(after: LabelConnection, before: LabelConnection, first: LabelConnection, last: LabelConnection): LabelConnection
}

type ProjectV2ItemFieldMilestoneValue {
  field: ProjectV2FieldConfiguration!
  milestone: Milestone
}

type ProjectV2ItemFieldNumberValue implements Node & ProjectV2ItemFieldValueCommon {
  createdAt: DateTime!
  creator: Actor
  databaseId: Int
  field: ProjectV2FieldConfiguration!
  id: ID!
  item: ProjectV2Item!
  number: Float
  updatedAt: DateTime!
}

type ProjectV2ItemFieldPullRequestValue {
  field: ProjectV2FieldConfiguration!
  pullRequests(after: PullRequestConnection, before: PullRequestConnection, first: PullRequestConnection, last: PullRequestConnection, orderBy: PullRequestConnection): PullRequestConnection
}

type ProjectV2ItemFieldRepositoryValue {
  field: ProjectV2FieldConfiguration!
  repository: Repository
}

type ProjectV2ItemFieldReviewerValue {
  field: ProjectV2FieldConfiguration!
  reviewers(after: RequestedReviewerConnection, before: RequestedReviewerConnection, first: RequestedReviewerConnection, last: RequestedReviewerConnection): RequestedReviewerConnection
}

type ProjectV2ItemFieldSingleSelectValue implements Node & ProjectV2ItemFieldValueCommon {
  color: ProjectV2SingleSelectFieldOptionColor!
  createdAt: DateTime!
  creator: Actor
  databaseId: Int
  description: String
  descriptionHTML: String
  field: ProjectV2FieldConfiguration!
  id: ID!
  item: ProjectV2Item!
  name: String
  nameHTML: String
  optionId: String
  updatedAt: DateTime!
}

type ProjectV2ItemFieldTextValue implements Node & ProjectV2ItemFieldValueCommon {
  createdAt: DateTime!
  creator: Actor
  databaseId: Int
  field: ProjectV2FieldConfiguration!
  id: ID!
  item: ProjectV2Item!
  text: String
  updatedAt: DateTime!
}

type ProjectV2ItemFieldUserValue {
  field: ProjectV2FieldConfiguration!
  users(after: UserConnection, before: UserConnection, first: UserConnection, last: UserConnection): UserConnection
}

union ProjectV2ItemFieldValue = ProjectV2ItemFieldDateValue | ProjectV2ItemFieldIterationValue | ProjectV2ItemFieldLabelValue | ProjectV2ItemFieldMilestoneValue | ProjectV2ItemFieldNumberValue | ProjectV2ItemFieldPullRequestValue | ProjectV2ItemFieldRepositoryValue | ProjectV2ItemFieldReviewerValue | ProjectV2ItemFieldSingleSelectValue | ProjectV2ItemFieldTextValue | ProjectV2ItemFieldUserValue

interface ProjectV2ItemFieldValueCommon {
  createdAt: DateTime!
  creator: Actor
  databaseId: Int
  field: ProjectV2FieldConfiguration!
  id: ID!
  item: ProjectV2Item!
  updatedAt: DateTime!
}

type ProjectV2ItemFieldValueConnection {
  edges: [ProjectV2ItemFieldValueEdge]
  nodes: [ProjectV2ItemFieldValue]
  pageInfo: PageInfo!
  totalCount: Int!
}

type ProjectV2ItemFieldValueEdge {
  cursor: String!
  node: ProjectV2ItemFieldValue
}

input ProjectV2ItemFieldValueOrder {
  field: ProjectV2ItemFieldValueOrderField!
  direction: OrderDirection!
}

enum ProjectV2ItemFieldValueOrderField {
  POSITION
}

input ProjectV2ItemOrder {
  field: ProjectV2ItemOrderField!
  direction: OrderDirection!
}

enum ProjectV2ItemOrderField {
  POSITION
}

enum ProjectV2ItemType {
  ISSUE
  PULL_REQUEST
  DRAFT_ISSUE
  REDACTED
}

type ProjectV2IterationField implements Node & ProjectV2FieldCommon {
  configuration: ProjectV2IterationFieldConfiguration!
  createdAt: DateTime!
  dataType: ProjectV2FieldType!
  databaseId: Int
  id: ID!
  name: String!
  project: ProjectV2!
  updatedAt: DateTime!
}

type ProjectV2IterationFieldConfiguration {
  completedIterations: [ProjectV2IterationFieldIteration!]!
  duration: Int!
  iterations: [ProjectV2IterationFieldIteration!]!
  startDay: Int!
}

type ProjectV2IterationFieldIteration {
  duration: Int!
  id: String!
  startDate: Date!
  title: String!
  titleHTML: String!
}

input ProjectV2Order {
  field: ProjectV2OrderField!
  direction: OrderDirection!
}

enum ProjectV2OrderField {
  TITLE
  NUMBER
  UPDATED_AT
  CREATED_AT
}

interface ProjectV2Owner {
  id: ID!
  projectV2(number: ProjectV2): ProjectV2
  projectsV2(query: ProjectV2Connection!, orderBy: ProjectV2Connection!, after: ProjectV2Connection!, before: ProjectV2Connection!, first: ProjectV2Connection!, last: ProjectV2Connection!): ProjectV2Connection!
}

interface ProjectV2Recent {
  recentProjects(after: ProjectV2Connection!, before: ProjectV2Connection!, first: ProjectV2Connection!, last: ProjectV2Connection!): ProjectV2Connection!
}

enum ProjectV2Roles {
  NONE
  READER
  WRITER
  ADMIN
}

type ProjectV2SingleSelectField implements Node & ProjectV2FieldCommon {
  createdAt: DateTime!
  dataType: ProjectV2FieldType!
  databaseId: Int
  id: ID!
  name: String!
  options(names: [ProjectV2SingleSelectFieldOption!]!): [ProjectV2SingleSelectFieldOption!]!
  project: ProjectV2!
  updatedAt: DateTime!
}

type ProjectV2SingleSelectFieldOption {
  color: ProjectV2SingleSelectFieldOptionColor!
  description: String!
  descriptionHTML: String!
  id: String!
  name: String!
  nameHTML: String!
}

enum ProjectV2SingleSelectFieldOptionColor {
  GRAY
  BLUE
  GREEN
  YELLOW
  ORANGE
  RED
  PINK
  PURPLE
}

input ProjectV2SingleSelectFieldOptionInput {
  name: String!
  color: ProjectV2SingleSelectFieldOptionColor!
  description: String!
}

type ProjectV2SortBy {
  direction: OrderDirection!
  field: ProjectV2Field!
}

type ProjectV2SortByConnection {
  edges: [ProjectV2SortByEdge]
  nodes: [ProjectV2SortBy]
  pageInfo: PageInfo!
  totalCount: Int!
}

type ProjectV2SortByEdge {
  cursor: String!
  node: ProjectV2SortBy
}

type ProjectV2SortByField {
  direction: OrderDirection!
  field: ProjectV2FieldConfiguration!
}

type ProjectV2SortByFieldConnection {
  edges: [ProjectV2SortByFieldEdge]
  nodes: [ProjectV2SortByField]
  pageInfo: PageInfo!
  totalCount: Int!
}

type ProjectV2SortByFieldEdge {
  cursor: String!
  node: ProjectV2SortByField
}

enum ProjectV2State {
  OPEN
  CLOSED
}

type ProjectV2View implements Node {
  createdAt: DateTime!
  databaseId: Int
  fields(after: ProjectV2FieldConfigurationConnection, before: ProjectV2FieldConfigurationConnection, first: ProjectV2FieldConfigurationConnection, last: ProjectV2FieldConfigurationConnection, orderBy: ProjectV2FieldConfigurationConnection): ProjectV2FieldConfigurationConnection
  filter: String
  groupBy(after: ProjectV2FieldConnection, before: ProjectV2FieldConnection, first: ProjectV2FieldConnection, last: ProjectV2FieldConnection, orderBy: ProjectV2FieldConnection): ProjectV2FieldConnection
  groupByFields(after: ProjectV2FieldConfigurationConnection, before: ProjectV2FieldConfigurationConnection, first: ProjectV2FieldConfigurationConnection, last: ProjectV2FieldConfigurationConnection, orderBy: ProjectV2FieldConfigurationConnection): ProjectV2FieldConfigurationConnection
  id: ID!
  layout: ProjectV2ViewLayout!
  name: String!
  number: Int!
  project: ProjectV2!
  sortBy(after: ProjectV2SortByConnection, before: ProjectV2SortByConnection, first: ProjectV2SortByConnection, last: ProjectV2SortByConnection): ProjectV2SortByConnection
  sortByFields(after: ProjectV2SortByFieldConnection, before: ProjectV2SortByFieldConnection, first: ProjectV2SortByFieldConnection, last: ProjectV2SortByFieldConnection): ProjectV2SortByFieldConnection
  updatedAt: DateTime!
  verticalGroupBy(after: ProjectV2FieldConnection, before: ProjectV2FieldConnection, first: ProjectV2FieldConnection, last: ProjectV2FieldConnection, orderBy: ProjectV2FieldConnection): ProjectV2FieldConnection
  verticalGroupByFields(after: ProjectV2FieldConfigurationConnection, before: ProjectV2FieldConfigurationConnection, first: ProjectV2FieldConfigurationConnection, last: ProjectV2FieldConfigurationConnection, orderBy: ProjectV2FieldConfigurationConnection): ProjectV2FieldConfigurationConnection
  visibleFields(after: ProjectV2FieldConnection, before: ProjectV2FieldConnection, first: ProjectV2FieldConnection, last: ProjectV2FieldConnection, orderBy: ProjectV2FieldConnection): ProjectV2FieldConnection
}

type ProjectV2ViewConnection {
  edges: [ProjectV2ViewEdge]
  nodes: [ProjectV2View]
  pageInfo: PageInfo!
  totalCount: Int!
}

type ProjectV2ViewEdge {
  cursor: String!
  node: ProjectV2View
}

enum ProjectV2ViewLayout {
  BOARD_LAYOUT
  TABLE_LAYOUT
  ROADMAP_LAYOUT
}

input ProjectV2ViewOrder {
  field: ProjectV2ViewOrderField!
  direction: OrderDirection!
}

enum ProjectV2ViewOrderField {
  POSITION
  CREATED_AT
  NAME
}

type ProjectV2Workflow implements Node {
  createdAt: DateTime!
  databaseId: Int
  enabled: Boolean!
  id: ID!
  name: String!
  number: Int!
  project: ProjectV2!
  updatedAt: DateTime!
}

type ProjectV2WorkflowConnection {
  edges: [ProjectV2WorkflowEdge]
  nodes: [ProjectV2Workflow]
  pageInfo: PageInfo!
  totalCount: Int!
}

type ProjectV2WorkflowEdge {
  cursor: String!
  node: ProjectV2Workflow
}

input ProjectV2WorkflowOrder {
  field: ProjectV2WorkflowsOrderField!
  direction: OrderDirection!
}

enum ProjectV2WorkflowsOrderField {
  NAME
  NUMBER
  UPDATED_AT
  CREATED_AT
}

type PropertyTargetDefinition {
  name: String!
  propertyValues: [String!]!
}

input PropertyTargetDefinitionInput {
  name: String!
  propertyValues: []!
}

type PublicKey implements Node {
  accessedAt: DateTime
  createdAt: DateTime
  fingerprint: String!
  id: ID!
  isReadOnly: Boolean
  key: String!
  updatedAt: DateTime
}

type PublicKeyConnection {
  edges: [PublicKeyEdge]
  nodes: [PublicKey]
  pageInfo: PageInfo!
  totalCount: Int!
}

type PublicKeyEdge {
  cursor: String!
  node: PublicKey
}

input PublishSponsorsTierInput {
  clientMutationId: String
  tierId: ID!
}

type PublishSponsorsTierPayload {
  clientMutationId: String
  sponsorsTier: SponsorsTier
}

type PullRequest implements Assignable & Closable & Comment & Labelable & Lockable & Node & ProjectV2Owner & Reactable & RepositoryNode & Subscribable & UniformResourceLocatable & Updatable & UpdatableComment {
  activeLockReason: LockReason
  additions: Int!
  assignees(after: UserConnection!, before: UserConnection!, first: UserConnection!, last: UserConnection!): UserConnection!
  author: Actor
  authorAssociation: CommentAuthorAssociation!
  autoMergeRequest: AutoMergeRequest
  baseRef: Ref
  baseRefName: String!
  baseRefOid: GitObjectID!
  baseRepository: Repository
  body: String!
  bodyHTML: HTML!
  bodyText: String!
  canBeRebased: Boolean!
  changedFiles: Int!
  checksResourcePath: URI!
  checksUrl: URI!
  closed: Boolean!
  closedAt: DateTime
  closingIssuesReferences(userLinkedOnly: IssueConnection, after: IssueConnection, before: IssueConnection, first: IssueConnection, last: IssueConnection, orderBy: IssueConnection): IssueConnection
  comments(orderBy: IssueCommentConnection!, after: IssueCommentConnection!, before: IssueCommentConnection!, first: IssueCommentConnection!, last: IssueCommentConnection!): IssueCommentConnection!
  commits(after: PullRequestCommitConnection!, before: PullRequestCommitConnection!, first: PullRequestCommitConnection!, last: PullRequestCommitConnection!): PullRequestCommitConnection!
  createdAt: DateTime!
  createdViaEmail: Boolean!
  databaseId: Int
  deletions: Int!
  editor: Actor
  files(after: PullRequestChangedFileConnection, before: PullRequestChangedFileConnection, first: PullRequestChangedFileConnection, last: PullRequestChangedFileConnection): PullRequestChangedFileConnection
  fullDatabaseId: BigInt
  headRef: Ref
  headRefName: String!
  headRefOid: GitObjectID!
  headRepository: Repository
  headRepositoryOwner: RepositoryOwner
  hovercard(includeNotificationContexts: Hovercard!): Hovercard!
  id: ID!
  includesCreatedEdit: Boolean!
  isCrossRepository: Boolean!
  isDraft: Boolean!
  isInMergeQueue: Boolean!
  isMergeQueueEnabled: Boolean!
  isReadByViewer: Boolean
  labels(orderBy: LabelConnection, after: LabelConnection, before: LabelConnection, first: LabelConnection, last: LabelConnection): LabelConnection
  lastEditedAt: DateTime
  latestOpinionatedReviews(after: PullRequestReviewConnection, before: PullRequestReviewConnection, first: PullRequestReviewConnection, last: PullRequestReviewConnection, writersOnly: PullRequestReviewConnection): PullRequestReviewConnection
  latestReviews(after: PullRequestReviewConnection, before: PullRequestReviewConnection, first: PullRequestReviewConnection, last: PullRequestReviewConnection): PullRequestReviewConnection
  locked: Boolean!
  maintainerCanModify: Boolean!
  mergeCommit: Commit
  mergeQueue: MergeQueue
  mergeQueueEntry: MergeQueueEntry
  mergeStateStatus: MergeStateStatus!
  mergeable: MergeableState!
  merged: Boolean!
  mergedAt: DateTime
  mergedBy: Actor
  milestone: Milestone
  number: Int!
  participants(after: UserConnection!, before: UserConnection!, first: UserConnection!, last: UserConnection!): UserConnection!
  permalink: URI!
  potentialMergeCommit: Commit
  projectCards(after: ProjectCardConnection!, before: ProjectCardConnection!, first: ProjectCardConnection!, last: ProjectCardConnection!, archivedStates: ProjectCardConnection!): ProjectCardConnection!
  projectItems(includeArchived: ProjectV2ItemConnection!, after: ProjectV2ItemConnection!, before: ProjectV2ItemConnection!, first: ProjectV2ItemConnection!, last: ProjectV2ItemConnection!): ProjectV2ItemConnection!
  projectV2(number: ProjectV2): ProjectV2
  projectsV2(query: ProjectV2Connection!, orderBy: ProjectV2Connection!, after: ProjectV2Connection!, before: ProjectV2Connection!, first: ProjectV2Connection!, last: ProjectV2Connection!): ProjectV2Connection!
  publishedAt: DateTime
  reactionGroups: [ReactionGroup!]
  reactions(after: ReactionConnection!, before: ReactionConnection!, first: ReactionConnection!, last: ReactionConnection!, content: ReactionConnection!, orderBy: ReactionConnection!): ReactionConnection!
  repository: Repository!
  resourcePath: URI!
  revertResourcePath: URI!
  revertUrl: URI!
  reviewDecision: PullRequestReviewDecision
  reviewRequests(after: ReviewRequestConnection, before: ReviewRequestConnection, first: ReviewRequestConnection, last: ReviewRequestConnection): ReviewRequestConnection
  reviewThreads(after: PullRequestReviewThreadConnection!, before: PullRequestReviewThreadConnection!, first: PullRequestReviewThreadConnection!, last: PullRequestReviewThreadConnection!): PullRequestReviewThreadConnection!
  reviews(after: PullRequestReviewConnection, before: PullRequestReviewConnection, first: PullRequestReviewConnection, last: PullRequestReviewConnection, states: PullRequestReviewConnection, author: PullRequestReviewConnection): PullRequestReviewConnection
  state: PullRequestState!
  statusCheckRollup: StatusCheckRollup
  suggestedReviewers: [SuggestedReviewer]!
  timeline(since: PullRequestTimelineConnection!, after: PullRequestTimelineConnection!, before: PullRequestTimelineConnection!, first: PullRequestTimelineConnection!, last: PullRequestTimelineConnection!): PullRequestTimelineConnection!
  timelineItems(since: PullRequestTimelineItemsConnection!, skip: PullRequestTimelineItemsConnection!, itemTypes: PullRequestTimelineItemsConnection!, after: PullRequestTimelineItemsConnection!, before: PullRequestTimelineItemsConnection!, first: PullRequestTimelineItemsConnection!, last: PullRequestTimelineItemsConnection!): PullRequestTimelineItemsConnection!
  title: String!
  titleHTML: HTML!
  totalCommentsCount: Int
  updatedAt: DateTime!
  url: URI!
  userContentEdits(after: UserContentEditConnection, before: UserContentEditConnection, first: UserContentEditConnection, last: UserContentEditConnection): UserContentEditConnection
  viewerCanApplySuggestion: Boolean!
  viewerCanClose: Boolean!
  viewerCanDeleteHeadRef: Boolean!
  viewerCanDisableAutoMerge: Boolean!
  viewerCanEditFiles: Boolean!
  viewerCanEnableAutoMerge: Boolean!
  viewerCanMergeAsAdmin: Boolean!
  viewerCanReact: Boolean!
  viewerCanReopen: Boolean!
  viewerCanSubscribe: Boolean!
  viewerCanUpdate: Boolean!
  viewerCanUpdateBranch: Boolean!
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
  viewerDidAuthor: Boolean!
  viewerLatestReview: PullRequestReview
  viewerLatestReviewRequest: ReviewRequest
  viewerMergeBodyText(mergeType: String!): String!
  viewerMergeHeadlineText(mergeType: String!): String!
  viewerSubscription: SubscriptionState
}

enum PullRequestBranchUpdateMethod {
  MERGE
  REBASE
}

type PullRequestChangedFile {
  additions: Int!
  changeType: PatchStatus!
  deletions: Int!
  path: String!
  viewerViewedState: FileViewedState!
}

type PullRequestChangedFileConnection {
  edges: [PullRequestChangedFileEdge]
  nodes: [PullRequestChangedFile]
  pageInfo: PageInfo!
  totalCount: Int!
}

type PullRequestChangedFileEdge {
  cursor: String!
  node: PullRequestChangedFile
}

type PullRequestCommit implements Node & UniformResourceLocatable {
  commit: Commit!
  id: ID!
  pullRequest: PullRequest!
  resourcePath: URI!
  url: URI!
}

type PullRequestCommitCommentThread implements Node & RepositoryNode {
  comments(after: CommitCommentConnection!, before: CommitCommentConnection!, first: CommitCommentConnection!, last: CommitCommentConnection!): CommitCommentConnection!
  commit: Commit!
  id: ID!
  path: String
  position: Int
  pullRequest: PullRequest!
  repository: Repository!
}

type PullRequestCommitConnection {
  edges: [PullRequestCommitEdge]
  nodes: [PullRequestCommit]
  pageInfo: PageInfo!
  totalCount: Int!
}

type PullRequestCommitEdge {
  cursor: String!
  node: PullRequestCommit
}

type PullRequestConnection {
  edges: [PullRequestEdge]
  nodes: [PullRequest]
  pageInfo: PageInfo!
  totalCount: Int!
}

type PullRequestContributionsByRepository {
  contributions(after: CreatedPullRequestContributionConnection!, before: CreatedPullRequestContributionConnection!, first: CreatedPullRequestContributionConnection!, last: CreatedPullRequestContributionConnection!, orderBy: CreatedPullRequestContributionConnection!): CreatedPullRequestContributionConnection!
  repository: Repository!
}

type PullRequestEdge {
  cursor: String!
  node: PullRequest
}

enum PullRequestMergeMethod {
  MERGE
  SQUASH
  REBASE
}

input PullRequestOrder {
  field: PullRequestOrderField!
  direction: OrderDirection!
}

enum PullRequestOrderField {
  CREATED_AT
  UPDATED_AT
}

type PullRequestParameters {
  dismissStaleReviewsOnPush: Boolean!
  requireCodeOwnerReview: Boolean!
  requireLastPushApproval: Boolean!
  requiredApprovingReviewCount: Int!
  requiredReviewThreadResolution: Boolean!
}

input PullRequestParametersInput {
  dismissStaleReviewsOnPush: Boolean!
  requireCodeOwnerReview: Boolean!
  requireLastPushApproval: Boolean!
  requiredApprovingReviewCount: Int!
  requiredReviewThreadResolution: Boolean!
}

type PullRequestReview implements Comment & Deletable & Minimizable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment {
  author: Actor
  authorAssociation: CommentAuthorAssociation!
  authorCanPushToRepository: Boolean!
  body: String!
  bodyHTML: HTML!
  bodyText: String!
  comments(after: PullRequestReviewCommentConnection!, before: PullRequestReviewCommentConnection!, first: PullRequestReviewCommentConnection!, last: PullRequestReviewCommentConnection!): PullRequestReviewCommentConnection!
  commit: Commit
  createdAt: DateTime!
  createdViaEmail: Boolean!
  databaseId: Int
  editor: Actor
  fullDatabaseId: BigInt
  id: ID!
  includesCreatedEdit: Boolean!
  isMinimized: Boolean!
  lastEditedAt: DateTime
  minimizedReason: String
  onBehalfOf(after: TeamConnection!, before: TeamConnection!, first: TeamConnection!, last: TeamConnection!): TeamConnection!
  publishedAt: DateTime
  pullRequest: PullRequest!
  reactionGroups: [ReactionGroup!]
  reactions(after: ReactionConnection!, before: ReactionConnection!, first: ReactionConnection!, last: ReactionConnection!, content: ReactionConnection!, orderBy: ReactionConnection!): ReactionConnection!
  repository: Repository!
  resourcePath: URI!
  state: PullRequestReviewState!
  submittedAt: DateTime
  updatedAt: DateTime!
  url: URI!
  userContentEdits(after: UserContentEditConnection, before: UserContentEditConnection, first: UserContentEditConnection, last: UserContentEditConnection): UserContentEditConnection
  viewerCanDelete: Boolean!
  viewerCanMinimize: Boolean!
  viewerCanReact: Boolean!
  viewerCanUpdate: Boolean!
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
  viewerDidAuthor: Boolean!
}

type PullRequestReviewComment implements Comment & Deletable & Minimizable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment {
  author: Actor
  authorAssociation: CommentAuthorAssociation!
  body: String!
  bodyHTML: HTML!
  bodyText: String!
  commit: Commit
  createdAt: DateTime!
  createdViaEmail: Boolean!
  databaseId: Int
  diffHunk: String!
  draftedAt: DateTime!
  editor: Actor
  fullDatabaseId: BigInt
  id: ID!
  includesCreatedEdit: Boolean!
  isMinimized: Boolean!
  lastEditedAt: DateTime
  line: Int
  minimizedReason: String
  originalCommit: Commit
  originalLine: Int
  originalPosition: Int!
  originalStartLine: Int
  outdated: Boolean!
  path: String!
  position: Int
  publishedAt: DateTime
  pullRequest: PullRequest!
  pullRequestReview: PullRequestReview
  reactionGroups: [ReactionGroup!]
  reactions(after: ReactionConnection!, before: ReactionConnection!, first: ReactionConnection!, last: ReactionConnection!, content: ReactionConnection!, orderBy: ReactionConnection!): ReactionConnection!
  replyTo: PullRequestReviewComment
  repository: Repository!
  resourcePath: URI!
  startLine: Int
  state: PullRequestReviewCommentState!
  subjectType: PullRequestReviewThreadSubjectType!
  updatedAt: DateTime!
  url: URI!
  userContentEdits(after: UserContentEditConnection, before: UserContentEditConnection, first: UserContentEditConnection, last: UserContentEditConnection): UserContentEditConnection
  viewerCanDelete: Boolean!
  viewerCanMinimize: Boolean!
  viewerCanReact: Boolean!
  viewerCanUpdate: Boolean!
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
  viewerDidAuthor: Boolean!
}

type PullRequestReviewCommentConnection {
  edges: [PullRequestReviewCommentEdge]
  nodes: [PullRequestReviewComment]
  pageInfo: PageInfo!
  totalCount: Int!
}

type PullRequestReviewCommentEdge {
  cursor: String!
  node: PullRequestReviewComment
}

enum PullRequestReviewCommentState {
  PENDING
  SUBMITTED
}

type PullRequestReviewConnection {
  edges: [PullRequestReviewEdge]
  nodes: [PullRequestReview]
  pageInfo: PageInfo!
  totalCount: Int!
}

type PullRequestReviewContributionsByRepository {
  contributions(after: CreatedPullRequestReviewContributionConnection!, before: CreatedPullRequestReviewContributionConnection!, first: CreatedPullRequestReviewContributionConnection!, last: CreatedPullRequestReviewContributionConnection!, orderBy: CreatedPullRequestReviewContributionConnection!): CreatedPullRequestReviewContributionConnection!
  repository: Repository!
}

enum PullRequestReviewDecision {
  CHANGES_REQUESTED
  APPROVED
  REVIEW_REQUIRED
}

type PullRequestReviewEdge {
  cursor: String!
  node: PullRequestReview
}

enum PullRequestReviewEvent {
  COMMENT
  APPROVE
  REQUEST_CHANGES
  DISMISS
}

enum PullRequestReviewState {
  PENDING
  COMMENTED
  APPROVED
  CHANGES_REQUESTED
  DISMISSED
}

type PullRequestReviewThread implements Node {
  comments(after: PullRequestReviewCommentConnection!, before: PullRequestReviewCommentConnection!, first: PullRequestReviewCommentConnection!, last: PullRequestReviewCommentConnection!, skip: PullRequestReviewCommentConnection!): PullRequestReviewCommentConnection!
  diffSide: DiffSide!
  id: ID!
  isCollapsed: Boolean!
  isOutdated: Boolean!
  isResolved: Boolean!
  line: Int
  originalLine: Int
  originalStartLine: Int
  path: String!
  pullRequest: PullRequest!
  repository: Repository!
  resolvedBy: User
  startDiffSide: DiffSide
  startLine: Int
  subjectType: PullRequestReviewThreadSubjectType!
  viewerCanReply: Boolean!
  viewerCanResolve: Boolean!
  viewerCanUnresolve: Boolean!
}

type PullRequestReviewThreadConnection {
  edges: [PullRequestReviewThreadEdge]
  nodes: [PullRequestReviewThread]
  pageInfo: PageInfo!
  totalCount: Int!
}

type PullRequestReviewThreadEdge {
  cursor: String!
  node: PullRequestReviewThread
}

enum PullRequestReviewThreadSubjectType {
  LINE
  FILE
}

type PullRequestRevisionMarker {
  createdAt: DateTime!
  lastSeenCommit: Commit!
  pullRequest: PullRequest!
}

enum PullRequestState {
  OPEN
  CLOSED
  MERGED
}

type PullRequestTemplate {
  body: String
  filename: String
  repository: Repository!
}

type PullRequestThread implements Node {
  comments(after: PullRequestReviewCommentConnection!, before: PullRequestReviewCommentConnection!, first: PullRequestReviewCommentConnection!, last: PullRequestReviewCommentConnection!, skip: PullRequestReviewCommentConnection!): PullRequestReviewCommentConnection!
  diffSide: DiffSide!
  id: ID!
  isCollapsed: Boolean!
  isOutdated: Boolean!
  isResolved: Boolean!
  line: Int
  path: String!
  pullRequest: PullRequest!
  repository: Repository!
  resolvedBy: User
  startDiffSide: DiffSide
  startLine: Int
  subjectType: PullRequestReviewThreadSubjectType!
  viewerCanReply: Boolean!
  viewerCanResolve: Boolean!
  viewerCanUnresolve: Boolean!
}

type PullRequestTimelineConnection {
  edges: [PullRequestTimelineItemEdge]
  nodes: [PullRequestTimelineItem]
  pageInfo: PageInfo!
  totalCount: Int!
}

union PullRequestTimelineItem = AssignedEvent | BaseRefDeletedEvent | BaseRefForcePushedEvent | ClosedEvent | Commit | CommitCommentThread | CrossReferencedEvent | DemilestonedEvent | DeployedEvent | DeploymentEnvironmentChangedEvent | HeadRefDeletedEvent | HeadRefForcePushedEvent | HeadRefRestoredEvent | IssueComment | LabeledEvent | LockedEvent | MergedEvent | MilestonedEvent | PullRequestReview | PullRequestReviewComment | PullRequestReviewThread | ReferencedEvent | RenamedTitleEvent | ReopenedEvent | ReviewDismissedEvent | ReviewRequestRemovedEvent | ReviewRequestedEvent | SubscribedEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnsubscribedEvent | UserBlockedEvent

type PullRequestTimelineItemEdge {
  cursor: String!
  node: PullRequestTimelineItem
}

union PullRequestTimelineItems = AddedToMergeQueueEvent | AddedToProjectEvent | AssignedEvent | AutoMergeDisabledEvent | AutoMergeEnabledEvent | AutoRebaseEnabledEvent | AutoSquashEnabledEvent | AutomaticBaseChangeFailedEvent | AutomaticBaseChangeSucceededEvent | BaseRefChangedEvent | BaseRefDeletedEvent | BaseRefForcePushedEvent | ClosedEvent | CommentDeletedEvent | ConnectedEvent | ConvertToDraftEvent | ConvertedNoteToIssueEvent | ConvertedToDiscussionEvent | CrossReferencedEvent | DemilestonedEvent | DeployedEvent | DeploymentEnvironmentChangedEvent | DisconnectedEvent | HeadRefDeletedEvent | HeadRefForcePushedEvent | HeadRefRestoredEvent | IssueComment | LabeledEvent | LockedEvent | MarkedAsDuplicateEvent | MentionedEvent | MergedEvent | MilestonedEvent | MovedColumnsInProjectEvent | PinnedEvent | PullRequestCommit | PullRequestCommitCommentThread | PullRequestReview | PullRequestReviewThread | PullRequestRevisionMarker | ReadyForReviewEvent | ReferencedEvent | RemovedFromMergeQueueEvent | RemovedFromProjectEvent | RenamedTitleEvent | ReopenedEvent | ReviewDismissedEvent | ReviewRequestRemovedEvent | ReviewRequestedEvent | SubscribedEvent | TransferredEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnmarkedAsDuplicateEvent | UnpinnedEvent | UnsubscribedEvent | UserBlockedEvent

type PullRequestTimelineItemsConnection {
  edges: [PullRequestTimelineItemsEdge]
  filteredCount: Int!
  nodes: [PullRequestTimelineItems]
  pageCount: Int!
  pageInfo: PageInfo!
  totalCount: Int!
  updatedAt: DateTime!
}

type PullRequestTimelineItemsEdge {
  cursor: String!
  node: PullRequestTimelineItems
}

enum PullRequestTimelineItemsItemType {
  PULL_REQUEST_COMMIT
  PULL_REQUEST_COMMIT_COMMENT_THREAD
  PULL_REQUEST_REVIEW
  PULL_REQUEST_REVIEW_THREAD
  PULL_REQUEST_REVISION_MARKER
  AUTOMATIC_BASE_CHANGE_FAILED_EVENT
  AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT
  AUTO_MERGE_DISABLED_EVENT
  AUTO_MERGE_ENABLED_EVENT
  AUTO_REBASE_ENABLED_EVENT
  AUTO_SQUASH_ENABLED_EVENT
  BASE_REF_CHANGED_EVENT
  BASE_REF_FORCE_PUSHED_EVENT
  BASE_REF_DELETED_EVENT
  DEPLOYED_EVENT
  DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT
  HEAD_REF_DELETED_EVENT
  HEAD_REF_FORCE_PUSHED_EVENT
  HEAD_REF_RESTORED_EVENT
  MERGED_EVENT
  REVIEW_DISMISSED_EVENT
  REVIEW_REQUESTED_EVENT
  REVIEW_REQUEST_REMOVED_EVENT
  READY_FOR_REVIEW_EVENT
  CONVERT_TO_DRAFT_EVENT
  ADDED_TO_MERGE_QUEUE_EVENT
  REMOVED_FROM_MERGE_QUEUE_EVENT
  ISSUE_COMMENT
  CROSS_REFERENCED_EVENT
  ADDED_TO_PROJECT_EVENT
  ASSIGNED_EVENT
  CLOSED_EVENT
  COMMENT_DELETED_EVENT
  CONNECTED_EVENT
  CONVERTED_NOTE_TO_ISSUE_EVENT
  CONVERTED_TO_DISCUSSION_EVENT
  DEMILESTONED_EVENT
  DISCONNECTED_EVENT
  LABELED_EVENT
  LOCKED_EVENT
  MARKED_AS_DUPLICATE_EVENT
  MENTIONED_EVENT
  MILESTONED_EVENT
  MOVED_COLUMNS_IN_PROJECT_EVENT
  PINNED_EVENT
  REFERENCED_EVENT
  REMOVED_FROM_PROJECT_EVENT
  RENAMED_TITLE_EVENT
  REOPENED_EVENT
  SUBSCRIBED_EVENT
  TRANSFERRED_EVENT
  UNASSIGNED_EVENT
  UNLABELED_EVENT
  UNLOCKED_EVENT
  USER_BLOCKED_EVENT
  UNMARKED_AS_DUPLICATE_EVENT
  UNPINNED_EVENT
  UNSUBSCRIBED_EVENT
}

enum PullRequestUpdateState {
  OPEN
  CLOSED
}

type Push implements Node {
  id: ID!
  nextSha: GitObjectID
  permalink: URI!
  previousSha: GitObjectID
  pusher: Actor!
  repository: Repository!
}

type PushAllowance implements Node {
  actor: PushAllowanceActor
  branchProtectionRule: BranchProtectionRule
  id: ID!
}

union PushAllowanceActor = App | Team | User

type PushAllowanceConnection {
  edges: [PushAllowanceEdge]
  nodes: [PushAllowance]
  pageInfo: PageInfo!
  totalCount: Int!
}

type PushAllowanceEdge {
  cursor: String!
  node: PushAllowance
}

type Query {
  codeOfConduct(key: CodeOfConduct): CodeOfConduct
  codesOfConduct: [CodeOfConduct]
  enterprise(slug: Enterprise, invitationToken: Enterprise): Enterprise
  enterpriseAdministratorInvitation(userLogin: EnterpriseAdministratorInvitation, enterpriseSlug: EnterpriseAdministratorInvitation, role: EnterpriseAdministratorInvitation): EnterpriseAdministratorInvitation
  enterpriseAdministratorInvitationByToken(invitationToken: EnterpriseAdministratorInvitation): EnterpriseAdministratorInvitation
  license(key: License): License
  licenses: [License]!
  marketplaceCategories(includeCategories: [MarketplaceCategory!]!, excludeEmpty: [MarketplaceCategory!]!, excludeSubcategories: [MarketplaceCategory!]!): [MarketplaceCategory!]!
  marketplaceCategory(slug: MarketplaceCategory, useTopicAliases: MarketplaceCategory): MarketplaceCategory
  marketplaceListing(slug: MarketplaceListing): MarketplaceListing
  marketplaceListings(after: MarketplaceListingConnection!, before: MarketplaceListingConnection!, first: MarketplaceListingConnection!, last: MarketplaceListingConnection!, categorySlug: MarketplaceListingConnection!, useTopicAliases: MarketplaceListingConnection!, viewerCanAdmin: MarketplaceListingConnection!, adminId: MarketplaceListingConnection!, organizationId: MarketplaceListingConnection!, allStates: MarketplaceListingConnection!, slugs: MarketplaceListingConnection!, primaryCategoryOnly: MarketplaceListingConnection!, withFreeTrialsOnly: MarketplaceListingConnection!): MarketplaceListingConnection!
  meta: GitHubMetadata!
  node(id: Node): Node
  nodes(ids: [Node]!): [Node]!
  organization(login: Organization): Organization
  rateLimit(dryRun: RateLimit): RateLimit
  relay: Query!
  repository(owner: Repository, name: Repository, followRenames: Repository): Repository
  repositoryOwner(login: RepositoryOwner): RepositoryOwner
  resource(url: UniformResourceLocatable): UniformResourceLocatable
  search(after: SearchResultItemConnection!, before: SearchResultItemConnection!, first: SearchResultItemConnection!, last: SearchResultItemConnection!, query: SearchResultItemConnection!, type: SearchResultItemConnection!): SearchResultItemConnection!
  securityAdvisories(orderBy: SecurityAdvisoryConnection!, identifier: SecurityAdvisoryConnection!, publishedSince: SecurityAdvisoryConnection!, updatedSince: SecurityAdvisoryConnection!, classifications: SecurityAdvisoryConnection!, after: SecurityAdvisoryConnection!, before: SecurityAdvisoryConnection!, first: SecurityAdvisoryConnection!, last: SecurityAdvisoryConnection!): SecurityAdvisoryConnection!
  securityAdvisory(ghsaId: SecurityAdvisory): SecurityAdvisory
  securityVulnerabilities(orderBy: SecurityVulnerabilityConnection!, ecosystem: SecurityVulnerabilityConnection!, package: SecurityVulnerabilityConnection!, severities: SecurityVulnerabilityConnection!, classifications: SecurityVulnerabilityConnection!, after: SecurityVulnerabilityConnection!, before: SecurityVulnerabilityConnection!, first: SecurityVulnerabilityConnection!, last: SecurityVulnerabilityConnection!): SecurityVulnerabilityConnection!
  sponsorables(after: SponsorableItemConnection!, before: SponsorableItemConnection!, first: SponsorableItemConnection!, last: SponsorableItemConnection!, orderBy: SponsorableItemConnection!, onlyDependencies: SponsorableItemConnection!, orgLoginForDependencies: SponsorableItemConnection!, dependencyEcosystem: SponsorableItemConnection!, ecosystem: SponsorableItemConnection!): SponsorableItemConnection!
  topic(name: Topic): Topic
  user(login: User): User
  viewer: User!
}

type RateLimit {
  cost: Int!
  limit: Int!
  nodeCount: Int!
  remaining: Int!
  resetAt: DateTime!
  used: Int!
}

interface Reactable {
  databaseId: Int
  id: ID!
  reactionGroups: [ReactionGroup!]
  reactions(after: ReactionConnection!, before: ReactionConnection!, first: ReactionConnection!, last: ReactionConnection!, content: ReactionConnection!, orderBy: ReactionConnection!): ReactionConnection!
  viewerCanReact: Boolean!
}

type ReactingUserConnection {
  edges: [ReactingUserEdge]
  nodes: [User]
  pageInfo: PageInfo!
  totalCount: Int!
}

type ReactingUserEdge {
  cursor: String!
  node: User!
  reactedAt: DateTime!
}

type Reaction implements Node {
  content: ReactionContent!
  createdAt: DateTime!
  databaseId: Int
  id: ID!
  reactable: Reactable!
  user: User
}

type ReactionConnection {
  edges: [ReactionEdge]
  nodes: [Reaction]
  pageInfo: PageInfo!
  totalCount: Int!
  viewerHasReacted: Boolean!
}

enum ReactionContent {
  THUMBS_UP
  THUMBS_DOWN
  LAUGH
  HOORAY
  CONFUSED
  HEART
  ROCKET
  EYES
}

type ReactionEdge {
  cursor: String!
  node: Reaction
}

type ReactionGroup {
  content: ReactionContent!
  createdAt: DateTime
  reactors(after: ReactorConnection!, before: ReactorConnection!, first: ReactorConnection!, last: ReactorConnection!): ReactorConnection!
  subject: Reactable!
  users(after: ReactingUserConnection!, before: ReactingUserConnection!, first: ReactingUserConnection!, last: ReactingUserConnection!): ReactingUserConnection!
  viewerHasReacted: Boolean!
}

input ReactionOrder {
  field: ReactionOrderField!
  direction: OrderDirection!
}

enum ReactionOrderField {
  CREATED_AT
}

union Reactor = Bot | Mannequin | Organization | User

type ReactorConnection {
  edges: [ReactorEdge]
  nodes: [Reactor]
  pageInfo: PageInfo!
  totalCount: Int!
}

type ReactorEdge {
  cursor: String!
  node: Reactor!
  reactedAt: DateTime!
}

type ReadyForReviewEvent implements Node & UniformResourceLocatable {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  pullRequest: PullRequest!
  resourcePath: URI!
  url: URI!
}

type Ref implements Node {
  associatedPullRequests(states: PullRequestConnection!, labels: PullRequestConnection!, headRefName: PullRequestConnection!, baseRefName: PullRequestConnection!, orderBy: PullRequestConnection!, after: PullRequestConnection!, before: PullRequestConnection!, first: PullRequestConnection!, last: PullRequestConnection!): PullRequestConnection!
  branchProtectionRule: BranchProtectionRule
  compare(headRef: Comparison): Comparison
  id: ID!
  name: String!
  prefix: String!
  refUpdateRule: RefUpdateRule
  repository: Repository!
  rules(after: RepositoryRuleConnection, before: RepositoryRuleConnection, first: RepositoryRuleConnection, last: RepositoryRuleConnection, orderBy: RepositoryRuleConnection): RepositoryRuleConnection
  target: GitObject
}

type RefConnection {
  edges: [RefEdge]
  nodes: [Ref]
  pageInfo: PageInfo!
  totalCount: Int!
}

type RefEdge {
  cursor: String!
  node: Ref
}

type RefNameConditionTarget {
  exclude: [String!]!
  include: [String!]!
}

input RefNameConditionTargetInput {
  exclude: []!
  include: []!
}

input RefOrder {
  field: RefOrderField!
  direction: OrderDirection!
}

enum RefOrderField {
  TAG_COMMIT_DATE
  ALPHABETICAL
}

input RefUpdate {
  name: GitRefname!
  afterOid: GitObjectID!
  beforeOid: GitObjectID
  force: Boolean
}

type RefUpdateRule {
  allowsDeletions: Boolean!
  allowsForcePushes: Boolean!
  blocksCreations: Boolean!
  pattern: String!
  requiredApprovingReviewCount: Int
  requiredStatusCheckContexts: [String]
  requiresCodeOwnerReviews: Boolean!
  requiresConversationResolution: Boolean!
  requiresLinearHistory: Boolean!
  requiresSignatures: Boolean!
  viewerAllowedToDismissReviews: Boolean!
  viewerCanPush: Boolean!
}

type ReferencedEvent implements Node {
  actor: Actor
  commit: Commit
  commitRepository: Repository!
  createdAt: DateTime!
  id: ID!
  isCrossRepository: Boolean!
  isDirectReference: Boolean!
  subject: ReferencedSubject!
}

union ReferencedSubject = Issue | PullRequest

input RegenerateEnterpriseIdentityProviderRecoveryCodesInput {
  clientMutationId: String
  enterpriseId: ID!
}

type RegenerateEnterpriseIdentityProviderRecoveryCodesPayload {
  clientMutationId: String
  identityProvider: EnterpriseIdentityProvider
}

input RegenerateVerifiableDomainTokenInput {
  clientMutationId: String
  id: ID!
}

type RegenerateVerifiableDomainTokenPayload {
  clientMutationId: String
  verificationToken: String
}

input RejectDeploymentsInput {
  clientMutationId: String
  workflowRunId: ID!
  environmentIds: []!
  comment: String
}

type RejectDeploymentsPayload {
  clientMutationId: String
  deployments: [Deployment!]
}

type Release implements Node & Reactable & UniformResourceLocatable {
  author: User
  createdAt: DateTime!
  databaseId: Int
  description: String
  descriptionHTML: HTML
  id: ID!
  isDraft: Boolean!
  isLatest: Boolean!
  isPrerelease: Boolean!
  mentions(after: UserConnection, before: UserConnection, first: UserConnection, last: UserConnection): UserConnection
  name: String
  publishedAt: DateTime
  reactionGroups: [ReactionGroup!]
  reactions(after: ReactionConnection!, before: ReactionConnection!, first: ReactionConnection!, last: ReactionConnection!, content: ReactionConnection!, orderBy: ReactionConnection!): ReactionConnection!
  releaseAssets(after: ReleaseAssetConnection!, before: ReleaseAssetConnection!, first: ReleaseAssetConnection!, last: ReleaseAssetConnection!, name: ReleaseAssetConnection!): ReleaseAssetConnection!
  repository: Repository!
  resourcePath: URI!
  shortDescriptionHTML(limit: HTML): HTML
  tag: Ref
  tagCommit: Commit
  tagName: String!
  updatedAt: DateTime!
  url: URI!
  viewerCanReact: Boolean!
}

type ReleaseAsset implements Node {
  contentType: String!
  createdAt: DateTime!
  downloadCount: Int!
  downloadUrl: URI!
  id: ID!
  name: String!
  release: Release
  size: Int!
  updatedAt: DateTime!
  uploadedBy: User!
  url: URI!
}

type ReleaseAssetConnection {
  edges: [ReleaseAssetEdge]
  nodes: [ReleaseAsset]
  pageInfo: PageInfo!
  totalCount: Int!
}

type ReleaseAssetEdge {
  cursor: String!
  node: ReleaseAsset
}

type ReleaseConnection {
  edges: [ReleaseEdge]
  nodes: [Release]
  pageInfo: PageInfo!
  totalCount: Int!
}

type ReleaseEdge {
  cursor: String!
  node: Release
}

input ReleaseOrder {
  field: ReleaseOrderField!
  direction: OrderDirection!
}

enum ReleaseOrderField {
  CREATED_AT
  NAME
}

input RemoveAssigneesFromAssignableInput {
  clientMutationId: String
  assignableId: ID!
  assigneeIds: []!
}

type RemoveAssigneesFromAssignablePayload {
  assignable: Assignable
  clientMutationId: String
}

input RemoveEnterpriseAdminInput {
  clientMutationId: String
  enterpriseId: ID!
  login: String!
}

type RemoveEnterpriseAdminPayload {
  admin: User
  clientMutationId: String
  enterprise: Enterprise
  message: String
  viewer: User
}

input RemoveEnterpriseIdentityProviderInput {
  clientMutationId: String
  enterpriseId: ID!
}

type RemoveEnterpriseIdentityProviderPayload {
  clientMutationId: String
  identityProvider: EnterpriseIdentityProvider
}

input RemoveEnterpriseMemberInput {
  clientMutationId: String
  enterpriseId: ID!
  userId: ID!
}

type RemoveEnterpriseMemberPayload {
  clientMutationId: String
  enterprise: Enterprise
  user: User
  viewer: User
}

input RemoveEnterpriseOrganizationInput {
  clientMutationId: String
  enterpriseId: ID!
  organizationId: ID!
}

type RemoveEnterpriseOrganizationPayload {
  clientMutationId: String
  enterprise: Enterprise
  organization: Organization
  viewer: User
}

input RemoveEnterpriseSupportEntitlementInput {
  clientMutationId: String
  enterpriseId: ID!
  login: String!
}

type RemoveEnterpriseSupportEntitlementPayload {
  clientMutationId: String
  message: String
}

input RemoveLabelsFromLabelableInput {
  clientMutationId: String
  labelableId: ID!
  labelIds: []!
}

type RemoveLabelsFromLabelablePayload {
  clientMutationId: String
  labelable: Labelable
}

input RemoveOutsideCollaboratorInput {
  clientMutationId: String
  userId: ID!
  organizationId: ID!
}

type RemoveOutsideCollaboratorPayload {
  clientMutationId: String
  removedUser: User
}

input RemoveReactionInput {
  clientMutationId: String
  subjectId: ID!
  content: ReactionContent!
}

type RemoveReactionPayload {
  clientMutationId: String
  reaction: Reaction
  reactionGroups: [ReactionGroup!]
  subject: Reactable
}

input RemoveStarInput {
  clientMutationId: String
  starrableId: ID!
}

type RemoveStarPayload {
  clientMutationId: String
  starrable: Starrable
}

input RemoveUpvoteInput {
  clientMutationId: String
  subjectId: ID!
}

type RemoveUpvotePayload {
  clientMutationId: String
  subject: Votable
}

type RemovedFromMergeQueueEvent implements Node {
  actor: Actor
  beforeCommit: Commit
  createdAt: DateTime!
  enqueuer: User
  id: ID!
  mergeQueue: MergeQueue
  pullRequest: PullRequest
  reason: String
}

type RemovedFromProjectEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  databaseId: Int
  id: ID!
  project: Project
  projectColumnName: String!
}

type RenamedTitleEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  currentTitle: String!
  id: ID!
  previousTitle: String!
  subject: RenamedTitleSubject!
}

union RenamedTitleSubject = Issue | PullRequest

input ReopenDiscussionInput {
  clientMutationId: String
  discussionId: ID!
}

type ReopenDiscussionPayload {
  clientMutationId: String
  discussion: Discussion
}

input ReopenIssueInput {
  clientMutationId: String
  issueId: ID!
}

type ReopenIssuePayload {
  clientMutationId: String
  issue: Issue
}

input ReopenPullRequestInput {
  clientMutationId: String
  pullRequestId: ID!
}

type ReopenPullRequestPayload {
  clientMutationId: String
  pullRequest: PullRequest
}

type ReopenedEvent implements Node {
  actor: Actor
  closable: Closable!
  createdAt: DateTime!
  id: ID!
  stateReason: IssueStateReason
}

input ReorderEnvironmentInput {
  clientMutationId: String
  environmentId: ID!
  position: Int!
}

type ReorderEnvironmentPayload {
  clientMutationId: String
  environment: Environment
}

type RepoAccessAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
  visibility: RepoAccessAuditEntryVisibility
}

enum RepoAccessAuditEntryVisibility {
  INTERNAL
  PRIVATE
  PUBLIC
}

type RepoAddMemberAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
  visibility: RepoAddMemberAuditEntryVisibility
}

enum RepoAddMemberAuditEntryVisibility {
  INTERNAL
  PRIVATE
  PUBLIC
}

type RepoAddTopicAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & TopicAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  topic: Topic
  topicName: String
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type RepoArchivedAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
  visibility: RepoArchivedAuditEntryVisibility
}

enum RepoArchivedAuditEntryVisibility {
  INTERNAL
  PRIVATE
  PUBLIC
}

type RepoChangeMergeSettingAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  isEnabled: Boolean
  mergeType: RepoChangeMergeSettingAuditEntryMergeType
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

enum RepoChangeMergeSettingAuditEntryMergeType {
  MERGE
  REBASE
  SQUASH
}

type RepoConfigDisableAnonymousGitAccessAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type RepoConfigDisableCollaboratorsOnlyAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type RepoConfigDisableContributorsOnlyAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type RepoConfigDisableSockpuppetDisallowedAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type RepoConfigEnableAnonymousGitAccessAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type RepoConfigEnableCollaboratorsOnlyAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type RepoConfigEnableContributorsOnlyAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type RepoConfigEnableSockpuppetDisallowedAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type RepoConfigLockAnonymousGitAccessAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type RepoConfigUnlockAnonymousGitAccessAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type RepoCreateAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  forkParentName: String
  forkSourceName: String
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
  visibility: RepoCreateAuditEntryVisibility
}

enum RepoCreateAuditEntryVisibility {
  INTERNAL
  PRIVATE
  PUBLIC
}

type RepoDestroyAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
  visibility: RepoDestroyAuditEntryVisibility
}

enum RepoDestroyAuditEntryVisibility {
  INTERNAL
  PRIVATE
  PUBLIC
}

type RepoRemoveMemberAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
  visibility: RepoRemoveMemberAuditEntryVisibility
}

enum RepoRemoveMemberAuditEntryVisibility {
  INTERNAL
  PRIVATE
  PUBLIC
}

type RepoRemoveTopicAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & TopicAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  topic: Topic
  topicName: String
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

enum ReportedContentClassifiers {
  SPAM
  ABUSE
  OFF_TOPIC
  OUTDATED
  DUPLICATE
  RESOLVED
}

type Repository implements Node & PackageOwner & ProjectOwner & ProjectV2Recent & RepositoryInfo & Starrable & Subscribable & UniformResourceLocatable {
  allowUpdateBranch: Boolean!
  archivedAt: DateTime
  assignableUsers(query: UserConnection!, after: UserConnection!, before: UserConnection!, first: UserConnection!, last: UserConnection!): UserConnection!
  autoMergeAllowed: Boolean!
  branchProtectionRules(after: BranchProtectionRuleConnection!, before: BranchProtectionRuleConnection!, first: BranchProtectionRuleConnection!, last: BranchProtectionRuleConnection!): BranchProtectionRuleConnection!
  codeOfConduct: CodeOfConduct
  codeowners(refName: RepositoryCodeowners): RepositoryCodeowners
  collaborators(affiliation: RepositoryCollaboratorConnection, login: RepositoryCollaboratorConnection, query: RepositoryCollaboratorConnection, after: RepositoryCollaboratorConnection, before: RepositoryCollaboratorConnection, first: RepositoryCollaboratorConnection, last: RepositoryCollaboratorConnection): RepositoryCollaboratorConnection
  commitComments(after: CommitCommentConnection!, before: CommitCommentConnection!, first: CommitCommentConnection!, last: CommitCommentConnection!): CommitCommentConnection!
  contactLinks: [RepositoryContactLink!]
  contributingGuidelines: ContributingGuidelines
  createdAt: DateTime!
  databaseId: Int
  defaultBranchRef: Ref
  deleteBranchOnMerge: Boolean!
  dependencyGraphManifests(after: DependencyGraphManifestConnection, before: DependencyGraphManifestConnection, first: DependencyGraphManifestConnection, last: DependencyGraphManifestConnection, withDependencies: DependencyGraphManifestConnection, dependenciesFirst: DependencyGraphManifestConnection, dependenciesAfter: DependencyGraphManifestConnection): DependencyGraphManifestConnection
  deployKeys(after: DeployKeyConnection!, before: DeployKeyConnection!, first: DeployKeyConnection!, last: DeployKeyConnection!): DeployKeyConnection!
  deployments(environments: DeploymentConnection!, orderBy: DeploymentConnection!, after: DeploymentConnection!, before: DeploymentConnection!, first: DeploymentConnection!, last: DeploymentConnection!): DeploymentConnection!
  description: String
  descriptionHTML: HTML!
  discussion(number: Discussion): Discussion
  discussionCategories(after: DiscussionCategoryConnection!, before: DiscussionCategoryConnection!, first: DiscussionCategoryConnection!, last: DiscussionCategoryConnection!, filterByAssignable: DiscussionCategoryConnection!): DiscussionCategoryConnection!
  discussionCategory(slug: DiscussionCategory): DiscussionCategory
  discussions(after: DiscussionConnection!, before: DiscussionConnection!, first: DiscussionConnection!, last: DiscussionConnection!, categoryId: DiscussionConnection!, states: DiscussionConnection!, orderBy: DiscussionConnection!, answered: DiscussionConnection!): DiscussionConnection!
  diskUsage: Int
  environment(name: Environment): Environment
  environments(after: EnvironmentConnection!, before: EnvironmentConnection!, first: EnvironmentConnection!, last: EnvironmentConnection!, orderBy: EnvironmentConnection!, pinnedEnvironmentFilter: EnvironmentConnection!, names: EnvironmentConnection!): EnvironmentConnection!
  forkCount: Int!
  forkingAllowed: Boolean!
  forks(privacy: RepositoryConnection!, visibility: RepositoryConnection!, orderBy: RepositoryConnection!, affiliations: RepositoryConnection!, ownerAffiliations: RepositoryConnection!, isLocked: RepositoryConnection!, hasIssuesEnabled: RepositoryConnection!, after: RepositoryConnection!, before: RepositoryConnection!, first: RepositoryConnection!, last: RepositoryConnection!): RepositoryConnection!
  fundingLinks: [FundingLink!]!
  hasDiscussionsEnabled: Boolean!
  hasIssuesEnabled: Boolean!
  hasProjectsEnabled: Boolean!
  hasSponsorshipsEnabled: Boolean!
  hasVulnerabilityAlertsEnabled: Boolean!
  hasWikiEnabled: Boolean!
  homepageUrl: URI
  id: ID!
  interactionAbility: RepositoryInteractionAbility
  isArchived: Boolean!
  isBlankIssuesEnabled: Boolean!
  isDisabled: Boolean!
  isEmpty: Boolean!
  isFork: Boolean!
  isInOrganization: Boolean!
  isLocked: Boolean!
  isMirror: Boolean!
  isPrivate: Boolean!
  isSecurityPolicyEnabled: Boolean
  isTemplate: Boolean!
  isUserConfigurationRepository: Boolean!
  issue(number: Issue): Issue
  issueOrPullRequest(number: IssueOrPullRequest): IssueOrPullRequest
  issueTemplates: [IssueTemplate!]
  issues(orderBy: IssueConnection!, labels: IssueConnection!, states: IssueConnection!, filterBy: IssueConnection!, after: IssueConnection!, before: IssueConnection!, first: IssueConnection!, last: IssueConnection!): IssueConnection!
  label(name: Label): Label
  labels(orderBy: LabelConnection, after: LabelConnection, before: LabelConnection, first: LabelConnection, last: LabelConnection, query: LabelConnection): LabelConnection
  languages(after: LanguageConnection, before: LanguageConnection, first: LanguageConnection, last: LanguageConnection, orderBy: LanguageConnection): LanguageConnection
  latestRelease: Release
  licenseInfo: License
  lockReason: RepositoryLockReason
  mentionableUsers(query: UserConnection!, after: UserConnection!, before: UserConnection!, first: UserConnection!, last: UserConnection!): UserConnection!
  mergeCommitAllowed: Boolean!
  mergeCommitMessage: MergeCommitMessage!
  mergeCommitTitle: MergeCommitTitle!
  mergeQueue(branch: MergeQueue): MergeQueue
  milestone(number: Milestone): Milestone
  milestones(after: MilestoneConnection, before: MilestoneConnection, first: MilestoneConnection, last: MilestoneConnection, states: MilestoneConnection, orderBy: MilestoneConnection, query: MilestoneConnection): MilestoneConnection
  mirrorUrl: URI
  name: String!
  nameWithOwner: String!
  object(oid: GitObject, expression: GitObject): GitObject
  openGraphImageUrl: URI!
  owner: RepositoryOwner!
  packages(after: PackageConnection!, before: PackageConnection!, first: PackageConnection!, last: PackageConnection!, names: PackageConnection!, repositoryId: PackageConnection!, packageType: PackageConnection!, orderBy: PackageConnection!): PackageConnection!
  parent: Repository
  pinnedDiscussions(after: PinnedDiscussionConnection!, before: PinnedDiscussionConnection!, first: PinnedDiscussionConnection!, last: PinnedDiscussionConnection!): PinnedDiscussionConnection!
  pinnedEnvironments(after: PinnedEnvironmentConnection, before: PinnedEnvironmentConnection, first: PinnedEnvironmentConnection, last: PinnedEnvironmentConnection, orderBy: PinnedEnvironmentConnection): PinnedEnvironmentConnection
  pinnedIssues(after: PinnedIssueConnection, before: PinnedIssueConnection, first: PinnedIssueConnection, last: PinnedIssueConnection): PinnedIssueConnection
  planFeatures: RepositoryPlanFeatures!
  primaryLanguage: Language
  project(number: Project): Project
  projectV2(number: ProjectV2): ProjectV2
  projects(orderBy: ProjectConnection!, search: ProjectConnection!, states: ProjectConnection!, after: ProjectConnection!, before: ProjectConnection!, first: ProjectConnection!, last: ProjectConnection!): ProjectConnection!
  projectsResourcePath: URI!
  projectsUrl: URI!
  projectsV2(after: ProjectV2Connection!, before: ProjectV2Connection!, first: ProjectV2Connection!, last: ProjectV2Connection!, query: ProjectV2Connection!, orderBy: ProjectV2Connection!): ProjectV2Connection!
  pullRequest(number: PullRequest): PullRequest
  pullRequestTemplates: [PullRequestTemplate!]
  pullRequests(states: PullRequestConnection!, labels: PullRequestConnection!, headRefName: PullRequestConnection!, baseRefName: PullRequestConnection!, orderBy: PullRequestConnection!, after: PullRequestConnection!, before: PullRequestConnection!, first: PullRequestConnection!, last: PullRequestConnection!): PullRequestConnection!
  pushedAt: DateTime
  rebaseMergeAllowed: Boolean!
  recentProjects(after: ProjectV2Connection!, before: ProjectV2Connection!, first: ProjectV2Connection!, last: ProjectV2Connection!): ProjectV2Connection!
  ref(qualifiedName: Ref): Ref
  refs(query: RefConnection, after: RefConnection, before: RefConnection, first: RefConnection, last: RefConnection, refPrefix: RefConnection, direction: RefConnection, orderBy: RefConnection): RefConnection
  release(tagName: Release): Release
  releases(after: ReleaseConnection!, before: ReleaseConnection!, first: ReleaseConnection!, last: ReleaseConnection!, orderBy: ReleaseConnection!): ReleaseConnection!
  repositoryTopics(after: RepositoryTopicConnection!, before: RepositoryTopicConnection!, first: RepositoryTopicConnection!, last: RepositoryTopicConnection!): RepositoryTopicConnection!
  resourcePath: URI!
  ruleset(includeParents: RepositoryRuleset, databaseId: RepositoryRuleset): RepositoryRuleset
  rulesets(after: RepositoryRulesetConnection, before: RepositoryRulesetConnection, first: RepositoryRulesetConnection, last: RepositoryRulesetConnection, includeParents: RepositoryRulesetConnection): RepositoryRulesetConnection
  securityPolicyUrl: URI
  shortDescriptionHTML(limit: HTML!): HTML!
  squashMergeAllowed: Boolean!
  squashMergeCommitMessage: SquashMergeCommitMessage!
  squashMergeCommitTitle: SquashMergeCommitTitle!
  squashPrTitleUsedAsDefault: Boolean!
  sshUrl: GitSSHRemote!
  stargazerCount: Int!
  stargazers(after: StargazerConnection!, before: StargazerConnection!, first: StargazerConnection!, last: StargazerConnection!, orderBy: StargazerConnection!): StargazerConnection!
  submodules(after: SubmoduleConnection!, before: SubmoduleConnection!, first: SubmoduleConnection!, last: SubmoduleConnection!): SubmoduleConnection!
  tempCloneToken: String
  templateRepository: Repository
  updatedAt: DateTime!
  url: URI!
  usesCustomOpenGraphImage: Boolean!
  viewerCanAdminister: Boolean!
  viewerCanCreateProjects: Boolean!
  viewerCanSubscribe: Boolean!
  viewerCanUpdateTopics: Boolean!
  viewerDefaultCommitEmail: String
  viewerDefaultMergeMethod: PullRequestMergeMethod!
  viewerHasStarred: Boolean!
  viewerPermission: RepositoryPermission
  viewerPossibleCommitEmails: [String!]
  viewerSubscription: SubscriptionState
  visibility: RepositoryVisibility!
  vulnerabilityAlert(number: RepositoryVulnerabilityAlert): RepositoryVulnerabilityAlert
  vulnerabilityAlerts(after: RepositoryVulnerabilityAlertConnection, before: RepositoryVulnerabilityAlertConnection, first: RepositoryVulnerabilityAlertConnection, last: RepositoryVulnerabilityAlertConnection, states: RepositoryVulnerabilityAlertConnection, dependencyScopes: RepositoryVulnerabilityAlertConnection): RepositoryVulnerabilityAlertConnection
  watchers(after: UserConnection!, before: UserConnection!, first: UserConnection!, last: UserConnection!): UserConnection!
  webCommitSignoffRequired: Boolean!
}

enum RepositoryAffiliation {
  OWNER
  COLLABORATOR
  ORGANIZATION_MEMBER
}

interface RepositoryAuditEntryData {
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
}

type RepositoryCodeowners {
  errors: [RepositoryCodeownersError!]!
}

type RepositoryCodeownersError {
  column: Int!
  kind: String!
  line: Int!
  message: String!
  path: String!
  source: String!
  suggestion: String
}

type RepositoryCollaboratorConnection {
  edges: [RepositoryCollaboratorEdge]
  nodes: [User]
  pageInfo: PageInfo!
  totalCount: Int!
}

type RepositoryCollaboratorEdge {
  cursor: String!
  node: User!
  permission: RepositoryPermission!
  permissionSources: [PermissionSource!]
}

type RepositoryConnection {
  edges: [RepositoryEdge]
  nodes: [Repository]
  pageInfo: PageInfo!
  totalCount: Int!
  totalDiskUsage: Int!
}

type RepositoryContactLink {
  about: String!
  name: String!
  url: URI!
}

enum RepositoryContributionType {
  COMMIT
  ISSUE
  PULL_REQUEST
  REPOSITORY
  PULL_REQUEST_REVIEW
}

interface RepositoryDiscussionAuthor {
  repositoryDiscussions(after: DiscussionConnection!, before: DiscussionConnection!, first: DiscussionConnection!, last: DiscussionConnection!, orderBy: DiscussionConnection!, repositoryId: DiscussionConnection!, answered: DiscussionConnection!, states: DiscussionConnection!): DiscussionConnection!
}

interface RepositoryDiscussionCommentAuthor {
  repositoryDiscussionComments(after: DiscussionCommentConnection!, before: DiscussionCommentConnection!, first: DiscussionCommentConnection!, last: DiscussionCommentConnection!, repositoryId: DiscussionCommentConnection!, onlyAnswers: DiscussionCommentConnection!): DiscussionCommentConnection!
}

type RepositoryEdge {
  cursor: String!
  node: Repository
}

type RepositoryIdConditionTarget {
  repositoryIds: [ID!]!
}

input RepositoryIdConditionTargetInput {
  repositoryIds: []!
}

interface RepositoryInfo {
  archivedAt: DateTime
  createdAt: DateTime!
  description: String
  descriptionHTML: HTML!
  forkCount: Int!
  hasDiscussionsEnabled: Boolean!
  hasIssuesEnabled: Boolean!
  hasProjectsEnabled: Boolean!
  hasSponsorshipsEnabled: Boolean!
  hasWikiEnabled: Boolean!
  homepageUrl: URI
  isArchived: Boolean!
  isFork: Boolean!
  isInOrganization: Boolean!
  isLocked: Boolean!
  isMirror: Boolean!
  isPrivate: Boolean!
  isTemplate: Boolean!
  licenseInfo: License
  lockReason: RepositoryLockReason
  mirrorUrl: URI
  name: String!
  nameWithOwner: String!
  openGraphImageUrl: URI!
  owner: RepositoryOwner!
  pushedAt: DateTime
  resourcePath: URI!
  shortDescriptionHTML(limit: HTML!): HTML!
  updatedAt: DateTime!
  url: URI!
  usesCustomOpenGraphImage: Boolean!
  visibility: RepositoryVisibility!
}

type RepositoryInteractionAbility {
  expiresAt: DateTime
  limit: RepositoryInteractionLimit!
  origin: RepositoryInteractionLimitOrigin!
}

enum RepositoryInteractionLimit {
  EXISTING_USERS
  CONTRIBUTORS_ONLY
  COLLABORATORS_ONLY
  NO_LIMIT
}

enum RepositoryInteractionLimitExpiry {
  ONE_DAY
  THREE_DAYS
  ONE_WEEK
  ONE_MONTH
  SIX_MONTHS
}

enum RepositoryInteractionLimitOrigin {
  REPOSITORY
  ORGANIZATION
  USER
}

type RepositoryInvitation implements Node {
  email: String
  id: ID!
  invitee: User
  inviter: User!
  permalink: URI!
  permission: RepositoryPermission!
  repository: RepositoryInfo
}

type RepositoryInvitationConnection {
  edges: [RepositoryInvitationEdge]
  nodes: [RepositoryInvitation]
  pageInfo: PageInfo!
  totalCount: Int!
}

type RepositoryInvitationEdge {
  cursor: String!
  node: RepositoryInvitation
}

input RepositoryInvitationOrder {
  field: RepositoryInvitationOrderField!
  direction: OrderDirection!
}

enum RepositoryInvitationOrderField {
  CREATED_AT
}

enum RepositoryLockReason {
  MOVING
  BILLING
  RENAME
  MIGRATING
  TRADE_RESTRICTION
  TRANSFERRING_OWNERSHIP
}

type RepositoryMigration implements Migration & Node {
  continueOnError: Boolean!
  createdAt: DateTime!
  databaseId: String
  failureReason: String
  id: ID!
  migrationLogUrl: URI
  migrationSource: MigrationSource!
  repositoryName: String!
  sourceUrl: URI!
  state: MigrationState!
  warningsCount: Int!
}

type RepositoryMigrationConnection {
  edges: [RepositoryMigrationEdge]
  nodes: [RepositoryMigration]
  pageInfo: PageInfo!
  totalCount: Int!
}

type RepositoryMigrationEdge {
  cursor: String!
  node: RepositoryMigration
}

input RepositoryMigrationOrder {
  field: RepositoryMigrationOrderField!
  direction: RepositoryMigrationOrderDirection!
}

enum RepositoryMigrationOrderDirection {
  ASC
  DESC
}

enum RepositoryMigrationOrderField {
  CREATED_AT
}

type RepositoryNameConditionTarget {
  exclude: [String!]!
  include: [String!]!
  protected: Boolean!
}

input RepositoryNameConditionTargetInput {
  exclude: []!
  include: []!
  protected: Boolean
}

interface RepositoryNode {
  repository: Repository!
}

input RepositoryOrder {
  field: RepositoryOrderField!
  direction: OrderDirection!
}

enum RepositoryOrderField {
  CREATED_AT
  UPDATED_AT
  PUSHED_AT
  NAME
  STARGAZERS
}

interface RepositoryOwner {
  avatarUrl(size: URI!): URI!
  id: ID!
  login: String!
  repositories(privacy: RepositoryConnection!, visibility: RepositoryConnection!, orderBy: RepositoryConnection!, affiliations: RepositoryConnection!, ownerAffiliations: RepositoryConnection!, isLocked: RepositoryConnection!, hasIssuesEnabled: RepositoryConnection!, after: RepositoryConnection!, before: RepositoryConnection!, first: RepositoryConnection!, last: RepositoryConnection!, isArchived: RepositoryConnection!, isFork: RepositoryConnection!): RepositoryConnection!
  repository(name: Repository, followRenames: Repository): Repository
  resourcePath: URI!
  url: URI!
}

enum RepositoryPermission {
  ADMIN
  MAINTAIN
  WRITE
  TRIAGE
  READ
}

type RepositoryPlanFeatures {
  codeowners: Boolean!
  draftPullRequests: Boolean!
  maximumAssignees: Int!
  maximumManualReviewRequests: Int!
  teamReviewRequests: Boolean!
}

enum RepositoryPrivacy {
  PUBLIC
  PRIVATE
}

type RepositoryPropertyConditionTarget {
  exclude: [PropertyTargetDefinition!]!
  include: [PropertyTargetDefinition!]!
}

input RepositoryPropertyConditionTargetInput {
  exclude: []!
  include: []!
}

type RepositoryRule implements Node {
  id: ID!
  parameters: RuleParameters
  repositoryRuleset: RepositoryRuleset
  type: RepositoryRuleType!
}

type RepositoryRuleConditions {
  refName: RefNameConditionTarget
  repositoryId: RepositoryIdConditionTarget
  repositoryName: RepositoryNameConditionTarget
  repositoryProperty: RepositoryPropertyConditionTarget
}

input RepositoryRuleConditionsInput {
  refName: RefNameConditionTargetInput
  repositoryName: RepositoryNameConditionTargetInput
  repositoryId: RepositoryIdConditionTargetInput
  repositoryProperty: RepositoryPropertyConditionTargetInput
}

type RepositoryRuleConnection {
  edges: [RepositoryRuleEdge]
  nodes: [RepositoryRule]
  pageInfo: PageInfo!
  totalCount: Int!
}

type RepositoryRuleEdge {
  cursor: String!
  node: RepositoryRule
}

input RepositoryRuleInput {
  id: ID
  type: RepositoryRuleType!
  parameters: RuleParametersInput
}

input RepositoryRuleOrder {
  field: RepositoryRuleOrderField!
  direction: OrderDirection!
}

enum RepositoryRuleOrderField {
  UPDATED_AT
  CREATED_AT
  TYPE
}

enum RepositoryRuleType {
  CREATION
  UPDATE
  DELETION
  REQUIRED_LINEAR_HISTORY
  MERGE_QUEUE
  REQUIRED_REVIEW_THREAD_RESOLUTION
  REQUIRED_DEPLOYMENTS
  REQUIRED_SIGNATURES
  PULL_REQUEST
  REQUIRED_STATUS_CHECKS
  REQUIRED_WORKFLOW_STATUS_CHECKS
  NON_FAST_FORWARD
  AUTHORIZATION
  TAG
  MERGE_QUEUE_LOCKED_REF
  LOCK_BRANCH
  MAX_REF_UPDATES
  COMMIT_MESSAGE_PATTERN
  COMMIT_AUTHOR_EMAIL_PATTERN
  COMMITTER_EMAIL_PATTERN
  BRANCH_NAME_PATTERN
  TAG_NAME_PATTERN
  FILE_PATH_RESTRICTION
  MAX_FILE_PATH_LENGTH
  FILE_EXTENSION_RESTRICTION
  MAX_FILE_SIZE
  WORKFLOWS
  SECRET_SCANNING
  WORKFLOW_UPDATES
  CODE_SCANNING
}

type RepositoryRuleset implements Node {
  bypassActors(after: RepositoryRulesetBypassActorConnection, before: RepositoryRulesetBypassActorConnection, first: RepositoryRulesetBypassActorConnection, last: RepositoryRulesetBypassActorConnection): RepositoryRulesetBypassActorConnection
  conditions: RepositoryRuleConditions!
  createdAt: DateTime!
  databaseId: Int
  enforcement: RuleEnforcement!
  id: ID!
  name: String!
  rules(after: RepositoryRuleConnection, before: RepositoryRuleConnection, first: RepositoryRuleConnection, last: RepositoryRuleConnection, type: RepositoryRuleConnection): RepositoryRuleConnection
  source: RuleSource!
  target: RepositoryRulesetTarget
  updatedAt: DateTime!
}

type RepositoryRulesetBypassActor implements Node {
  actor: BypassActor
  bypassMode: RepositoryRulesetBypassActorBypassMode
  deployKey: Boolean!
  id: ID!
  organizationAdmin: Boolean!
  repositoryRoleDatabaseId: Int
  repositoryRoleName: String
  repositoryRuleset: RepositoryRuleset
}

enum RepositoryRulesetBypassActorBypassMode {
  ALWAYS
  PULL_REQUEST
}

type RepositoryRulesetBypassActorConnection {
  edges: [RepositoryRulesetBypassActorEdge]
  nodes: [RepositoryRulesetBypassActor]
  pageInfo: PageInfo!
  totalCount: Int!
}

type RepositoryRulesetBypassActorEdge {
  cursor: String!
  node: RepositoryRulesetBypassActor
}

input RepositoryRulesetBypassActorInput {
  actorId: ID
  repositoryRoleDatabaseId: Int
  organizationAdmin: Boolean
  deployKey: Boolean
  bypassMode: RepositoryRulesetBypassActorBypassMode!
}

type RepositoryRulesetConnection {
  edges: [RepositoryRulesetEdge]
  nodes: [RepositoryRuleset]
  pageInfo: PageInfo!
  totalCount: Int!
}

type RepositoryRulesetEdge {
  cursor: String!
  node: RepositoryRuleset
}

enum RepositoryRulesetTarget {
  BRANCH
  TAG
  PUSH
}

type RepositoryTopic implements Node & UniformResourceLocatable {
  id: ID!
  resourcePath: URI!
  topic: Topic!
  url: URI!
}

type RepositoryTopicConnection {
  edges: [RepositoryTopicEdge]
  nodes: [RepositoryTopic]
  pageInfo: PageInfo!
  totalCount: Int!
}

type RepositoryTopicEdge {
  cursor: String!
  node: RepositoryTopic
}

enum RepositoryVisibility {
  PRIVATE
  PUBLIC
  INTERNAL
}

type RepositoryVisibilityChangeDisableAuditEntry implements AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  enterpriseResourcePath: URI
  enterpriseSlug: String
  enterpriseUrl: URI
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type RepositoryVisibilityChangeEnableAuditEntry implements AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  enterpriseResourcePath: URI
  enterpriseSlug: String
  enterpriseUrl: URI
  id: ID!
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type RepositoryVulnerabilityAlert implements Node & RepositoryNode {
  autoDismissedAt: DateTime
  createdAt: DateTime!
  dependabotUpdate: DependabotUpdate
  dependencyScope: RepositoryVulnerabilityAlertDependencyScope
  dismissComment: String
  dismissReason: String
  dismissedAt: DateTime
  dismisser: User
  fixedAt: DateTime
  id: ID!
  number: Int!
  repository: Repository!
  securityAdvisory: SecurityAdvisory
  securityVulnerability: SecurityVulnerability
  state: RepositoryVulnerabilityAlertState!
  vulnerableManifestFilename: String!
  vulnerableManifestPath: String!
  vulnerableRequirements: String
}

type RepositoryVulnerabilityAlertConnection {
  edges: [RepositoryVulnerabilityAlertEdge]
  nodes: [RepositoryVulnerabilityAlert]
  pageInfo: PageInfo!
  totalCount: Int!
}

enum RepositoryVulnerabilityAlertDependencyScope {
  RUNTIME
  DEVELOPMENT
}

type RepositoryVulnerabilityAlertEdge {
  cursor: String!
  node: RepositoryVulnerabilityAlert
}

enum RepositoryVulnerabilityAlertState {
  OPEN
  FIXED
  DISMISSED
  AUTO_DISMISSED
}

input RequestReviewsInput {
  clientMutationId: String
  pullRequestId: ID!
  userIds: [ID!]
  teamIds: [ID!]
  union: Boolean
}

type RequestReviewsPayload {
  actor: Actor
  clientMutationId: String
  pullRequest: PullRequest
  requestedReviewersEdge: UserEdge
}

enum RequestableCheckStatusState {
  QUEUED
  IN_PROGRESS
  COMPLETED
  WAITING
  PENDING
}

union RequestedReviewer = Bot | Mannequin | Team | User

type RequestedReviewerConnection {
  edges: [RequestedReviewerEdge]
  nodes: [RequestedReviewer]
  pageInfo: PageInfo!
  totalCount: Int!
}

type RequestedReviewerEdge {
  cursor: String!
  node: RequestedReviewer
}

interface RequirableByPullRequest {
  isRequired(pullRequestId: Boolean!, pullRequestNumber: Boolean!): Boolean!
}

type RequiredDeploymentsParameters {
  requiredDeploymentEnvironments: [String!]!
}

input RequiredDeploymentsParametersInput {
  requiredDeploymentEnvironments: []!
}

type RequiredStatusCheckDescription {
  app: App
  context: String!
}

input RequiredStatusCheckInput {
  context: String!
  appId: ID
}

type RequiredStatusChecksParameters {
  requiredStatusChecks: [StatusCheckConfiguration!]!
  strictRequiredStatusChecksPolicy: Boolean!
}

input RequiredStatusChecksParametersInput {
  requiredStatusChecks: []!
  strictRequiredStatusChecksPolicy: Boolean!
}

input RerequestCheckSuiteInput {
  clientMutationId: String
  repositoryId: ID!
  checkSuiteId: ID!
}

type RerequestCheckSuitePayload {
  checkSuite: CheckSuite
  clientMutationId: String
}

input ResolveReviewThreadInput {
  clientMutationId: String
  threadId: ID!
}

type ResolveReviewThreadPayload {
  clientMutationId: String
  thread: PullRequestReviewThread
}

type RestrictedContribution implements Contribution {
  isRestricted: Boolean!
  occurredAt: DateTime!
  resourcePath: URI!
  url: URI!
  user: User!
}

input RetireSponsorsTierInput {
  clientMutationId: String
  tierId: ID!
}

type RetireSponsorsTierPayload {
  clientMutationId: String
  sponsorsTier: SponsorsTier
}

input RevertPullRequestInput {
  clientMutationId: String
  pullRequestId: ID!
  title: String
  body: String
  draft: Boolean
}

type RevertPullRequestPayload {
  clientMutationId: String
  pullRequest: PullRequest
  revertPullRequest: PullRequest
}

type ReviewDismissalAllowance implements Node {
  actor: ReviewDismissalAllowanceActor
  branchProtectionRule: BranchProtectionRule
  id: ID!
}

union ReviewDismissalAllowanceActor = App | Team | User

type ReviewDismissalAllowanceConnection {
  edges: [ReviewDismissalAllowanceEdge]
  nodes: [ReviewDismissalAllowance]
  pageInfo: PageInfo!
  totalCount: Int!
}

type ReviewDismissalAllowanceEdge {
  cursor: String!
  node: ReviewDismissalAllowance
}

type ReviewDismissedEvent implements Node & UniformResourceLocatable {
  actor: Actor
  createdAt: DateTime!
  databaseId: Int
  dismissalMessage: String
  dismissalMessageHTML: String
  id: ID!
  previousReviewState: PullRequestReviewState!
  pullRequest: PullRequest!
  pullRequestCommit: PullRequestCommit
  resourcePath: URI!
  review: PullRequestReview
  url: URI!
}

type ReviewRequest implements Node {
  asCodeOwner: Boolean!
  databaseId: Int
  id: ID!
  pullRequest: PullRequest!
  requestedReviewer: RequestedReviewer
}

type ReviewRequestConnection {
  edges: [ReviewRequestEdge]
  nodes: [ReviewRequest]
  pageInfo: PageInfo!
  totalCount: Int!
}

type ReviewRequestEdge {
  cursor: String!
  node: ReviewRequest
}

type ReviewRequestRemovedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  pullRequest: PullRequest!
  requestedReviewer: RequestedReviewer
}

type ReviewRequestedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  pullRequest: PullRequest!
  requestedReviewer: RequestedReviewer
}

type ReviewStatusHovercardContext implements HovercardContext {
  message: String!
  octicon: String!
  reviewDecision: PullRequestReviewDecision
}

input RevokeEnterpriseOrganizationsMigratorRoleInput {
  clientMutationId: String
  enterpriseId: ID!
  login: String!
}

type RevokeEnterpriseOrganizationsMigratorRolePayload {
  clientMutationId: String
  organizations(after: OrganizationConnection, before: OrganizationConnection, first: OrganizationConnection, last: OrganizationConnection): OrganizationConnection
}

input RevokeMigratorRoleInput {
  clientMutationId: String
  organizationId: ID!
  actor: String!
  actorType: ActorType!
}

type RevokeMigratorRolePayload {
  clientMutationId: String
  success: Boolean
}

enum RoleInOrganization {
  OWNER
  DIRECT_MEMBER
  UNAFFILIATED
}

enum RuleEnforcement {
  DISABLED
  ACTIVE
  EVALUATE
}

union RuleParameters = BranchNamePatternParameters | CodeScanningParameters | CommitAuthorEmailPatternParameters | CommitMessagePatternParameters | CommitterEmailPatternParameters | FileExtensionRestrictionParameters | FilePathRestrictionParameters | MaxFilePathLengthParameters | MaxFileSizeParameters | PullRequestParameters | RequiredDeploymentsParameters | RequiredStatusChecksParameters | TagNamePatternParameters | UpdateParameters | WorkflowsParameters

input RuleParametersInput {
  update: UpdateParametersInput
  requiredDeployments: RequiredDeploymentsParametersInput
  pullRequest: PullRequestParametersInput
  requiredStatusChecks: RequiredStatusChecksParametersInput
  commitMessagePattern: CommitMessagePatternParametersInput
  commitAuthorEmailPattern: CommitAuthorEmailPatternParametersInput
  committerEmailPattern: CommitterEmailPatternParametersInput
  branchNamePattern: BranchNamePatternParametersInput
  tagNamePattern: TagNamePatternParametersInput
  filePathRestriction: FilePathRestrictionParametersInput
  maxFilePathLength: MaxFilePathLengthParametersInput
  fileExtensionRestriction: FileExtensionRestrictionParametersInput
  maxFileSize: MaxFileSizeParametersInput
  workflows: WorkflowsParametersInput
  codeScanning: CodeScanningParametersInput
}

union RuleSource = Organization | Repository

enum SamlDigestAlgorithm {
  SHA1
  SHA256
  SHA384
  SHA512
}

enum SamlSignatureAlgorithm {
  RSA_SHA1
  RSA_SHA256
  RSA_SHA384
  RSA_SHA512
}

type SavedReply implements Node {
  body: String!
  bodyHTML: HTML!
  databaseId: Int
  id: ID!
  title: String!
  user: Actor
}

type SavedReplyConnection {
  edges: [SavedReplyEdge]
  nodes: [SavedReply]
  pageInfo: PageInfo!
  totalCount: Int!
}

type SavedReplyEdge {
  cursor: String!
  node: SavedReply
}

input SavedReplyOrder {
  field: SavedReplyOrderField!
  direction: OrderDirection!
}

enum SavedReplyOrderField {
  UPDATED_AT
}

union SearchResultItem = App | Discussion | Issue | MarketplaceListing | Organization | PullRequest | Repository | User

type SearchResultItemConnection {
  codeCount: Int!
  discussionCount: Int!
  edges: [SearchResultItemEdge]
  issueCount: Int!
  nodes: [SearchResultItem]
  pageInfo: PageInfo!
  repositoryCount: Int!
  userCount: Int!
  wikiCount: Int!
}

type SearchResultItemEdge {
  cursor: String!
  node: SearchResultItem
  textMatches: [TextMatch]
}

enum SearchType {
  ISSUE
  REPOSITORY
  USER
  DISCUSSION
}

type SecurityAdvisory implements Node {
  classification: SecurityAdvisoryClassification!
  cvss: CVSS!
  cwes(after: CWEConnection!, before: CWEConnection!, first: CWEConnection!, last: CWEConnection!): CWEConnection!
  databaseId: Int
  description: String!
  ghsaId: String!
  id: ID!
  identifiers: [SecurityAdvisoryIdentifier!]!
  notificationsPermalink: URI
  origin: String!
  permalink: URI
  publishedAt: DateTime!
  references: [SecurityAdvisoryReference!]!
  severity: SecurityAdvisorySeverity!
  summary: String!
  updatedAt: DateTime!
  vulnerabilities(orderBy: SecurityVulnerabilityConnection!, ecosystem: SecurityVulnerabilityConnection!, package: SecurityVulnerabilityConnection!, severities: SecurityVulnerabilityConnection!, classifications: SecurityVulnerabilityConnection!, after: SecurityVulnerabilityConnection!, before: SecurityVulnerabilityConnection!, first: SecurityVulnerabilityConnection!, last: SecurityVulnerabilityConnection!): SecurityVulnerabilityConnection!
  withdrawnAt: DateTime
}

enum SecurityAdvisoryClassification {
  GENERAL
  MALWARE
}

type SecurityAdvisoryConnection {
  edges: [SecurityAdvisoryEdge]
  nodes: [SecurityAdvisory]
  pageInfo: PageInfo!
  totalCount: Int!
}

enum SecurityAdvisoryEcosystem {
  COMPOSER
  ERLANG
  ACTIONS
  GO
  MAVEN
  NPM
  NUGET
  PIP
  PUB
  RUBYGEMS
  RUST
  SWIFT
}

type SecurityAdvisoryEdge {
  cursor: String!
  node: SecurityAdvisory
}

type SecurityAdvisoryIdentifier {
  type: String!
  value: String!
}

input SecurityAdvisoryIdentifierFilter {
  type: SecurityAdvisoryIdentifierType!
  value: String!
}

enum SecurityAdvisoryIdentifierType {
  CVE
  GHSA
}

input SecurityAdvisoryOrder {
  field: SecurityAdvisoryOrderField!
  direction: OrderDirection!
}

enum SecurityAdvisoryOrderField {
  PUBLISHED_AT
  UPDATED_AT
}

type SecurityAdvisoryPackage {
  ecosystem: SecurityAdvisoryEcosystem!
  name: String!
}

type SecurityAdvisoryPackageVersion {
  identifier: String!
}

type SecurityAdvisoryReference {
  url: URI!
}

enum SecurityAdvisorySeverity {
  LOW
  MODERATE
  HIGH
  CRITICAL
}

type SecurityVulnerability {
  advisory: SecurityAdvisory!
  firstPatchedVersion: SecurityAdvisoryPackageVersion
  package: SecurityAdvisoryPackage!
  severity: SecurityAdvisorySeverity!
  updatedAt: DateTime!
  vulnerableVersionRange: String!
}

type SecurityVulnerabilityConnection {
  edges: [SecurityVulnerabilityEdge]
  nodes: [SecurityVulnerability]
  pageInfo: PageInfo!
  totalCount: Int!
}

type SecurityVulnerabilityEdge {
  cursor: String!
  node: SecurityVulnerability
}

input SecurityVulnerabilityOrder {
  field: SecurityVulnerabilityOrderField!
  direction: OrderDirection!
}

enum SecurityVulnerabilityOrderField {
  UPDATED_AT
}

input SetEnterpriseIdentityProviderInput {
  clientMutationId: String
  enterpriseId: ID!
  ssoUrl: URI!
  issuer: String
  idpCertificate: String!
  signatureMethod: SamlSignatureAlgorithm!
  digestMethod: SamlDigestAlgorithm!
}

type SetEnterpriseIdentityProviderPayload {
  clientMutationId: String
  identityProvider: EnterpriseIdentityProvider
}

input SetOrganizationInteractionLimitInput {
  clientMutationId: String
  organizationId: ID!
  limit: RepositoryInteractionLimit!
  expiry: RepositoryInteractionLimitExpiry
}

type SetOrganizationInteractionLimitPayload {
  clientMutationId: String
  organization: Organization
}

input SetRepositoryInteractionLimitInput {
  clientMutationId: String
  repositoryId: ID!
  limit: RepositoryInteractionLimit!
  expiry: RepositoryInteractionLimitExpiry
}

type SetRepositoryInteractionLimitPayload {
  clientMutationId: String
  repository: Repository
}

input SetUserInteractionLimitInput {
  clientMutationId: String
  userId: ID!
  limit: RepositoryInteractionLimit!
  expiry: RepositoryInteractionLimitExpiry
}

type SetUserInteractionLimitPayload {
  clientMutationId: String
  user: User
}

type SmimeSignature implements GitSignature {
  email: String!
  isValid: Boolean!
  payload: String!
  signature: String!
  signer: User
  state: GitSignatureState!
  wasSignedByGitHub: Boolean!
}

type SocialAccount {
  displayName: String!
  provider: SocialAccountProvider!
  url: URI!
}

type SocialAccountConnection {
  edges: [SocialAccountEdge]
  nodes: [SocialAccount]
  pageInfo: PageInfo!
  totalCount: Int!
}

type SocialAccountEdge {
  cursor: String!
  node: SocialAccount
}

enum SocialAccountProvider {
  GENERIC
  FACEBOOK
  HOMETOWN
  INSTAGRAM
  LINKEDIN
  MASTODON
  REDDIT
  TWITCH
  TWITTER
  YOUTUBE
  NPM
}

union Sponsor = Organization | User

type SponsorAndLifetimeValue {
  amountInCents: Int!
  formattedAmount: String!
  sponsor: Sponsorable!
  sponsorable: Sponsorable!
}

type SponsorAndLifetimeValueConnection {
  edges: [SponsorAndLifetimeValueEdge]
  nodes: [SponsorAndLifetimeValue]
  pageInfo: PageInfo!
  totalCount: Int!
}

type SponsorAndLifetimeValueEdge {
  cursor: String!
  node: SponsorAndLifetimeValue
}

input SponsorAndLifetimeValueOrder {
  field: SponsorAndLifetimeValueOrderField!
  direction: OrderDirection!
}

enum SponsorAndLifetimeValueOrderField {
  SPONSOR_LOGIN
  SPONSOR_RELEVANCE
  LIFETIME_VALUE
}

type SponsorConnection {
  edges: [SponsorEdge]
  nodes: [Sponsor]
  pageInfo: PageInfo!
  totalCount: Int!
}

type SponsorEdge {
  cursor: String!
  node: Sponsor
}

input SponsorOrder {
  field: SponsorOrderField!
  direction: OrderDirection!
}

enum SponsorOrderField {
  LOGIN
  RELEVANCE
}

interface Sponsorable {
  estimatedNextSponsorsPayoutInCents: Int!
  hasSponsorsListing: Boolean!
  isSponsoredBy(accountLogin: Boolean!): Boolean!
  isSponsoringViewer: Boolean!
  lifetimeReceivedSponsorshipValues(after: SponsorAndLifetimeValueConnection!, before: SponsorAndLifetimeValueConnection!, first: SponsorAndLifetimeValueConnection!, last: SponsorAndLifetimeValueConnection!, orderBy: SponsorAndLifetimeValueConnection!): SponsorAndLifetimeValueConnection!
  monthlyEstimatedSponsorsIncomeInCents: Int!
  sponsoring(after: SponsorConnection!, before: SponsorConnection!, first: SponsorConnection!, last: SponsorConnection!, orderBy: SponsorConnection!): SponsorConnection!
  sponsors(after: SponsorConnection!, before: SponsorConnection!, first: SponsorConnection!, last: SponsorConnection!, tierId: SponsorConnection!, orderBy: SponsorConnection!): SponsorConnection!
  sponsorsActivities(after: SponsorsActivityConnection!, before: SponsorsActivityConnection!, first: SponsorsActivityConnection!, last: SponsorsActivityConnection!, period: SponsorsActivityConnection!, since: SponsorsActivityConnection!, until: SponsorsActivityConnection!, orderBy: SponsorsActivityConnection!, actions: SponsorsActivityConnection!, includeAsSponsor: SponsorsActivityConnection!, includePrivate: SponsorsActivityConnection!): SponsorsActivityConnection!
  sponsorsListing: SponsorsListing
  sponsorshipForViewerAsSponsor(activeOnly: Sponsorship): Sponsorship
  sponsorshipForViewerAsSponsorable(activeOnly: Sponsorship): Sponsorship
  sponsorshipNewsletters(after: SponsorshipNewsletterConnection!, before: SponsorshipNewsletterConnection!, first: SponsorshipNewsletterConnection!, last: SponsorshipNewsletterConnection!, orderBy: SponsorshipNewsletterConnection!): SponsorshipNewsletterConnection!
  sponsorshipsAsMaintainer(after: SponsorshipConnection!, before: SponsorshipConnection!, first: SponsorshipConnection!, last: SponsorshipConnection!, includePrivate: SponsorshipConnection!, orderBy: SponsorshipConnection!, activeOnly: SponsorshipConnection!): SponsorshipConnection!
  sponsorshipsAsSponsor(after: SponsorshipConnection!, before: SponsorshipConnection!, first: SponsorshipConnection!, last: SponsorshipConnection!, orderBy: SponsorshipConnection!, maintainerLogins: SponsorshipConnection!, activeOnly: SponsorshipConnection!): SponsorshipConnection!
  totalSponsorshipAmountAsSponsorInCents(since: Int, until: Int, sponsorableLogins: Int): Int
  viewerCanSponsor: Boolean!
  viewerIsSponsoring: Boolean!
}

union SponsorableItem = Organization | User

type SponsorableItemConnection {
  edges: [SponsorableItemEdge]
  nodes: [SponsorableItem]
  pageInfo: PageInfo!
  totalCount: Int!
}

type SponsorableItemEdge {
  cursor: String!
  node: SponsorableItem
}

input SponsorableOrder {
  field: SponsorableOrderField!
  direction: OrderDirection!
}

enum SponsorableOrderField {
  LOGIN
}

type SponsorsActivity implements Node {
  action: SponsorsActivityAction!
  currentPrivacyLevel: SponsorshipPrivacy
  id: ID!
  paymentSource: SponsorshipPaymentSource
  previousSponsorsTier: SponsorsTier
  sponsor: Sponsor
  sponsorable: Sponsorable!
  sponsorsTier: SponsorsTier
  timestamp: DateTime
  viaBulkSponsorship: Boolean!
}

enum SponsorsActivityAction {
  NEW_SPONSORSHIP
  CANCELLED_SPONSORSHIP
  TIER_CHANGE
  REFUND
  PENDING_CHANGE
  SPONSOR_MATCH_DISABLED
}

type SponsorsActivityConnection {
  edges: [SponsorsActivityEdge]
  nodes: [SponsorsActivity]
  pageInfo: PageInfo!
  totalCount: Int!
}

type SponsorsActivityEdge {
  cursor: String!
  node: SponsorsActivity
}

input SponsorsActivityOrder {
  field: SponsorsActivityOrderField!
  direction: OrderDirection!
}

enum SponsorsActivityOrderField {
  TIMESTAMP
}

enum SponsorsActivityPeriod {
  DAY
  WEEK
  MONTH
  ALL
}

enum SponsorsCountryOrRegionCode {
  AF
  AX
  AL
  DZ
  AS
  AD
  AO
  AI
  AQ
  AG
  AR
  AM
  AW
  AU
  AT
  AZ
  BS
  BH
  BD
  BB
  BY
  BE
  BZ
  BJ
  BM
  BT
  BO
  BQ
  BA
  BW
  BV
  BR
  IO
  BN
  BG
  BF
  BI
  KH
  CM
  CA
  CV
  KY
  CF
  TD
  CL
  CN
  CX
  CC
  CO
  KM
  CG
  CD
  CK
  CR
  CI
  HR
  CW
  CY
  CZ
  DK
  DJ
  DM
  DO
  EC
  EG
  SV
  GQ
  ER
  EE
  ET
  FK
  FO
  FJ
  FI
  FR
  GF
  PF
  TF
  GA
  GM
  GE
  DE
  GH
  GI
  GR
  GL
  GD
  GP
  GU
  GT
  GG
  GN
  GW
  GY
  HT
  HM
  HN
  HK
  HU
  IS
  IN
  ID
  IR
  IQ
  IE
  IM
  IL
  IT
  JM
  JP
  JE
  JO
  KZ
  KE
  KI
  KR
  KW
  KG
  LA
  LV
  LB
  LS
  LR
  LY
  LI
  LT
  LU
  MO
  MK
  MG
  MW
  MY
  MV
  ML
  MT
  MH
  MQ
  MR
  MU
  YT
  MX
  FM
  MD
  MC
  MN
  ME
  MS
  MA
  MZ
  MM
  NA
  NR
  NP
  NL
  NC
  NZ
  NI
  NE
  NG
  NU
  NF
  MP
  NO
  OM
  PK
  PW
  PS
  PA
  PG
  PY
  PE
  PH
  PN
  PL
  PT
  PR
  QA
  RE
  RO
  RU
  RW
  BL
  SH
  KN
  LC
  MF
  PM
  VC
  WS
  SM
  ST
  SA
  SN
  RS
  SC
  SL
  SG
  SX
  SK
  SI
  SB
  SO
  ZA
  GS
  SS
  ES
  LK
  SD
  SR
  SJ
  SZ
  SE
  CH
  TW
  TJ
  TZ
  TH
  TL
  TG
  TK
  TO
  TT
  TN
  TR
  TM
  TC
  TV
  UG
  UA
  AE
  GB
  UM
  US
  UY
  UZ
  VU
  VA
  VE
  VN
  VG
  VI
  WF
  EH
  YE
  ZM
  ZW
}

type SponsorsGoal {
  description: String
  kind: SponsorsGoalKind!
  percentComplete: Int!
  targetValue: Int!
  title: String!
}

enum SponsorsGoalKind {
  TOTAL_SPONSORS_COUNT
  MONTHLY_SPONSORSHIP_AMOUNT
}

type SponsorsListing implements Node {
  activeGoal: SponsorsGoal
  activeStripeConnectAccount: StripeConnectAccount
  billingCountryOrRegion: String
  contactEmailAddress: String
  createdAt: DateTime!
  dashboardResourcePath: URI!
  dashboardUrl: URI!
  featuredItems(featureableTypes: [SponsorsListingFeaturedItem!]!): [SponsorsListingFeaturedItem!]!
  fiscalHost: Organization
  fullDescription: String!
  fullDescriptionHTML: HTML!
  id: ID!
  isPublic: Boolean!
  name: String!
  nextPayoutDate: Date
  residenceCountryOrRegion: String
  resourcePath: URI!
  shortDescription: String!
  slug: String!
  sponsorable: Sponsorable!
  tiers(after: SponsorsTierConnection, before: SponsorsTierConnection, first: SponsorsTierConnection, last: SponsorsTierConnection, orderBy: SponsorsTierConnection, includeUnpublished: SponsorsTierConnection): SponsorsTierConnection
  url: URI!
}

union SponsorsListingFeatureableItem = Repository | User

type SponsorsListingFeaturedItem implements Node {
  createdAt: DateTime!
  description: String
  featureable: SponsorsListingFeatureableItem!
  id: ID!
  position: Int!
  sponsorsListing: SponsorsListing!
  updatedAt: DateTime!
}

enum SponsorsListingFeaturedItemFeatureableType {
  REPOSITORY
  USER
}

type SponsorsTier implements Node {
  adminInfo: SponsorsTierAdminInfo
  closestLesserValueTier: SponsorsTier
  createdAt: DateTime!
  description: String!
  descriptionHTML: HTML!
  id: ID!
  isCustomAmount: Boolean!
  isOneTime: Boolean!
  monthlyPriceInCents: Int!
  monthlyPriceInDollars: Int!
  name: String!
  sponsorsListing: SponsorsListing!
  updatedAt: DateTime!
}

type SponsorsTierAdminInfo {
  isDraft: Boolean!
  isPublished: Boolean!
  isRetired: Boolean!
  sponsorships(after: SponsorshipConnection!, before: SponsorshipConnection!, first: SponsorshipConnection!, last: SponsorshipConnection!, includePrivate: SponsorshipConnection!, orderBy: SponsorshipConnection!): SponsorshipConnection!
}

type SponsorsTierConnection {
  edges: [SponsorsTierEdge]
  nodes: [SponsorsTier]
  pageInfo: PageInfo!
  totalCount: Int!
}

type SponsorsTierEdge {
  cursor: String!
  node: SponsorsTier
}

input SponsorsTierOrder {
  field: SponsorsTierOrderField!
  direction: OrderDirection!
}

enum SponsorsTierOrderField {
  CREATED_AT
  MONTHLY_PRICE_IN_CENTS
}

type Sponsorship implements Node {
  createdAt: DateTime!
  id: ID!
  isActive: Boolean!
  isOneTimePayment: Boolean!
  isSponsorOptedIntoEmail: Boolean
  maintainer: User!
  paymentSource: SponsorshipPaymentSource
  privacyLevel: SponsorshipPrivacy!
  sponsor: User
  sponsorEntity: Sponsor
  sponsorable: Sponsorable!
  tier: SponsorsTier
  tierSelectedAt: DateTime
}

type SponsorshipConnection {
  edges: [SponsorshipEdge]
  nodes: [Sponsorship]
  pageInfo: PageInfo!
  totalCount: Int!
  totalRecurringMonthlyPriceInCents: Int!
  totalRecurringMonthlyPriceInDollars: Int!
}

type SponsorshipEdge {
  cursor: String!
  node: Sponsorship
}

type SponsorshipNewsletter implements Node {
  author: User
  body: String!
  createdAt: DateTime!
  id: ID!
  isPublished: Boolean!
  sponsorable: Sponsorable!
  subject: String!
  updatedAt: DateTime!
}

type SponsorshipNewsletterConnection {
  edges: [SponsorshipNewsletterEdge]
  nodes: [SponsorshipNewsletter]
  pageInfo: PageInfo!
  totalCount: Int!
}

type SponsorshipNewsletterEdge {
  cursor: String!
  node: SponsorshipNewsletter
}

input SponsorshipNewsletterOrder {
  field: SponsorshipNewsletterOrderField!
  direction: OrderDirection!
}

enum SponsorshipNewsletterOrderField {
  CREATED_AT
}

input SponsorshipOrder {
  field: SponsorshipOrderField!
  direction: OrderDirection!
}

enum SponsorshipOrderField {
  CREATED_AT
}

enum SponsorshipPaymentSource {
  GITHUB
  PATREON
}

enum SponsorshipPrivacy {
  PUBLIC
  PRIVATE
}

enum SquashMergeCommitMessage {
  PR_BODY
  COMMIT_MESSAGES
  BLANK
}

enum SquashMergeCommitTitle {
  PR_TITLE
  COMMIT_OR_PR_TITLE
}

type SshSignature implements GitSignature {
  email: String!
  isValid: Boolean!
  keyFingerprint: String
  payload: String!
  signature: String!
  signer: User
  state: GitSignatureState!
  wasSignedByGitHub: Boolean!
}

input StarOrder {
  field: StarOrderField!
  direction: OrderDirection!
}

enum StarOrderField {
  STARRED_AT
}

type StargazerConnection {
  edges: [StargazerEdge]
  nodes: [User]
  pageInfo: PageInfo!
  totalCount: Int!
}

type StargazerEdge {
  cursor: String!
  node: User!
  starredAt: DateTime!
}

interface Starrable {
  id: ID!
  stargazerCount: Int!
  stargazers(after: StargazerConnection!, before: StargazerConnection!, first: StargazerConnection!, last: StargazerConnection!, orderBy: StargazerConnection!): StargazerConnection!
  viewerHasStarred: Boolean!
}

type StarredRepositoryConnection {
  edges: [StarredRepositoryEdge]
  isOverLimit: Boolean!
  nodes: [Repository]
  pageInfo: PageInfo!
  totalCount: Int!
}

type StarredRepositoryEdge {
  cursor: String!
  node: Repository!
  starredAt: DateTime!
}

input StartOrganizationMigrationInput {
  clientMutationId: String
  sourceOrgUrl: URI!
  targetOrgName: String!
  targetEnterpriseId: ID!
  sourceAccessToken: String!
}

type StartOrganizationMigrationPayload {
  clientMutationId: String
  orgMigration: OrganizationMigration
}

input StartRepositoryMigrationInput {
  clientMutationId: String
  sourceId: ID!
  ownerId: ID!
  sourceRepositoryUrl: URI!
  repositoryName: String!
  continueOnError: Boolean
  gitArchiveUrl: String
  metadataArchiveUrl: String
  accessToken: String
  githubPat: String
  skipReleases: Boolean
  targetRepoVisibility: String
  lockSource: Boolean
}

type StartRepositoryMigrationPayload {
  clientMutationId: String
  repositoryMigration: RepositoryMigration
}

type Status implements Node {
  combinedContexts(after: StatusCheckRollupContextConnection!, before: StatusCheckRollupContextConnection!, first: StatusCheckRollupContextConnection!, last: StatusCheckRollupContextConnection!): StatusCheckRollupContextConnection!
  commit: Commit
  context(name: StatusContext): StatusContext
  contexts: [StatusContext!]!
  id: ID!
  state: StatusState!
}

type StatusCheckConfiguration {
  context: String!
  integrationId: Int
}

input StatusCheckConfigurationInput {
  context: String!
  integrationId: Int
}

type StatusCheckRollup implements Node {
  commit: Commit
  contexts(after: StatusCheckRollupContextConnection!, before: StatusCheckRollupContextConnection!, first: StatusCheckRollupContextConnection!, last: StatusCheckRollupContextConnection!): StatusCheckRollupContextConnection!
  id: ID!
  state: StatusState!
}

union StatusCheckRollupContext = CheckRun | StatusContext

type StatusCheckRollupContextConnection {
  checkRunCount: Int!
  checkRunCountsByState: [CheckRunStateCount!]
  edges: [StatusCheckRollupContextEdge]
  nodes: [StatusCheckRollupContext]
  pageInfo: PageInfo!
  statusContextCount: Int!
  statusContextCountsByState: [StatusContextStateCount!]
  totalCount: Int!
}

type StatusCheckRollupContextEdge {
  cursor: String!
  node: StatusCheckRollupContext
}

type StatusContext implements Node & RequirableByPullRequest {
  avatarUrl(size: URI): URI
  commit: Commit
  context: String!
  createdAt: DateTime!
  creator: Actor
  description: String
  id: ID!
  isRequired(pullRequestId: Boolean!, pullRequestNumber: Boolean!): Boolean!
  state: StatusState!
  targetUrl: URI
}

type StatusContextStateCount {
  count: Int!
  state: StatusState!
}

enum StatusState {
  EXPECTED
  ERROR
  FAILURE
  PENDING
  SUCCESS
}

scalar String

type StripeConnectAccount {
  accountId: String!
  billingCountryOrRegion: String
  countryOrRegion: String
  isActive: Boolean!
  sponsorsListing: SponsorsListing!
  stripeDashboardUrl: URI!
}

input SubmitPullRequestReviewInput {
  clientMutationId: String
  pullRequestId: ID
  pullRequestReviewId: ID
  event: PullRequestReviewEvent!
  body: String
}

type SubmitPullRequestReviewPayload {
  clientMutationId: String
  pullRequestReview: PullRequestReview
}

type Submodule {
  branch: String
  gitUrl: URI!
  name: String!
  nameRaw: Base64String!
  path: String!
  pathRaw: Base64String!
  subprojectCommitOid: GitObjectID
}

type SubmoduleConnection {
  edges: [SubmoduleEdge]
  nodes: [Submodule]
  pageInfo: PageInfo!
  totalCount: Int!
}

type SubmoduleEdge {
  cursor: String!
  node: Submodule
}

interface Subscribable {
  id: ID!
  viewerCanSubscribe: Boolean!
  viewerSubscription: SubscriptionState
}

interface SubscribableThread {
  id: ID!
  viewerThreadSubscriptionFormAction: ThreadSubscriptionFormAction
  viewerThreadSubscriptionStatus: ThreadSubscriptionState
}

type SubscribedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  subscribable: Subscribable!
}

enum SubscriptionState {
  UNSUBSCRIBED
  SUBSCRIBED
  IGNORED
}

type SuggestedReviewer {
  isAuthor: Boolean!
  isCommenter: Boolean!
  reviewer: User!
}

type Tag implements GitObject & Node {
  abbreviatedOid: String!
  commitResourcePath: URI!
  commitUrl: URI!
  id: ID!
  message: String
  name: String!
  oid: GitObjectID!
  repository: Repository!
  tagger: GitActor
  target: GitObject!
}

type TagNamePatternParameters {
  name: String
  negate: Boolean!
  operator: String!
  pattern: String!
}

input TagNamePatternParametersInput {
  name: String
  negate: Boolean
  operator: String!
  pattern: String!
}

type Team implements MemberStatusable & Node & Subscribable {
  ancestors(after: TeamConnection!, before: TeamConnection!, first: TeamConnection!, last: TeamConnection!): TeamConnection!
  avatarUrl(size: URI): URI
  childTeams(orderBy: TeamConnection!, userLogins: TeamConnection!, immediateOnly: TeamConnection!, after: TeamConnection!, before: TeamConnection!, first: TeamConnection!, last: TeamConnection!): TeamConnection!
  combinedSlug: String!
  createdAt: DateTime!
  databaseId: Int
  description: String
  discussion(number: TeamDiscussion): TeamDiscussion
  discussions(after: TeamDiscussionConnection!, before: TeamDiscussionConnection!, first: TeamDiscussionConnection!, last: TeamDiscussionConnection!, isPinned: TeamDiscussionConnection!, orderBy: TeamDiscussionConnection!): TeamDiscussionConnection!
  discussionsResourcePath: URI!
  discussionsUrl: URI!
  editTeamResourcePath: URI!
  editTeamUrl: URI!
  id: ID!
  invitations(after: OrganizationInvitationConnection, before: OrganizationInvitationConnection, first: OrganizationInvitationConnection, last: OrganizationInvitationConnection): OrganizationInvitationConnection
  memberStatuses(after: UserStatusConnection!, before: UserStatusConnection!, first: UserStatusConnection!, last: UserStatusConnection!, orderBy: UserStatusConnection!): UserStatusConnection!
  members(after: TeamMemberConnection!, before: TeamMemberConnection!, first: TeamMemberConnection!, last: TeamMemberConnection!, query: TeamMemberConnection!, membership: TeamMemberConnection!, role: TeamMemberConnection!, orderBy: TeamMemberConnection!): TeamMemberConnection!
  membersResourcePath: URI!
  membersUrl: URI!
  name: String!
  newTeamResourcePath: URI!
  newTeamUrl: URI!
  notificationSetting: TeamNotificationSetting!
  organization: Organization!
  parentTeam: Team
  privacy: TeamPrivacy!
  projectV2(number: ProjectV2): ProjectV2
  projectsV2(after: ProjectV2Connection!, before: ProjectV2Connection!, first: ProjectV2Connection!, last: ProjectV2Connection!, orderBy: ProjectV2Connection!, filterBy: ProjectV2Connection!, query: ProjectV2Connection!): ProjectV2Connection!
  repositories(after: TeamRepositoryConnection!, before: TeamRepositoryConnection!, first: TeamRepositoryConnection!, last: TeamRepositoryConnection!, query: TeamRepositoryConnection!, orderBy: TeamRepositoryConnection!): TeamRepositoryConnection!
  repositoriesResourcePath: URI!
  repositoriesUrl: URI!
  resourcePath: URI!
  reviewRequestDelegationAlgorithm: TeamReviewAssignmentAlgorithm
  reviewRequestDelegationEnabled: Boolean!
  reviewRequestDelegationMemberCount: Int
  reviewRequestDelegationNotifyTeam: Boolean!
  slug: String!
  teamsResourcePath: URI!
  teamsUrl: URI!
  updatedAt: DateTime!
  url: URI!
  viewerCanAdminister: Boolean!
  viewerCanSubscribe: Boolean!
  viewerSubscription: SubscriptionState
}

type TeamAddMemberAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & TeamAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  isLdapMapped: Boolean
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  team: Team
  teamName: String
  teamResourcePath: URI
  teamUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type TeamAddRepositoryAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & TeamAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  isLdapMapped: Boolean
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  team: Team
  teamName: String
  teamResourcePath: URI
  teamUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

interface TeamAuditEntryData {
  team: Team
  teamName: String
  teamResourcePath: URI
  teamUrl: URI
}

type TeamChangeParentTeamAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & TeamAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  isLdapMapped: Boolean
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  parentTeam: Team
  parentTeamName: String
  parentTeamNameWas: String
  parentTeamResourcePath: URI
  parentTeamUrl: URI
  parentTeamWas: Team
  parentTeamWasResourcePath: URI
  parentTeamWasUrl: URI
  team: Team
  teamName: String
  teamResourcePath: URI
  teamUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type TeamConnection {
  edges: [TeamEdge]
  nodes: [Team]
  pageInfo: PageInfo!
  totalCount: Int!
}

type TeamDiscussion implements Comment & Deletable & Node & Reactable & Subscribable & UniformResourceLocatable & Updatable & UpdatableComment {
  author: Actor
  authorAssociation: CommentAuthorAssociation!
  body: String!
  bodyHTML: HTML!
  bodyText: String!
  bodyVersion: String!
  comments(after: TeamDiscussionCommentConnection!, before: TeamDiscussionCommentConnection!, first: TeamDiscussionCommentConnection!, last: TeamDiscussionCommentConnection!, orderBy: TeamDiscussionCommentConnection!, fromComment: TeamDiscussionCommentConnection!): TeamDiscussionCommentConnection!
  commentsResourcePath: URI!
  commentsUrl: URI!
  createdAt: DateTime!
  createdViaEmail: Boolean!
  databaseId: Int
  editor: Actor
  id: ID!
  includesCreatedEdit: Boolean!
  isPinned: Boolean!
  isPrivate: Boolean!
  lastEditedAt: DateTime
  number: Int!
  publishedAt: DateTime
  reactionGroups: [ReactionGroup!]
  reactions(after: ReactionConnection!, before: ReactionConnection!, first: ReactionConnection!, last: ReactionConnection!, content: ReactionConnection!, orderBy: ReactionConnection!): ReactionConnection!
  resourcePath: URI!
  team: Team!
  title: String!
  updatedAt: DateTime!
  url: URI!
  userContentEdits(after: UserContentEditConnection, before: UserContentEditConnection, first: UserContentEditConnection, last: UserContentEditConnection): UserContentEditConnection
  viewerCanDelete: Boolean!
  viewerCanPin: Boolean!
  viewerCanReact: Boolean!
  viewerCanSubscribe: Boolean!
  viewerCanUpdate: Boolean!
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
  viewerDidAuthor: Boolean!
  viewerSubscription: SubscriptionState
}

type TeamDiscussionComment implements Comment & Deletable & Node & Reactable & UniformResourceLocatable & Updatable & UpdatableComment {
  author: Actor
  authorAssociation: CommentAuthorAssociation!
  body: String!
  bodyHTML: HTML!
  bodyText: String!
  bodyVersion: String!
  createdAt: DateTime!
  createdViaEmail: Boolean!
  databaseId: Int
  discussion: TeamDiscussion!
  editor: Actor
  id: ID!
  includesCreatedEdit: Boolean!
  lastEditedAt: DateTime
  number: Int!
  publishedAt: DateTime
  reactionGroups: [ReactionGroup!]
  reactions(after: ReactionConnection!, before: ReactionConnection!, first: ReactionConnection!, last: ReactionConnection!, content: ReactionConnection!, orderBy: ReactionConnection!): ReactionConnection!
  resourcePath: URI!
  updatedAt: DateTime!
  url: URI!
  userContentEdits(after: UserContentEditConnection, before: UserContentEditConnection, first: UserContentEditConnection, last: UserContentEditConnection): UserContentEditConnection
  viewerCanDelete: Boolean!
  viewerCanReact: Boolean!
  viewerCanUpdate: Boolean!
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
  viewerDidAuthor: Boolean!
}

type TeamDiscussionCommentConnection {
  edges: [TeamDiscussionCommentEdge]
  nodes: [TeamDiscussionComment]
  pageInfo: PageInfo!
  totalCount: Int!
}

type TeamDiscussionCommentEdge {
  cursor: String!
  node: TeamDiscussionComment
}

input TeamDiscussionCommentOrder {
  field: TeamDiscussionCommentOrderField!
  direction: OrderDirection!
}

enum TeamDiscussionCommentOrderField {
  NUMBER
}

type TeamDiscussionConnection {
  edges: [TeamDiscussionEdge]
  nodes: [TeamDiscussion]
  pageInfo: PageInfo!
  totalCount: Int!
}

type TeamDiscussionEdge {
  cursor: String!
  node: TeamDiscussion
}

input TeamDiscussionOrder {
  field: TeamDiscussionOrderField!
  direction: OrderDirection!
}

enum TeamDiscussionOrderField {
  CREATED_AT
}

type TeamEdge {
  cursor: String!
  node: Team
}

type TeamMemberConnection {
  edges: [TeamMemberEdge]
  nodes: [User]
  pageInfo: PageInfo!
  totalCount: Int!
}

type TeamMemberEdge {
  cursor: String!
  memberAccessResourcePath: URI!
  memberAccessUrl: URI!
  node: User!
  role: TeamMemberRole!
}

input TeamMemberOrder {
  field: TeamMemberOrderField!
  direction: OrderDirection!
}

enum TeamMemberOrderField {
  LOGIN
  CREATED_AT
}

enum TeamMemberRole {
  MAINTAINER
  MEMBER
}

enum TeamMembershipType {
  IMMEDIATE
  CHILD_TEAM
  ALL
}

enum TeamNotificationSetting {
  NOTIFICATIONS_ENABLED
  NOTIFICATIONS_DISABLED
}

input TeamOrder {
  field: TeamOrderField!
  direction: OrderDirection!
}

enum TeamOrderField {
  NAME
}

enum TeamPrivacy {
  SECRET
  VISIBLE
}

type TeamRemoveMemberAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & TeamAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  isLdapMapped: Boolean
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  team: Team
  teamName: String
  teamResourcePath: URI
  teamUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type TeamRemoveRepositoryAuditEntry implements AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & TeamAuditEntryData {
  action: String!
  actor: AuditEntryActor
  actorIp: String
  actorLocation: ActorLocation
  actorLogin: String
  actorResourcePath: URI
  actorUrl: URI
  createdAt: PreciseDateTime!
  id: ID!
  isLdapMapped: Boolean
  operationType: OperationType
  organization: Organization
  organizationName: String
  organizationResourcePath: URI
  organizationUrl: URI
  repository: Repository
  repositoryName: String
  repositoryResourcePath: URI
  repositoryUrl: URI
  team: Team
  teamName: String
  teamResourcePath: URI
  teamUrl: URI
  user: User
  userLogin: String
  userResourcePath: URI
  userUrl: URI
}

type TeamRepositoryConnection {
  edges: [TeamRepositoryEdge]
  nodes: [Repository]
  pageInfo: PageInfo!
  totalCount: Int!
}

type TeamRepositoryEdge {
  cursor: String!
  node: Repository!
  permission: RepositoryPermission!
}

input TeamRepositoryOrder {
  field: TeamRepositoryOrderField!
  direction: OrderDirection!
}

enum TeamRepositoryOrderField {
  CREATED_AT
  UPDATED_AT
  PUSHED_AT
  NAME
  PERMISSION
  STARGAZERS
}

enum TeamReviewAssignmentAlgorithm {
  ROUND_ROBIN
  LOAD_BALANCE
}

enum TeamRole {
  ADMIN
  MEMBER
}

type TextMatch {
  fragment: String!
  highlights: [TextMatchHighlight!]!
  property: String!
}

type TextMatchHighlight {
  beginIndice: Int!
  endIndice: Int!
  text: String!
}

enum ThreadSubscriptionFormAction {
  NONE
  SUBSCRIBE
  UNSUBSCRIBE
}

enum ThreadSubscriptionState {
  UNAVAILABLE
  DISABLED
  IGNORING_LIST
  SUBSCRIBED_TO_THREAD_EVENTS
  IGNORING_THREAD
  SUBSCRIBED_TO_LIST
  SUBSCRIBED_TO_THREAD_TYPE
  SUBSCRIBED_TO_THREAD
  NONE
}

type Topic implements Node & Starrable {
  id: ID!
  name: String!
  relatedTopics(first: [Topic!]!): [Topic!]!
  repositories(privacy: RepositoryConnection!, visibility: RepositoryConnection!, orderBy: RepositoryConnection!, affiliations: RepositoryConnection!, ownerAffiliations: RepositoryConnection!, isLocked: RepositoryConnection!, hasIssuesEnabled: RepositoryConnection!, after: RepositoryConnection!, before: RepositoryConnection!, first: RepositoryConnection!, last: RepositoryConnection!, sponsorableOnly: RepositoryConnection!): RepositoryConnection!
  stargazerCount: Int!
  stargazers(after: StargazerConnection!, before: StargazerConnection!, first: StargazerConnection!, last: StargazerConnection!, orderBy: StargazerConnection!): StargazerConnection!
  viewerHasStarred: Boolean!
}

interface TopicAuditEntryData {
  topic: Topic
  topicName: String
}

enum TopicSuggestionDeclineReason {
  NOT_RELEVANT
  TOO_SPECIFIC
  PERSONAL_PREFERENCE
  TOO_GENERAL
}

enum TrackedIssueStates {
  OPEN
  CLOSED
}

input TransferEnterpriseOrganizationInput {
  clientMutationId: String
  organizationId: ID!
  destinationEnterpriseId: ID!
}

type TransferEnterpriseOrganizationPayload {
  clientMutationId: String
  organization: Organization
}

input TransferIssueInput {
  clientMutationId: String
  issueId: ID!
  repositoryId: ID!
  createLabelsIfMissing: Boolean
}

type TransferIssuePayload {
  clientMutationId: String
  issue: Issue
}

type TransferredEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  fromRepository: Repository
  id: ID!
  issue: Issue!
}

type Tree implements GitObject & Node {
  abbreviatedOid: String!
  commitResourcePath: URI!
  commitUrl: URI!
  entries: [TreeEntry!]
  id: ID!
  oid: GitObjectID!
  repository: Repository!
}

type TreeEntry {
  extension: String
  isGenerated: Boolean!
  language: Language
  lineCount: Int
  mode: Int!
  name: String!
  nameRaw: Base64String!
  object: GitObject
  oid: GitObjectID!
  path: String
  pathRaw: Base64String
  repository: Repository!
  size: Int!
  submodule: Submodule
  type: String!
}

scalar URI

input UnarchiveProjectV2ItemInput {
  clientMutationId: String
  projectId: ID!
  itemId: ID!
}

type UnarchiveProjectV2ItemPayload {
  clientMutationId: String
  item: ProjectV2Item
}

input UnarchiveRepositoryInput {
  clientMutationId: String
  repositoryId: ID!
}

type UnarchiveRepositoryPayload {
  clientMutationId: String
  repository: Repository
}

type UnassignedEvent implements Node {
  actor: Actor
  assignable: Assignable!
  assignee: Assignee
  createdAt: DateTime!
  id: ID!
  user: User
}

input UnfollowOrganizationInput {
  clientMutationId: String
  organizationId: ID!
}

type UnfollowOrganizationPayload {
  clientMutationId: String
  organization: Organization
}

input UnfollowUserInput {
  clientMutationId: String
  userId: ID!
}

type UnfollowUserPayload {
  clientMutationId: String
  user: User
}

interface UniformResourceLocatable {
  resourcePath: URI!
  url: URI!
}

type UnknownSignature implements GitSignature {
  email: String!
  isValid: Boolean!
  payload: String!
  signature: String!
  signer: User
  state: GitSignatureState!
  wasSignedByGitHub: Boolean!
}

type UnlabeledEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  label: Label!
  labelable: Labelable!
}

input UnlinkProjectV2FromRepositoryInput {
  clientMutationId: String
  projectId: ID!
  repositoryId: ID!
}

type UnlinkProjectV2FromRepositoryPayload {
  clientMutationId: String
  repository: Repository
}

input UnlinkProjectV2FromTeamInput {
  clientMutationId: String
  projectId: ID!
  teamId: ID!
}

type UnlinkProjectV2FromTeamPayload {
  clientMutationId: String
  team: Team
}

input UnlinkRepositoryFromProjectInput {
  clientMutationId: String
  projectId: ID!
  repositoryId: ID!
}

type UnlinkRepositoryFromProjectPayload {
  clientMutationId: String
  project: Project
  repository: Repository
}

input UnlockLockableInput {
  clientMutationId: String
  lockableId: ID!
}

type UnlockLockablePayload {
  actor: Actor
  clientMutationId: String
  unlockedRecord: Lockable
}

type UnlockedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  lockable: Lockable!
}

input UnmarkDiscussionCommentAsAnswerInput {
  clientMutationId: String
  id: ID!
}

type UnmarkDiscussionCommentAsAnswerPayload {
  clientMutationId: String
  discussion: Discussion
}

input UnmarkFileAsViewedInput {
  clientMutationId: String
  pullRequestId: ID!
  path: String!
}

type UnmarkFileAsViewedPayload {
  clientMutationId: String
  pullRequest: PullRequest
}

input UnmarkIssueAsDuplicateInput {
  clientMutationId: String
  duplicateId: ID!
  canonicalId: ID!
}

type UnmarkIssueAsDuplicatePayload {
  clientMutationId: String
  duplicate: IssueOrPullRequest
}

input UnmarkProjectV2AsTemplateInput {
  clientMutationId: String
  projectId: ID!
}

type UnmarkProjectV2AsTemplatePayload {
  clientMutationId: String
  projectV2: ProjectV2
}

type UnmarkedAsDuplicateEvent implements Node {
  actor: Actor
  canonical: IssueOrPullRequest
  createdAt: DateTime!
  duplicate: IssueOrPullRequest
  id: ID!
  isCrossRepository: Boolean!
}

input UnminimizeCommentInput {
  clientMutationId: String
  subjectId: ID!
}

type UnminimizeCommentPayload {
  clientMutationId: String
  unminimizedComment: Minimizable
}

input UnpinIssueInput {
  clientMutationId: String
  issueId: ID!
}

type UnpinIssuePayload {
  clientMutationId: String
  id: ID
  issue: Issue
}

type UnpinnedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  issue: Issue!
}

input UnresolveReviewThreadInput {
  clientMutationId: String
  threadId: ID!
}

type UnresolveReviewThreadPayload {
  clientMutationId: String
  thread: PullRequestReviewThread
}

input UnsubscribeFromNotificationsInput {
  clientMutationId: String
  ids: []!
}

type UnsubscribeFromNotificationsPayload {
  clientMutationId: String
  success: Boolean
}

type UnsubscribedEvent implements Node {
  actor: Actor
  createdAt: DateTime!
  id: ID!
  subscribable: Subscribable!
}

interface Updatable {
  viewerCanUpdate: Boolean!
}

interface UpdatableComment {
  viewerCannotUpdateReasons: [CommentCannotUpdateReason!]!
}

input UpdateBranchProtectionRuleInput {
  clientMutationId: String
  branchProtectionRuleId: ID!
  pattern: String
  requiresApprovingReviews: Boolean
  requiredApprovingReviewCount: Int
  requiresCommitSignatures: Boolean
  requiresLinearHistory: Boolean
  blocksCreations: Boolean
  allowsForcePushes: Boolean
  allowsDeletions: Boolean
  isAdminEnforced: Boolean
  requiresStatusChecks: Boolean
  requiresStrictStatusChecks: Boolean
  requiresCodeOwnerReviews: Boolean
  dismissesStaleReviews: Boolean
  restrictsReviewDismissals: Boolean
  reviewDismissalActorIds: [ID!]
  bypassPullRequestActorIds: [ID!]
  bypassForcePushActorIds: [ID!]
  restrictsPushes: Boolean
  pushActorIds: [ID!]
  requiredStatusCheckContexts: [String!]
  requiredStatusChecks: [RequiredStatusCheckInput!]
  requiresDeployments: Boolean
  requiredDeploymentEnvironments: [String!]
  requiresConversationResolution: Boolean
  requireLastPushApproval: Boolean
  lockBranch: Boolean
  lockAllowsFetchAndMerge: Boolean
}

type UpdateBranchProtectionRulePayload {
  branchProtectionRule: BranchProtectionRule
  clientMutationId: String
}

input UpdateCheckRunInput {
  clientMutationId: String
  repositoryId: ID!
  checkRunId: ID!
  name: String
  detailsUrl: URI
  externalId: String
  status: RequestableCheckStatusState
  startedAt: DateTime
  conclusion: CheckConclusionState
  completedAt: DateTime
  output: CheckRunOutput
  actions: [CheckRunAction!]
}

type UpdateCheckRunPayload {
  checkRun: CheckRun
  clientMutationId: String
}

input UpdateCheckSuitePreferencesInput {
  clientMutationId: String
  repositoryId: ID!
  autoTriggerPreferences: []!
}

type UpdateCheckSuitePreferencesPayload {
  clientMutationId: String
  repository: Repository
}

input UpdateDiscussionCommentInput {
  clientMutationId: String
  commentId: ID!
  body: String!
}

type UpdateDiscussionCommentPayload {
  clientMutationId: String
  comment: DiscussionComment
}

input UpdateDiscussionInput {
  clientMutationId: String
  discussionId: ID!
  title: String
  body: String
  categoryId: ID
}

type UpdateDiscussionPayload {
  clientMutationId: String
  discussion: Discussion
}

input UpdateEnterpriseAdministratorRoleInput {
  clientMutationId: String
  enterpriseId: ID!
  login: String!
  role: EnterpriseAdministratorRole!
}

type UpdateEnterpriseAdministratorRolePayload {
  clientMutationId: String
  message: String
}

input UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput {
  clientMutationId: String
  enterpriseId: ID!
  settingValue: EnterpriseEnabledDisabledSettingValue!
  policyValue: EnterpriseAllowPrivateRepositoryForkingPolicyValue
}

type UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload {
  clientMutationId: String
  enterprise: Enterprise
  message: String
}

input UpdateEnterpriseDefaultRepositoryPermissionSettingInput {
  clientMutationId: String
  enterpriseId: ID!
  settingValue: EnterpriseDefaultRepositoryPermissionSettingValue!
}

type UpdateEnterpriseDefaultRepositoryPermissionSettingPayload {
  clientMutationId: String
  enterprise: Enterprise
  message: String
}

input UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput {
  clientMutationId: String
  enterpriseId: ID!
  settingValue: EnterpriseEnabledDisabledSettingValue!
}

type UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload {
  clientMutationId: String
  enterprise: Enterprise
  message: String
}

input UpdateEnterpriseMembersCanCreateRepositoriesSettingInput {
  clientMutationId: String
  enterpriseId: ID!
  settingValue: EnterpriseMembersCanCreateRepositoriesSettingValue
  membersCanCreateRepositoriesPolicyEnabled: Boolean
  membersCanCreatePublicRepositories: Boolean
  membersCanCreatePrivateRepositories: Boolean
  membersCanCreateInternalRepositories: Boolean
}

type UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload {
  clientMutationId: String
  enterprise: Enterprise
  message: String
}

input UpdateEnterpriseMembersCanDeleteIssuesSettingInput {
  clientMutationId: String
  enterpriseId: ID!
  settingValue: EnterpriseEnabledDisabledSettingValue!
}

type UpdateEnterpriseMembersCanDeleteIssuesSettingPayload {
  clientMutationId: String
  enterprise: Enterprise
  message: String
}

input UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput {
  clientMutationId: String
  enterpriseId: ID!
  settingValue: EnterpriseEnabledDisabledSettingValue!
}

type UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload {
  clientMutationId: String
  enterprise: Enterprise
  message: String
}

input UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput {
  clientMutationId: String
  enterpriseId: ID!
  settingValue: EnterpriseEnabledDisabledSettingValue!
}

type UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload {
  clientMutationId: String
  enterprise: Enterprise
  message: String
}

input UpdateEnterpriseMembersCanMakePurchasesSettingInput {
  clientMutationId: String
  enterpriseId: ID!
  settingValue: EnterpriseMembersCanMakePurchasesSettingValue!
}

type UpdateEnterpriseMembersCanMakePurchasesSettingPayload {
  clientMutationId: String
  enterprise: Enterprise
  message: String
}

input UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput {
  clientMutationId: String
  enterpriseId: ID!
  settingValue: EnterpriseEnabledDisabledSettingValue!
}

type UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload {
  clientMutationId: String
  enterprise: Enterprise
  message: String
}

input UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput {
  clientMutationId: String
  enterpriseId: ID!
  settingValue: EnterpriseEnabledDisabledSettingValue!
}

type UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload {
  clientMutationId: String
  enterprise: Enterprise
  message: String
}

input UpdateEnterpriseOrganizationProjectsSettingInput {
  clientMutationId: String
  enterpriseId: ID!
  settingValue: EnterpriseEnabledDisabledSettingValue!
}

type UpdateEnterpriseOrganizationProjectsSettingPayload {
  clientMutationId: String
  enterprise: Enterprise
  message: String
}

input UpdateEnterpriseOwnerOrganizationRoleInput {
  clientMutationId: String
  enterpriseId: ID!
  organizationId: ID!
  organizationRole: RoleInOrganization!
}

type UpdateEnterpriseOwnerOrganizationRolePayload {
  clientMutationId: String
  message: String
}

input UpdateEnterpriseProfileInput {
  clientMutationId: String
  enterpriseId: ID!
  name: String
  description: String
  websiteUrl: String
  location: String
}

type UpdateEnterpriseProfilePayload {
  clientMutationId: String
  enterprise: Enterprise
}

input UpdateEnterpriseRepositoryProjectsSettingInput {
  clientMutationId: String
  enterpriseId: ID!
  settingValue: EnterpriseEnabledDisabledSettingValue!
}

type UpdateEnterpriseRepositoryProjectsSettingPayload {
  clientMutationId: String
  enterprise: Enterprise
  message: String
}

input UpdateEnterpriseTeamDiscussionsSettingInput {
  clientMutationId: String
  enterpriseId: ID!
  settingValue: EnterpriseEnabledDisabledSettingValue!
}

type UpdateEnterpriseTeamDiscussionsSettingPayload {
  clientMutationId: String
  enterprise: Enterprise
  message: String
}

input UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput {
  clientMutationId: String
  enterpriseId: ID!
  settingValue: EnterpriseEnabledSettingValue!
}

type UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload {
  clientMutationId: String
  enterprise: Enterprise
  message: String
}

input UpdateEnvironmentInput {
  clientMutationId: String
  environmentId: ID!
  waitTimer: Int
  reviewers: [ID!]
  preventSelfReview: Boolean
}

type UpdateEnvironmentPayload {
  clientMutationId: String
  environment: Environment
}

input UpdateIpAllowListEnabledSettingInput {
  clientMutationId: String
  ownerId: ID!
  settingValue: IpAllowListEnabledSettingValue!
}

type UpdateIpAllowListEnabledSettingPayload {
  clientMutationId: String
  owner: IpAllowListOwner
}

input UpdateIpAllowListEntryInput {
  clientMutationId: String
  ipAllowListEntryId: ID!
  allowListValue: String!
  name: String
  isActive: Boolean!
}

type UpdateIpAllowListEntryPayload {
  clientMutationId: String
  ipAllowListEntry: IpAllowListEntry
}

input UpdateIpAllowListForInstalledAppsEnabledSettingInput {
  clientMutationId: String
  ownerId: ID!
  settingValue: IpAllowListForInstalledAppsEnabledSettingValue!
}

type UpdateIpAllowListForInstalledAppsEnabledSettingPayload {
  clientMutationId: String
  owner: IpAllowListOwner
}

input UpdateIssueCommentInput {
  clientMutationId: String
  id: ID!
  body: String!
}

type UpdateIssueCommentPayload {
  clientMutationId: String
  issueComment: IssueComment
}

input UpdateIssueInput {
  clientMutationId: String
  id: ID!
  title: String
  body: String
  assigneeIds: [ID!]
  milestoneId: ID
  labelIds: [ID!]
  state: IssueState
  projectIds: [ID!]
}

type UpdateIssuePayload {
  actor: Actor
  clientMutationId: String
  issue: Issue
}

input UpdateLabelInput {
  clientMutationId: String
  id: ID!
  color: String
  description: String
  name: String
}

type UpdateLabelPayload {
  clientMutationId: String
  label: Label
}

input UpdateNotificationRestrictionSettingInput {
  clientMutationId: String
  ownerId: ID!
  settingValue: NotificationRestrictionSettingValue!
}

type UpdateNotificationRestrictionSettingPayload {
  clientMutationId: String
  owner: VerifiableDomainOwner
}

input UpdateOrganizationAllowPrivateRepositoryForkingSettingInput {
  clientMutationId: String
  organizationId: ID!
  forkingEnabled: Boolean!
}

type UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload {
  clientMutationId: String
  message: String
  organization: Organization
}

input UpdateOrganizationWebCommitSignoffSettingInput {
  clientMutationId: String
  organizationId: ID!
  webCommitSignoffRequired: Boolean!
}

type UpdateOrganizationWebCommitSignoffSettingPayload {
  clientMutationId: String
  message: String
  organization: Organization
}

type UpdateParameters {
  updateAllowsFetchAndMerge: Boolean!
}

input UpdateParametersInput {
  updateAllowsFetchAndMerge: Boolean!
}

input UpdatePatreonSponsorabilityInput {
  clientMutationId: String
  sponsorableLogin: String
  enablePatreonSponsorships: Boolean!
}

type UpdatePatreonSponsorabilityPayload {
  clientMutationId: String
  sponsorsListing: SponsorsListing
}

input UpdateProjectCardInput {
  clientMutationId: String
  projectCardId: ID!
  isArchived: Boolean
  note: String
}

type UpdateProjectCardPayload {
  clientMutationId: String
  projectCard: ProjectCard
}

input UpdateProjectColumnInput {
  clientMutationId: String
  projectColumnId: ID!
  name: String!
}

type UpdateProjectColumnPayload {
  clientMutationId: String
  projectColumn: ProjectColumn
}

input UpdateProjectInput {
  clientMutationId: String
  projectId: ID!
  name: String
  body: String
  state: ProjectState
  public: Boolean
}

type UpdateProjectPayload {
  clientMutationId: String
  project: Project
}

input UpdateProjectV2CollaboratorsInput {
  clientMutationId: String
  projectId: ID!
  collaborators: []!
}

type UpdateProjectV2CollaboratorsPayload {
  clientMutationId: String
  collaborators(after: ProjectV2ActorConnection, before: ProjectV2ActorConnection, first: ProjectV2ActorConnection, last: ProjectV2ActorConnection): ProjectV2ActorConnection
}

input UpdateProjectV2DraftIssueInput {
  clientMutationId: String
  draftIssueId: ID!
  title: String
  body: String
  assigneeIds: [ID!]
}

type UpdateProjectV2DraftIssuePayload {
  clientMutationId: String
  draftIssue: DraftIssue
}

input UpdateProjectV2Input {
  clientMutationId: String
  projectId: ID!
  title: String
  shortDescription: String
  readme: String
  closed: Boolean
  public: Boolean
}

input UpdateProjectV2ItemFieldValueInput {
  clientMutationId: String
  projectId: ID!
  itemId: ID!
  fieldId: ID!
  value: ProjectV2FieldValue!
}

type UpdateProjectV2ItemFieldValuePayload {
  clientMutationId: String
  projectV2Item: ProjectV2Item
}

input UpdateProjectV2ItemPositionInput {
  clientMutationId: String
  projectId: ID!
  itemId: ID!
  afterId: ID
}

type UpdateProjectV2ItemPositionPayload {
  clientMutationId: String
  items(after: ProjectV2ItemConnection, before: ProjectV2ItemConnection, first: ProjectV2ItemConnection, last: ProjectV2ItemConnection): ProjectV2ItemConnection
}

type UpdateProjectV2Payload {
  clientMutationId: String
  projectV2: ProjectV2
}

input UpdatePullRequestBranchInput {
  clientMutationId: String
  pullRequestId: ID!
  expectedHeadOid: GitObjectID
  updateMethod: PullRequestBranchUpdateMethod
}

type UpdatePullRequestBranchPayload {
  clientMutationId: String
  pullRequest: PullRequest
}

input UpdatePullRequestInput {
  clientMutationId: String
  pullRequestId: ID!
  baseRefName: String
  title: String
  body: String
  state: PullRequestUpdateState
  maintainerCanModify: Boolean
  assigneeIds: [ID!]
  milestoneId: ID
  labelIds: [ID!]
  projectIds: [ID!]
}

type UpdatePullRequestPayload {
  actor: Actor
  clientMutationId: String
  pullRequest: PullRequest
}

input UpdatePullRequestReviewCommentInput {
  clientMutationId: String
  pullRequestReviewCommentId: ID!
  body: String!
}

type UpdatePullRequestReviewCommentPayload {
  clientMutationId: String
  pullRequestReviewComment: PullRequestReviewComment
}

input UpdatePullRequestReviewInput {
  clientMutationId: String
  pullRequestReviewId: ID!
  body: String!
}

type UpdatePullRequestReviewPayload {
  clientMutationId: String
  pullRequestReview: PullRequestReview
}

input UpdateRefInput {
  clientMutationId: String
  refId: ID!
  oid: GitObjectID!
  force: Boolean
}

type UpdateRefPayload {
  clientMutationId: String
  ref: Ref
}

input UpdateRefsInput {
  clientMutationId: String
  repositoryId: ID!
  refUpdates: []!
}

type UpdateRefsPayload {
  clientMutationId: String
}

input UpdateRepositoryInput {
  clientMutationId: String
  repositoryId: ID!
  name: String
  description: String
  template: Boolean
  homepageUrl: URI
  hasWikiEnabled: Boolean
  hasIssuesEnabled: Boolean
  hasProjectsEnabled: Boolean
  hasDiscussionsEnabled: Boolean
  hasSponsorshipsEnabled: Boolean
}

type UpdateRepositoryPayload {
  clientMutationId: String
  repository: Repository
}

input UpdateRepositoryRulesetInput {
  clientMutationId: String
  repositoryRulesetId: ID!
  name: String
  target: RepositoryRulesetTarget
  rules: [RepositoryRuleInput!]
  conditions: RepositoryRuleConditionsInput
  enforcement: RuleEnforcement
  bypassActors: [RepositoryRulesetBypassActorInput!]
}

type UpdateRepositoryRulesetPayload {
  clientMutationId: String
  ruleset: RepositoryRuleset
}

input UpdateRepositoryWebCommitSignoffSettingInput {
  clientMutationId: String
  repositoryId: ID!
  webCommitSignoffRequired: Boolean!
}

type UpdateRepositoryWebCommitSignoffSettingPayload {
  clientMutationId: String
  message: String
  repository: Repository
}

input UpdateSponsorshipPreferencesInput {
  clientMutationId: String
  sponsorId: ID
  sponsorLogin: String
  sponsorableId: ID
  sponsorableLogin: String
  receiveEmails: Boolean
  privacyLevel: SponsorshipPrivacy
}

type UpdateSponsorshipPreferencesPayload {
  clientMutationId: String
  sponsorship: Sponsorship
}

input UpdateSubscriptionInput {
  clientMutationId: String
  subscribableId: ID!
  state: SubscriptionState!
}

type UpdateSubscriptionPayload {
  clientMutationId: String
  subscribable: Subscribable
}

input UpdateTeamDiscussionCommentInput {
  clientMutationId: String
  id: ID!
  body: String!
  bodyVersion: String
}

type UpdateTeamDiscussionCommentPayload {
  clientMutationId: String
  teamDiscussionComment: TeamDiscussionComment
}

input UpdateTeamDiscussionInput {
  clientMutationId: String
  id: ID!
  title: String
  body: String
  bodyVersion: String
  pinned: Boolean
}

type UpdateTeamDiscussionPayload {
  clientMutationId: String
  teamDiscussion: TeamDiscussion
}

input UpdateTeamReviewAssignmentInput {
  clientMutationId: String
  id: ID!
  enabled: Boolean!
  algorithm: TeamReviewAssignmentAlgorithm
  teamMemberCount: Int
  notifyTeam: Boolean
  removeTeamRequest: Boolean
  includeChildTeamMembers: Boolean
  countMembersAlreadyRequested: Boolean
  excludedTeamMemberIds: [ID!]
}

type UpdateTeamReviewAssignmentPayload {
  clientMutationId: String
  team: Team
}

input UpdateTeamsRepositoryInput {
  clientMutationId: String
  repositoryId: ID!
  teamIds: []!
  permission: RepositoryPermission!
}

type UpdateTeamsRepositoryPayload {
  clientMutationId: String
  repository: Repository
  teams: [Team!]
}

input UpdateTopicsInput {
  clientMutationId: String
  repositoryId: ID!
  topicNames: []!
}

type UpdateTopicsPayload {
  clientMutationId: String
  invalidTopicNames: [String!]
  repository: Repository
}

input UpdateUserListInput {
  clientMutationId: String
  listId: ID!
  name: String
  description: String
  isPrivate: Boolean
}

type UpdateUserListPayload {
  clientMutationId: String
  list: UserList
}

input UpdateUserListsForItemInput {
  clientMutationId: String
  itemId: ID!
  listIds: []!
  suggestedListIds: [ID!]
}

type UpdateUserListsForItemPayload {
  clientMutationId: String
  item: UserListItems
  lists: [UserList!]
  user: User
}

type User implements Actor & Node & PackageOwner & ProfileOwner & ProjectOwner & ProjectV2Owner & ProjectV2Recent & RepositoryDiscussionAuthor & RepositoryDiscussionCommentAuthor & RepositoryOwner & Sponsorable & UniformResourceLocatable {
  anyPinnableItems(type: Boolean!): Boolean!
  avatarUrl(size: URI!): URI!
  bio: String
  bioHTML: HTML!
  canReceiveOrganizationEmailsWhenNotificationsRestricted(login: Boolean!): Boolean!
  commitComments(after: CommitCommentConnection!, before: CommitCommentConnection!, first: CommitCommentConnection!, last: CommitCommentConnection!): CommitCommentConnection!
  company: String
  companyHTML: HTML!
  contributionsCollection(organizationID: ContributionsCollection!, from: ContributionsCollection!, to: ContributionsCollection!): ContributionsCollection!
  copilotEndpoints: CopilotEndpoints
  createdAt: DateTime!
  databaseId: Int
  email: String!
  enterprises(after: EnterpriseConnection, before: EnterpriseConnection, first: EnterpriseConnection, last: EnterpriseConnection, orderBy: EnterpriseConnection, membershipType: EnterpriseConnection): EnterpriseConnection
  estimatedNextSponsorsPayoutInCents: Int!
  followers(after: FollowerConnection!, before: FollowerConnection!, first: FollowerConnection!, last: FollowerConnection!): FollowerConnection!
  following(after: FollowingConnection!, before: FollowingConnection!, first: FollowingConnection!, last: FollowingConnection!): FollowingConnection!
  gist(name: Gist): Gist
  gistComments(after: GistCommentConnection!, before: GistCommentConnection!, first: GistCommentConnection!, last: GistCommentConnection!): GistCommentConnection!
  gists(privacy: GistConnection!, orderBy: GistConnection!, after: GistConnection!, before: GistConnection!, first: GistConnection!, last: GistConnection!): GistConnection!
  hasSponsorsListing: Boolean!
  hovercard(primarySubjectId: Hovercard!): Hovercard!
  id: ID!
  interactionAbility: RepositoryInteractionAbility
  isBountyHunter: Boolean!
  isCampusExpert: Boolean!
  isDeveloperProgramMember: Boolean!
  isEmployee: Boolean!
  isFollowingViewer: Boolean!
  isGitHubStar: Boolean!
  isHireable: Boolean!
  isSiteAdmin: Boolean!
  isSponsoredBy(accountLogin: Boolean!): Boolean!
  isSponsoringViewer: Boolean!
  isViewer: Boolean!
  issueComments(orderBy: IssueCommentConnection!, after: IssueCommentConnection!, before: IssueCommentConnection!, first: IssueCommentConnection!, last: IssueCommentConnection!): IssueCommentConnection!
  issues(orderBy: IssueConnection!, labels: IssueConnection!, states: IssueConnection!, filterBy: IssueConnection!, after: IssueConnection!, before: IssueConnection!, first: IssueConnection!, last: IssueConnection!): IssueConnection!
  itemShowcase: ProfileItemShowcase!
  lifetimeReceivedSponsorshipValues(after: SponsorAndLifetimeValueConnection!, before: SponsorAndLifetimeValueConnection!, first: SponsorAndLifetimeValueConnection!, last: SponsorAndLifetimeValueConnection!, orderBy: SponsorAndLifetimeValueConnection!): SponsorAndLifetimeValueConnection!
  lists(after: UserListConnection!, before: UserListConnection!, first: UserListConnection!, last: UserListConnection!): UserListConnection!
  location: String
  login: String!
  monthlyEstimatedSponsorsIncomeInCents: Int!
  name: String
  organization(login: Organization): Organization
  organizationVerifiedDomainEmails(login: [String!]!): [String!]!
  organizations(orderBy: OrganizationConnection!, after: OrganizationConnection!, before: OrganizationConnection!, first: OrganizationConnection!, last: OrganizationConnection!): OrganizationConnection!
  packages(after: PackageConnection!, before: PackageConnection!, first: PackageConnection!, last: PackageConnection!, names: PackageConnection!, repositoryId: PackageConnection!, packageType: PackageConnection!, orderBy: PackageConnection!): PackageConnection!
  pinnableItems(types: PinnableItemConnection!, after: PinnableItemConnection!, before: PinnableItemConnection!, first: PinnableItemConnection!, last: PinnableItemConnection!): PinnableItemConnection!
  pinnedItems(types: PinnableItemConnection!, after: PinnableItemConnection!, before: PinnableItemConnection!, first: PinnableItemConnection!, last: PinnableItemConnection!): PinnableItemConnection!
  pinnedItemsRemaining: Int!
  project(number: Project): Project
  projectV2(number: ProjectV2): ProjectV2
  projects(orderBy: ProjectConnection!, search: ProjectConnection!, states: ProjectConnection!, after: ProjectConnection!, before: ProjectConnection!, first: ProjectConnection!, last: ProjectConnection!): ProjectConnection!
  projectsResourcePath: URI!
  projectsUrl: URI!
  projectsV2(query: ProjectV2Connection!, orderBy: ProjectV2Connection!, after: ProjectV2Connection!, before: ProjectV2Connection!, first: ProjectV2Connection!, last: ProjectV2Connection!): ProjectV2Connection!
  pronouns: String
  publicKeys(after: PublicKeyConnection!, before: PublicKeyConnection!, first: PublicKeyConnection!, last: PublicKeyConnection!): PublicKeyConnection!
  pullRequests(states: PullRequestConnection!, labels: PullRequestConnection!, headRefName: PullRequestConnection!, baseRefName: PullRequestConnection!, orderBy: PullRequestConnection!, after: PullRequestConnection!, before: PullRequestConnection!, first: PullRequestConnection!, last: PullRequestConnection!): PullRequestConnection!
  recentProjects(after: ProjectV2Connection!, before: ProjectV2Connection!, first: ProjectV2Connection!, last: ProjectV2Connection!): ProjectV2Connection!
  repositories(privacy: RepositoryConnection!, visibility: RepositoryConnection!, orderBy: RepositoryConnection!, affiliations: RepositoryConnection!, ownerAffiliations: RepositoryConnection!, isLocked: RepositoryConnection!, hasIssuesEnabled: RepositoryConnection!, after: RepositoryConnection!, before: RepositoryConnection!, first: RepositoryConnection!, last: RepositoryConnection!, isArchived: RepositoryConnection!, isFork: RepositoryConnection!): RepositoryConnection!
  repositoriesContributedTo(privacy: RepositoryConnection!, orderBy: RepositoryConnection!, isLocked: RepositoryConnection!, hasIssues: RepositoryConnection!, includeUserRepositories: RepositoryConnection!, contributionTypes: RepositoryConnection!, after: RepositoryConnection!, before: RepositoryConnection!, first: RepositoryConnection!, last: RepositoryConnection!): RepositoryConnection!
  repository(name: Repository, followRenames: Repository): Repository
  repositoryDiscussionComments(after: DiscussionCommentConnection!, before: DiscussionCommentConnection!, first: DiscussionCommentConnection!, last: DiscussionCommentConnection!, repositoryId: DiscussionCommentConnection!, onlyAnswers: DiscussionCommentConnection!): DiscussionCommentConnection!
  repositoryDiscussions(after: DiscussionConnection!, before: DiscussionConnection!, first: DiscussionConnection!, last: DiscussionConnection!, orderBy: DiscussionConnection!, repositoryId: DiscussionConnection!, answered: DiscussionConnection!, states: DiscussionConnection!): DiscussionConnection!
  resourcePath: URI!
  savedReplies(after: SavedReplyConnection, before: SavedReplyConnection, first: SavedReplyConnection, last: SavedReplyConnection, orderBy: SavedReplyConnection): SavedReplyConnection
  socialAccounts(after: SocialAccountConnection!, before: SocialAccountConnection!, first: SocialAccountConnection!, last: SocialAccountConnection!): SocialAccountConnection!
  sponsoring(after: SponsorConnection!, before: SponsorConnection!, first: SponsorConnection!, last: SponsorConnection!, orderBy: SponsorConnection!): SponsorConnection!
  sponsors(after: SponsorConnection!, before: SponsorConnection!, first: SponsorConnection!, last: SponsorConnection!, tierId: SponsorConnection!, orderBy: SponsorConnection!): SponsorConnection!
  sponsorsActivities(after: SponsorsActivityConnection!, before: SponsorsActivityConnection!, first: SponsorsActivityConnection!, last: SponsorsActivityConnection!, period: SponsorsActivityConnection!, since: SponsorsActivityConnection!, until: SponsorsActivityConnection!, orderBy: SponsorsActivityConnection!, actions: SponsorsActivityConnection!, includeAsSponsor: SponsorsActivityConnection!, includePrivate: SponsorsActivityConnection!): SponsorsActivityConnection!
  sponsorsListing: SponsorsListing
  sponsorshipForViewerAsSponsor(activeOnly: Sponsorship): Sponsorship
  sponsorshipForViewerAsSponsorable(activeOnly: Sponsorship): Sponsorship
  sponsorshipNewsletters(after: SponsorshipNewsletterConnection!, before: SponsorshipNewsletterConnection!, first: SponsorshipNewsletterConnection!, last: SponsorshipNewsletterConnection!, orderBy: SponsorshipNewsletterConnection!): SponsorshipNewsletterConnection!
  sponsorshipsAsMaintainer(after: SponsorshipConnection!, before: SponsorshipConnection!, first: SponsorshipConnection!, last: SponsorshipConnection!, includePrivate: SponsorshipConnection!, orderBy: SponsorshipConnection!, activeOnly: SponsorshipConnection!): SponsorshipConnection!
  sponsorshipsAsSponsor(after: SponsorshipConnection!, before: SponsorshipConnection!, first: SponsorshipConnection!, last: SponsorshipConnection!, orderBy: SponsorshipConnection!, maintainerLogins: SponsorshipConnection!, activeOnly: SponsorshipConnection!): SponsorshipConnection!
  starredRepositories(after: StarredRepositoryConnection!, before: StarredRepositoryConnection!, first: StarredRepositoryConnection!, last: StarredRepositoryConnection!, ownedByViewer: StarredRepositoryConnection!, orderBy: StarredRepositoryConnection!): StarredRepositoryConnection!
  status: UserStatus
  suggestedListNames: [UserListSuggestion!]!
  topRepositories(after: RepositoryConnection!, before: RepositoryConnection!, first: RepositoryConnection!, last: RepositoryConnection!, orderBy: RepositoryConnection!, since: RepositoryConnection!): RepositoryConnection!
  totalSponsorshipAmountAsSponsorInCents(since: Int, until: Int, sponsorableLogins: Int): Int
  twitterUsername: String
  updatedAt: DateTime!
  url: URI!
  viewerCanChangePinnedItems: Boolean!
  viewerCanCreateProjects: Boolean!
  viewerCanFollow: Boolean!
  viewerCanSponsor: Boolean!
  viewerIsFollowing: Boolean!
  viewerIsSponsoring: Boolean!
  watching(privacy: RepositoryConnection!, visibility: RepositoryConnection!, orderBy: RepositoryConnection!, affiliations: RepositoryConnection!, ownerAffiliations: RepositoryConnection!, isLocked: RepositoryConnection!, hasIssuesEnabled: RepositoryConnection!, after: RepositoryConnection!, before: RepositoryConnection!, first: RepositoryConnection!, last: RepositoryConnection!): RepositoryConnection!
  websiteUrl: URI
}

enum UserBlockDuration {
  ONE_DAY
  THREE_DAYS
  ONE_WEEK
  ONE_MONTH
  PERMANENT
}

type UserBlockedEvent implements Node {
  actor: Actor
  blockDuration: UserBlockDuration!
  createdAt: DateTime!
  id: ID!
  subject: User
}

type UserConnection {
  edges: [UserEdge]
  nodes: [User]
  pageInfo: PageInfo!
  totalCount: Int!
}

type UserContentEdit implements Node {
  createdAt: DateTime!
  deletedAt: DateTime
  deletedBy: Actor
  diff: String
  editedAt: DateTime!
  editor: Actor
  id: ID!
  updatedAt: DateTime!
}

type UserContentEditConnection {
  edges: [UserContentEditEdge]
  nodes: [UserContentEdit]
  pageInfo: PageInfo!
  totalCount: Int!
}

type UserContentEditEdge {
  cursor: String!
  node: UserContentEdit
}

type UserEdge {
  cursor: String!
  node: User
}

type UserEmailMetadata {
  primary: Boolean
  type: String
  value: String!
}

type UserList implements Node {
  createdAt: DateTime!
  description: String
  id: ID!
  isPrivate: Boolean!
  items(after: UserListItemsConnection!, before: UserListItemsConnection!, first: UserListItemsConnection!, last: UserListItemsConnection!): UserListItemsConnection!
  lastAddedAt: DateTime!
  name: String!
  slug: String!
  updatedAt: DateTime!
  user: User!
}

type UserListConnection {
  edges: [UserListEdge]
  nodes: [UserList]
  pageInfo: PageInfo!
  totalCount: Int!
}

type UserListEdge {
  cursor: String!
  node: UserList
}

union UserListItems = Repository

type UserListItemsConnection {
  edges: [UserListItemsEdge]
  nodes: [UserListItems]
  pageInfo: PageInfo!
  totalCount: Int!
}

type UserListItemsEdge {
  cursor: String!
  node: UserListItems
}

type UserListSuggestion {
  id: ID
  name: String
}

type UserStatus implements Node {
  createdAt: DateTime!
  emoji: String
  emojiHTML: HTML
  expiresAt: DateTime
  id: ID!
  indicatesLimitedAvailability: Boolean!
  message: String
  organization: Organization
  updatedAt: DateTime!
  user: User!
}

type UserStatusConnection {
  edges: [UserStatusEdge]
  nodes: [UserStatus]
  pageInfo: PageInfo!
  totalCount: Int!
}

type UserStatusEdge {
  cursor: String!
  node: UserStatus
}

input UserStatusOrder {
  field: UserStatusOrderField!
  direction: OrderDirection!
}

enum UserStatusOrderField {
  UPDATED_AT
}

type VerifiableDomain implements Node {
  createdAt: DateTime!
  databaseId: Int
  dnsHostName: URI
  domain: URI!
  hasFoundHostName: Boolean!
  hasFoundVerificationToken: Boolean!
  id: ID!
  isApproved: Boolean!
  isRequiredForPolicyEnforcement: Boolean!
  isVerified: Boolean!
  owner: VerifiableDomainOwner!
  punycodeEncodedDomain: URI!
  tokenExpirationTime: DateTime
  updatedAt: DateTime!
  verificationToken: String
}

type VerifiableDomainConnection {
  edges: [VerifiableDomainEdge]
  nodes: [VerifiableDomain]
  pageInfo: PageInfo!
  totalCount: Int!
}

type VerifiableDomainEdge {
  cursor: String!
  node: VerifiableDomain
}

input VerifiableDomainOrder {
  field: VerifiableDomainOrderField!
  direction: OrderDirection!
}

enum VerifiableDomainOrderField {
  DOMAIN
  CREATED_AT
}

union VerifiableDomainOwner = Enterprise | Organization

input VerifyVerifiableDomainInput {
  clientMutationId: String
  id: ID!
}

type VerifyVerifiableDomainPayload {
  clientMutationId: String
  domain: VerifiableDomain
}

type ViewerHovercardContext implements HovercardContext {
  message: String!
  octicon: String!
  viewer: User!
}

interface Votable {
  upvoteCount: Int!
  viewerCanUpvote: Boolean!
  viewerHasUpvoted: Boolean!
}

type Workflow implements Node & UniformResourceLocatable {
  createdAt: DateTime!
  databaseId: Int
  id: ID!
  name: String!
  resourcePath: URI!
  runs(after: WorkflowRunConnection!, before: WorkflowRunConnection!, first: WorkflowRunConnection!, last: WorkflowRunConnection!, orderBy: WorkflowRunConnection!): WorkflowRunConnection!
  state: WorkflowState!
  updatedAt: DateTime!
  url: URI!
}

type WorkflowFileReference {
  path: String!
  ref: String
  repositoryId: Int!
  sha: String
}

input WorkflowFileReferenceInput {
  path: String!
  ref: String
  repositoryId: Int!
  sha: String
}

type WorkflowRun implements Node & UniformResourceLocatable {
  checkSuite: CheckSuite!
  createdAt: DateTime!
  databaseId: Int
  deploymentReviews(after: DeploymentReviewConnection!, before: DeploymentReviewConnection!, first: DeploymentReviewConnection!, last: DeploymentReviewConnection!): DeploymentReviewConnection!
  event: String!
  file: WorkflowRunFile
  id: ID!
  pendingDeploymentRequests(after: DeploymentRequestConnection!, before: DeploymentRequestConnection!, first: DeploymentRequestConnection!, last: DeploymentRequestConnection!): DeploymentRequestConnection!
  resourcePath: URI!
  runNumber: Int!
  updatedAt: DateTime!
  url: URI!
  workflow: Workflow!
}

type WorkflowRunConnection {
  edges: [WorkflowRunEdge]
  nodes: [WorkflowRun]
  pageInfo: PageInfo!
  totalCount: Int!
}

type WorkflowRunEdge {
  cursor: String!
  node: WorkflowRun
}

type WorkflowRunFile implements Node & UniformResourceLocatable {
  id: ID!
  path: String!
  repositoryFileUrl: URI!
  repositoryName: URI!
  resourcePath: URI!
  run: WorkflowRun!
  url: URI!
  viewerCanPushRepository: Boolean!
  viewerCanReadRepository: Boolean!
}

input WorkflowRunOrder {
  field: WorkflowRunOrderField!
  direction: OrderDirection!
}

enum WorkflowRunOrderField {
  CREATED_AT
}

enum WorkflowState {
  ACTIVE
  DELETED
  DISABLED_FORK
  DISABLED_INACTIVITY
  DISABLED_MANUALLY
}

type WorkflowsParameters {
  workflows: [WorkflowFileReference!]!
}

input WorkflowsParametersInput {
  workflows: []!
}

scalar X509Certificate

